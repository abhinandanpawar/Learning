# Java Notes Consolidation

## Become Java Expert in 20 days (Bosscoder).txt

Java
 Become


 EXpert
-----------------------Page 1 End-----------------------

   Day 1



Introduction and Setting Goals


Goals




Topics




Resources




                                 1
-----------------------Page 2 End-----------------------

Practice Questions




                     2
-----------------------Page 3 End-----------------------

   Day 2



Java Syntax and Variables


Goals




Topics




Resources




                            3
-----------------------Page 4 End-----------------------

Practice Questions




                     4
-----------------------Page 5 End-----------------------

   Day 3

Operators and Expressions
Goals


Topics




Resources




                            5
-----------------------Page 6 End-----------------------

Practice Questions




                     6
-----------------------Page 7 End-----------------------

   Day 4
Control Flow Statements
Goals

Topics



Resources




                          7
-----------------------Page 8 End-----------------------

Practice Questions




                     8
-----------------------Page 9 End-----------------------

   Day 5

Arrays and Strings
Goals


Topics




Resources




                     9
-----------------------Page 10 End-----------------------

Practice Questions




                     10
-----------------------Page 11 End-----------------------

Practice Questions




                     11
-----------------------Page 12 End-----------------------

Practice Questions




                     12
-----------------------Page 13 End-----------------------

   Day 6

Object-Oriented Programming

(OOP) Concepts
Goals


Topics



Resources




                               13
-----------------------Page 14 End-----------------------

Practice Questions




                     14
-----------------------Page 15 End-----------------------

   Day 7



Class Inheritance and Interfaces


Goals




Topics




Resources




                                   15
-----------------------Page 16 End-----------------------

Practice Questions




                     16
-----------------------Page 17 End-----------------------

   Day 8
Exception Handling
Goals

Topics



Resources




                     17
-----------------------Page 18 End-----------------------

Practice Questions




                     18
-----------------------Page 19 End-----------------------

   Day 9

Input and Output (I/O) Operations
Goals

Topics



Resources




                                    19
-----------------------Page 20 End-----------------------

Practice Questions




                     20
-----------------------Page 21 End-----------------------

  Day 10
Collections Framework
Goals


Topics



Resources




                        21
-----------------------Page 22 End-----------------------

Practice Questions




                     22
-----------------------Page 23 End-----------------------

  Day 11



Generics


Goals




Topics




Resources




            23
-----------------------Page 24 End-----------------------

Practice Questions




                     24
-----------------------Page 25 End-----------------------

  Day 12

Multithreading
Goals



Topics




Resources




                 25
-----------------------Page 26 End-----------------------

Practice Questions




                     26
-----------------------Page 27 End-----------------------

  Day 13
Lambda Expressions and

Functional Programming
Goals

Topics


Resources




                           27
-----------------------Page 28 End-----------------------

Practice Questions




                     28
-----------------------Page 29 End-----------------------

  Day 14
JDBC and Database Connectivity
Goals


Topics



Resources




                                 29
-----------------------Page 30 End-----------------------

Practice Questions




                     30
-----------------------Page 31 End-----------------------

  Day 15
GUI Development with Swing
Goals

Topics


Resources




                             31
-----------------------Page 32 End-----------------------

Practice Questions




                     32
-----------------------Page 33 End-----------------------

  Day 16

JavaFX and Modern

UI Development
Goals

Topics



Resources




                      33
-----------------------Page 34 End-----------------------

Practice Questions




                     34
-----------------------Page 35 End-----------------------

  Day 17

Unit Testing with JUnit
Goals


Topics



Resources




                          35
-----------------------Page 36 End-----------------------

Practice Questions




                     36
-----------------------Page 37 End-----------------------

  Day 18
Advanced Java Concepts
Goals

Topics



Resources




                         37
-----------------------Page 38 End-----------------------

Practice Questions




                     38
-----------------------Page 39 End-----------------------

  Day 19

Java Best Practices and

Code Quality
Goals


Topics



Resources




                           39
-----------------------Page 40 End-----------------------

Practice Questions




                     40
-----------------------Page 41 End-----------------------

  Day 20
Project Development and

Real-World Applications
Goals


Topics



Resources




                            41
-----------------------Page 42 End-----------------------

Practice Questions




                     42
-----------------------Page 43 End-----------------------

      Why

   Bosscoder?
750+ Alumni placed at Top
Product-based companies.

More than 136% hike for every

2 out of 3 working professional.

Average package of 24LPA.




                       .




       Explore More
-----------------------Page 44 End-----------------------

## Java Coding Interview Programs.txt

Coding Interview in
      Java
     Program Creek

        May 1st, 2016




           Page 290 of 496
-----------------------Page 1 End-----------------------

                                                                 Contents


121 Java PriorityQueue Class Example                                 295

122 Binary Tree Preorder Traversal                                   297

123 Binary Tree Inorder Traversal                                    299

124 Binary Tree Postorder Traversal                                  303

125 Binary Tree Level Order Traversal                                307

126 Binary Tree Level Order Traversal II                             309

127 Binary Tree Vertical Order Traversal                             311

128 Invert Binary Tree                                               313

129 Kth Smallest Element in a BST                                    315

130 Binary Tree Longest Consecutive Sequence                         317

131 Validate Binary Search Tree                                      321

132 Flatten Binary Tree to Linked List                               323

133 Path Sum                                                         325

134 Path Sum II                                                      327

135 Construct Binary Tree from Inorder and Postorder Traversal       329

136 Construct Binary Tree from Preorder and Inorder Traversal        331

137 Convert Sorted Array to Binary Search Tree                       333

138 Convert Sorted List to Binary Search Tree                        335

139 Minimum Depth of Binary Tree                                     337

140 Binary Tree Maximum Path Sum                                     339

141 Balanced Binary Tree                                             341

142 Symmetric Tree                                                   343

143 Binary Search Tree Iterator                                      345

144 Binary Tree Right Side View                                      347

145 Lowest Common Ancestor of a Binary Search Tree                   349



                                  Program Creek                   7 | 531

                                      Page 291 of 496
-----------------------Page 2 End-----------------------

Contents


146 Lowest Common Ancestor of a Binary Tree                    351

147 Verify Preorder Serialization of a Binary Tree             353

148 Populating Next Right Pointers in Each Node                355

149 Populating Next Right Pointers in Each Node II             357

150 Unique Binary Search Trees                                 359

151 Unique Binary Search Trees II                              361

152 Sum Root to Leaf Numbers                                   363

153 Count Complete Tree Nodes                                  365

154 Closest Binary Search Tree Value                           367

155 Binary Tree Paths                                          369

156 Merge K Sorted Arrays in Java                              371

157 Merge k Sorted Lists                                       373

158 Find Median from Data Stream                               375

159 Implement Trie (Prefix Tree)                               377

160 Add and Search Word Data structure design                  381

161 Range Sum Query Mutable                                    385

162 The Skyline Problem                                        389

163 Clone Graph Java                                           391

164 Course Schedule                                            395

165 Course Schedule II                                         399

166 Reconstruct Itinerary                                      401

167 How Developers Sort in Java?                               403

168 Solution Merge Sort LinkedList in Java                     405

169 Quicksort Array in Java                                    409

170 Solution Sort a linked list using insertion sort in Java   411



8 | 531                            Program Creek


                              Page 292 of 496
-----------------------Page 3 End-----------------------

                                                      Contents


171 Maximum Gap                                           415

172 First Missing Positive                                417

173 Sort Colors                                           419

174 Edit Distance in Java                                 421

175 Distinct Subsequences Total                           425

176 Longest Palindromic Substring                         427

177 Word Break                                            431

178 Word Break II                                         435

179 Maximum Subarray                                      439

180 Maximum Product Subarray                              441

181 Palindrome Partitioning                               443

182 Palindrome Partitioning II                            447

183 House Robber                                          449

184 House Robber II                                       451

185 House Robber III                                      453

186 Jump Game                                             455

187 Jump Game II                                          457

188 Best Time to Buy and Sell Stock                       459

189 Best Time to Buy and Sell Stock II                    461

190 Best Time to Buy and Sell Stock III                   463

191 Best Time to Buy and Sell Stock IV                    465

192 Dungeon Game                                          467

193 Decode Ways                                           469

194 Longest Common Subsequence                            471

195 Longest Common Substring                              473



                                  Program Creek        9 | 531

                                    Page 293 of 496
-----------------------Page 4 End-----------------------

Contents


196 Longest Increasing Subsequence             475

197 Coin Change                                479

198 Single Number                              481

199 Single Number II                           483

200 Twitter Codility Problem Max Binary Gap    485

201 Number of 1 Bits                           487

202 Reverse Bits                               489

203 Repeated DNA Sequences                     491

204 Bitwise AND of Numbers Range               493

205 Power of Two                               495

206 Counting Bits                              497

207 Maximum Product of Word Lengths            499

208 Permutations                               501

209 Permutations II                            505

210 Permutation Sequence                       507

211 Generate Parentheses                       509

212 Combination Sum                            511

213 Combination Sum II                         513

214 Combination Sum III                        515

215 Combinations                               517

216 Letter Combinations of a Phone Number      521

217 Restore IP Addresses                       523

218 Reverse Integer                            525

219 Palindrome Number                          527

220 Pow(x, n)                                  529




10 | 531                       Program Creek


                           Page 294 of 496
-----------------------Page 5 End-----------------------

121 Java PriorityQueue Class Example

In Java, the PriorityQueue class is implemented as a priority heap. Heap is an impor-
tant data structure in computer science. For a quick overview of heap, here is a very
good tutorial.


121.1 Simple Example

The following examples shows the basic operations of PriorityQueue such as offer(),
peek(), poll(), and size().
import java.util.Comparator;
import java.util.PriorityQueue;

public class PriorityQueueTest {

  static class PQsort implements Comparator<Integer> {

      public int compare(Integer one, Integer two) {
        return two - one;
      }
  }

  public static void main(String[] args) {
    int[] ia = { 1, 10, 5, 3, 4, 7, 6, 9, 8 };
    PriorityQueue<Integer> pq1 = new PriorityQueue<Integer>();

      // use offer() method to add elements to the PriorityQueue pq1
      for (int x : ia) {
        pq1.offer(x);
      }

      System.out.println("pq1: " + pq1);

      PQsort pqs = new PQsort();
      PriorityQueue<Integer> pq2 = new PriorityQueue<Integer>(10, pqs);
      // In this particular case, we can simply use Collections.reverseOrder()
      // instead of self-defined comparator
      for (int x : ia) {
        pq2.offer(x);
      }

      System.out.println("pq2: " + pq2);




                                                                           295 | 531

                                      Page 295 of 496
-----------------------Page 6 End-----------------------

121 Java PriorityQueue Class Example




        // print size
        System.out.println("size: " + pq2.size());
        // return highest priority element in the queue without removing it
        System.out.println("peek: " + pq2.peek());
        // print size
        System.out.println("size: " + pq2.size());
        // return highest priority element and removes it from the queue
        System.out.println("poll: " + pq2.poll());
        // print size
        System.out.println("size: " + pq2.size());

        System.out.print("pq2: " + pq2);

    }
}


    Output:
pq1: [1, 3, 5, 8, 4, 7, 6, 10, 9]
pq2: [10, 9, 7, 8, 3, 5, 6, 1, 4]
size: 9
peek: 10
size: 9
poll: 10
size: 8
pq2: [9, 8, 7, 4, 3, 5, 6, 1]




121.2 Example of Solving Problems Using PriorityQueue

Merging k sorted list.
 For more details about PriorityQueue, please go to doc.




296 | 531                           Program Creek


                                Page 296 of 496
-----------------------Page 7 End-----------------------

122 Binary Tree Preorder Traversal

122.1 Analysis

Preorder binary tree traversal is a classic interview problem about trees. The key to
solve this problem is to understand the following:

   • What is preorder? (parent node is processed before its children)
   • Use Stack from Java Core library

  The key is using a stack to store left and right children, and push right child first so
that it is processed after the left child.


122.2 Java Solution

public class TreeNode {
   int val;
   TreeNode left;
   TreeNode right;
   TreeNode(int x) { val = x; }
}

public class Solution {
   public ArrayList<Integer> preorderTraversal(TreeNode root) {
      ArrayList<Integer> returnList = new ArrayList<Integer>();

      if(root == null)
         return returnList;

      Stack<TreeNode> stack = new Stack<TreeNode>();
      stack.push(root);

      while(!stack.empty()){
         TreeNode n = stack.pop();
         returnList.add(n.val);

          if(n.right != null){
             stack.push(n.right);
          }
          if(n.left != null){
             stack.push(n.left);
          }




                                                                                297 | 531

                                        Page 297 of 496
-----------------------Page 8 End-----------------------

122 Binary Tree Preorder Traversal




        }
        return returnList;
    }
}




298 | 531                            Program Creek


                               Page 298 of 496
-----------------------Page 9 End-----------------------

123 Binary Tree Inorder Traversal

There are 3 solutions for solving this problem.


123.1 Java Solution 1 - Iterative

The key to solve inorder traversal of binary tree includes the following:

   • The order of "inorder" is: left child ->parent ->right child
   • Use a stack to track nodes
   • Understand when to push node into the stack and when to pop node out of the
     stack




//Definition for binary tree
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
 }

public class Solution {
   public ArrayList<Integer> inorderTraversal(TreeNode root) {
      // IMPORTANT: Please reset any member data you declared, as
      // the same Solution instance will be reused for each test case.




                                                                            299 | 531

                                        Page 299 of 496
-----------------------Page 10 End-----------------------

123 Binary Tree Inorder Traversal


        ArrayList<Integer> lst = new ArrayList<Integer>();

        if(root == null)
           return lst;

        Stack<TreeNode> stack = new Stack<TreeNode>();
        //define a pointer to track nodes
        TreeNode p = root;

        while(!stack.empty() || p != null){

            // if it is not null, push to stack
            //and go down the tree to left
            if(p != null){
               stack.push(p);
               p = p.left;

            // if no left child
            // pop stack, process the node
            // then let p point to the right
            }else{
               TreeNode t = stack.pop();
               lst.add(t.val);
               p = t.right;
            }
        }

        return lst;
    }
}




123.2 Java Solution 2 - Recursive

The recursive solution is trivial.
public class Solution {
   List<Integer> result = new ArrayList<Integer>();

    public List<Integer> inorderTraversal(TreeNode root) {
       if(root !=null){
          helper(root);
       }

        return result;
    }

    public void helper(TreeNode p){
       if(p.left!=null)




300 | 531                            Program Creek


                                 Page 300 of 496
-----------------------Page 11 End-----------------------

                                                    123 Binary Tree Inorder Traversal


          helper(p.left);

        result.add(p.val);

        if(p.right!=null)
           helper(p.right);
    }
}




123.3 Java Solution 3 - Simple

Updated on 4/28/2016
public List<Integer> inorderTraversal(TreeNode root) {
   List<Integer> result = new ArrayList<Integer>();
   if(root==null)
      return result;
   Stack<TreeNode> stack = new Stack<TreeNode>();
   stack.push(root);

    while(!stack.isEmpty()){
       TreeNode top = stack.peek();
       if(top.left!=null){
          stack.push(top.left);
          top.left=null;
       }else{
          result.add(top.val);
          stack.pop();
          if(top.right!=null){
             stack.push(top.right);
          }
       }
    }

    return result;
}




                                 Program Creek                             301 | 531

                                      Page 301 of 496
-----------------------Page 12 End-----------------------

124 Binary Tree Postorder Traversal

Among preoder, inorder and postorder binary tree traversal problems, postorder traver-
sal is the most complicated one.




124.1 Java Solution 1

The key to to iterative postorder traversal is the following:

   • The order of "Postorder" is: left child ->right child ->parent node.
   • Find the relation between the previously visited node and the current node
   • Use a stack to track nodes

  As we go down the tree to the lft, check the previously visited node. If the current
node is the left or right child of the previous node, then keep going down the tree, and
add left/right node to stack when applicable. When there is no children for current
node, i.e., the current node is a leaf, pop it from the stack. Then the previous node
become to be under the current node for next loop. You can using an example to walk
through the code.
//Definition for binary tree
public class TreeNode {
   int val;
   TreeNode left;
   TreeNode right;
   TreeNode(int x) { val = x; }
}



public class Solution {
   public ArrayList<Integer> postorderTraversal(TreeNode root) {

      ArrayList<Integer> lst = new ArrayList<Integer>();




                                                                              303 | 531

                                        Page 302 of 496
-----------------------Page 13 End-----------------------

124 Binary Tree Postorder Traversal


        if(root == null)
           return lst;

        Stack<TreeNode> stack = new Stack<TreeNode>();
        stack.push(root);

        TreeNode prev = null;
        while(!stack.empty()){
           TreeNode curr = stack.peek();

            // go down the tree.
            //check if current node is leaf, if so, process it and pop stack,
            //otherwise, keep going down
            if(prev == null || prev.left == curr || prev.right == curr){
               //prev == null is the situation for the root node
               if(curr.left != null){
                  stack.push(curr.left);
               }else if(curr.right != null){
                  stack.push(curr.right);
               }else{
                  stack.pop();
                  lst.add(curr.val);
               }

            //go up the tree from left node
            //need to check if there is a right child
            //if yes, push it to stack
            //otherwise, process parent and pop stack
            }else if(curr.left == prev){
               if(curr.right != null){
                  stack.push(curr.right);
               }else{
                  stack.pop();
                  lst.add(curr.val);
               }

            //go up the tree from right node
            //after coming back from right node, process parent node and pop
                stack.
            }else if(curr.right == prev){
               stack.pop();
               lst.add(curr.val);
            }

            prev = curr;
        }

        return lst;
    }
}




304 | 531                             Program Creek


                                Page 303 of 496
-----------------------Page 14 End-----------------------

                                                   124 Binary Tree Postorder Traversal


124.2 Java Solution 2 - Simple!

Thanks to Edmond. This solution is superior!
public List<Integer> postorderTraversal(TreeNode root) {
   List<Integer> res = new ArrayList<Integer>();

    if(root==null) {
       return res;
    }

    Stack<TreeNode> stack = new Stack<TreeNode>();
    stack.push(root);

    while(!stack.isEmpty()) {
       TreeNode temp = stack.peek();
       if(temp.left==null && temp.right==null) {
          TreeNode pop = stack.pop();
          res.add(pop.val);
       }
       else {
          if(temp.right!=null) {
             stack.push(temp.right);
             temp.right = null;
          }

            if(temp.left!=null) {
               stack.push(temp.left);
               temp.left = null;
            }
        }
    }

    return res;
}




                                   Program Creek                            305 | 531

                                        Page 304 of 496
-----------------------Page 15 End-----------------------

125 Binary Tree Level Order Traversal

Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left
to right, level by level).
  For example: Given binary tree 3,9,20,#,#,15,7,
3
     / \
    9 20
      / \
     15 7


    return its level order traversal as [[3], [9,20], [15,7]]


125.1 Analysis

It is obvious that this problem can be solve by using a queue. However, if we use one
queue we can not track when each level starts. So we use two queues to track the
current level and the next level.


125.2 Java Solution

public ArrayList<ArrayList<Integer>> levelOrder(TreeNode root) {
   ArrayList<ArrayList<Integer>> al = new ArrayList<ArrayList<Integer>>();
   ArrayList<Integer> nodeValues = new ArrayList<Integer>();
   if(root == null)
      return al;

     LinkedList<TreeNode> current = new LinkedList<TreeNode>();
     LinkedList<TreeNode> next = new LinkedList<TreeNode>();
     current.add(root);

     while(!current.isEmpty()){
        TreeNode node = current.remove();

        if(node.left != null)
           next.add(node.left);
        if(node.right != null)
           next.add(node.right);

        nodeValues.add(node.val);




                                                                                307 | 531

                                             Page 305 of 496
-----------------------Page 16 End-----------------------

125 Binary Tree Level Order Traversal


      if(current.isEmpty()){
         current = next;
         next = new LinkedList<TreeNode>();
         al.add(nodeValues);
         nodeValues = new ArrayList();
      }

    }
    return al;
}




308 | 531                          Program Creek


                               Page 306 of 496
-----------------------Page 17 End-----------------------

126 Binary Tree Level Order Traversal II

Given a binary tree, return the bottom-up level order traversal of its nodes’ values.
  For example, given binary tree 3,9,20,#,#,15,7,
3
     / \
    9 20
      / \
     15 7


    return its level order traversal as [[15,7], [9,20],[3]]


126.1 Java Solution

public List<ArrayList<Integer>> levelOrderBottom(TreeNode root) {
   ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();

     if(root == null){
        return result;
     }

     LinkedList<TreeNode> current = new LinkedList<TreeNode>();
     LinkedList<TreeNode> next = new LinkedList<TreeNode>();
     current.offer(root);

     ArrayList<Integer> numberList = new ArrayList<Integer>();

     // need to track when each level starts
     while(!current.isEmpty()){
        TreeNode head = current.poll();

        numberList.add(head.val);

        if(head.left != null){
           next.offer(head.left);
        }
        if(head.right!= null){
           next.offer(head.right);
        }

        if(current.isEmpty()){
           current = next;




                                                                              309 | 531

                                             Page 307 of 496
-----------------------Page 18 End-----------------------

126 Binary Tree Level Order Traversal II


            next = new LinkedList<TreeNode>();
            result.add(numberList);
            numberList = new ArrayList<Integer>();
        }
    }

    //return Collections.reverse(result);
    ArrayList<ArrayList<Integer>> reversedResult = new
        ArrayList<ArrayList<Integer>>();
    for(int i=result.size()-1; i>=0; i--){
       reversedResult.add(result.get(i));
    }

    return reversedResult;
}




310 | 531                            Program Creek


                                Page 308 of 496
-----------------------Page 19 End-----------------------

127 Binary Tree Vertical Order Traversal

Given a binary tree, return the vertical order traversal of its nodes’ values. (ie, from
top to bottom, column by column).


127.1 Java Solution

For each node, its left child’s degree is -1 and is right child’s degree is +1. We can do
a level order traversal and save the degree information.
class Wrapper{
   TreeNode node;
   int level;

    public Wrapper(TreeNode n, int l){
       node = n;
       level = l;
    }
}

public class Solution {
   public List<List<Integer>> verticalOrder(TreeNode root) {
      List<List<Integer>> result = new ArrayList<List<Integer>>();
      if(root==null)
         return result;

      LinkedList<Wrapper> queue = new LinkedList<Wrapper>();
      queue.offer(new Wrapper(root,0));

      TreeMap<Integer, ArrayList<Integer>> map = new TreeMap<Integer,
          ArrayList<Integer>>();

      while(!queue.isEmpty()){
         Wrapper w = queue.poll();

          TreeNode node = w.node;
          int level = w.level;

          if(map.containsKey(level)){
             map.get(level).add(node.val);
          }else{
             ArrayList<Integer> t = new ArrayList<Integer>();
             t.add(node.val);




                                                                               311 | 531

                                        Page 309 of 496
-----------------------Page 20 End-----------------------

127 Binary Tree Vertical Order Traversal


                map.put(level, t);
            }

            if(node.left!=null){
               queue.offer(new Wrapper(node.left, level-1));
            }

            if(node.right!=null){
               queue.offer(new Wrapper(node.right, level+1));
            }

        }

        for(Map.Entry<Integer, ArrayList<Integer>> entry: map.entrySet()){
           result.add(entry.getValue());
        }

        return result;
    }
}




312 | 531                            Program Creek


                                 Page 310 of 496
-----------------------Page 21 End-----------------------

128 Invert Binary Tree

      Google: 90
    Very funny. Luckily, I can and in 2 ways!


128.1 Java Solution 1 - Recursive

public TreeNode invertTree(TreeNode root) {
   if(root!=null){
      helper(root);
   }

     return root;
}

public void helper(TreeNode p){

     TreeNode temp = p.left;
     p.left = p.right;
     p.right = temp;

     if(p.left!=null)
        helper(p.left);

     if(p.right!=null)
        helper(p.right);
}




128.2 Java Solution 2 - Iterative

public TreeNode invertTree(TreeNode root) {
   LinkedList<TreeNode> queue = new LinkedList<TreeNode>();

     if(root!=null){
        queue.add(root);
     }

     while(!queue.isEmpty()){
        TreeNode p = queue.poll();
        if(p.left!=null)




                                                              313 | 531

                                        Page 311 of 496
-----------------------Page 22 End-----------------------

128 Invert Binary Tree


           queue.add(p.left);
        if(p.right!=null)
           queue.add(p.right);

        TreeNode temp = p.left;
        p.left = p.right;
        p.right = temp;
    }

    return root;
}




314 | 531                             Program Creek


                                  Page 312 of 496
-----------------------Page 23 End-----------------------

129 Kth Smallest Element in a BST

Given a binary search tree, write a function kthSmallest to find the kth smallest ele-
ment in it. (1 ≤ k ≤ BST’s total elements)


129.1 Java Solution 1 - Inorder Traversal

We can inorder traverse the tree and get the kth smallest element. Time is O(n).
public int kthSmallest(TreeNode root, int k) {
   Stack<TreeNode> stack = new Stack<TreeNode>();

    TreeNode p = root;
    int result = 0;

    while(!stack.isEmpty() || p!=null){
       if(p!=null){
          stack.push(p);
          p = p.left;
       }else{
          TreeNode t = stack.pop();
          k--;
          if(k==0)
             result = t.val;
          p = t.right;
       }
    }

    return result;
}




129.2 Java Solution 2 - Extra Data Structure

We can let each node track the order, i.e., the number of elements that are less than
itself. Time is O(log(n)).
   coming soon...




                                                                            315 | 531

                                       Page 313 of 496
-----------------------Page 24 End-----------------------

130 Binary Tree Longest Consecutive
    Sequence

Given a binary tree, find the length of the longest consecutive sequence path.
   The path refers to any sequence of nodes from some starting node to any node in
the tree along the parent-child connections. The longest consecutive path need to be
from parent to child (cannot be the reverse).


130.1 Java Solution 1 - Queue

public int longestConsecutive(TreeNode root) {
   if(root==null)
      return 0;

   LinkedList<TreeNode> nodeQueue = new LinkedList<TreeNode>();
   LinkedList<Integer> sizeQueue = new LinkedList<Integer>();

   nodeQueue.offer(root);
   sizeQueue.offer(1);
   int max=1;

   while(!nodeQueue.isEmpty()){
      TreeNode head = nodeQueue.poll();
      int size = sizeQueue.poll();

      if(head.left!=null){
         int leftSize=size;
         if(head.val==head.left.val-1){
            leftSize++;
            max = Math.max(max, leftSize);
         }else{
            leftSize=1;
         }

          nodeQueue.offer(head.left);
          sizeQueue.offer(leftSize);
      }

      if(head.right!=null){
         int rightSize=size;
         if(head.val==head.right.val-1){




                                                                          317 | 531

                                      Page 314 of 496
-----------------------Page 25 End-----------------------

130 Binary Tree Longest Consecutive Sequence


               rightSize++;
               max = Math.max(max, rightSize);
            }else{
               rightSize=1;
            }

            nodeQueue.offer(head.right);
            sizeQueue.offer(rightSize);
        }



    }

    return max;
}




130.2 Java Solution 2 - Recursion

public class Solution {
   int max=0;

    public int longestConsecutive(TreeNode root) {
       helper(root);
       return max;
    }

    public int helper(TreeNode root) {
       if(root==null)
          return 0;

        int l = helper(root.left);
        int r = helper(root.right);

        int fromLeft = 0;
        int fromRight= 0;

        if(root.left==null){
           fromLeft=1;
        }else if(root.left.val-1==root.val){
           fromLeft = l+1;
        }else{
           fromLeft=1;
        }

        if(root.right==null){
           fromRight=1;
        }else if(root.right.val-1==root.val){




318 | 531                           Program Creek


                                Page 315 of 496
-----------------------Page 26 End-----------------------

                                      130 Binary Tree Longest Consecutive Sequence


           fromRight = r+1;
        }else{
           fromRight=1;
        }

        max = Math.max(max, fromLeft);
        max = Math.max(max, fromRight);

        return Math.max(fromLeft, fromRight);
    }

}




                                  Program Creek                          319 | 531

                                     Page 316 of 496
-----------------------Page 27 End-----------------------

131 Validate Binary Search Tree

      Given a binary tree, determine if it is a valid binary search tree (BST).
    Assume a BST is defined as follows:

    • The left subtree of a node contains only nodes with keys less than the node’s key.
    • The right subtree of a node contains only nodes with keys greater than the node’s
      key.
    • Both the left and right subtrees must also be binary search trees.


131.1 Java Solution 1 - Recursive

All values on the left sub tree must be less than root, and all values on the right sub
tree must be greater than root. So we just check the boundaries for each node.
public boolean isValidBST(TreeNode root) {
   return isValidBST(root, Double.NEGATIVE_INFINITY,
       Double.POSITIVE_INFINITY);
}

public boolean isValidBST(TreeNode p, double min, double max){
   if(p==null)
      return true;

    if(p.val <= min || p.val >= max)
       return false;

    return isValidBST(p.left, min, p.val) && isValidBST(p.right, p.val, max);
}


  This solution also goes to the left subtree first. If the violation occurs close to the
root but on the right subtree, the method still cost O(n). The second solution below
can handle violations close to root node faster.


131.2 Java Solution 2 - Iterative

public class Solution {
   public boolean isValidBST(TreeNode root) {
      if(root == null)
         return true;




                                                                                  321 | 531

                                            Page 317 of 496
-----------------------Page 28 End-----------------------

131 Validate Binary Search Tree




      LinkedList<BNode> queue = new LinkedList<BNode>();
      queue.add(new BNode(root, Double.NEGATIVE_INFINITY,
          Double.POSITIVE_INFINITY));
      while(!queue.isEmpty()){
         BNode b = queue.poll();
         if(b.n.val <= b.left || b.n.val >=b.right){
            return false;
         }
         if(b.n.left!=null){
            queue.offer(new BNode(b.n.left, b.left, b.n.val));
         }
         if(b.n.right!=null){
            queue.offer(new BNode(b.n.right, b.n.val, b.right));
         }
      }
      return true;
   }
}
//define a BNode class with TreeNode and it’s boundaries
class BNode{
   TreeNode n;
   double left;
   double right;
   public BNode(TreeNode n, double left, double right){
      this.n = n;
      this.left = left;
      this.right = right;
   }
}




322 | 531                             Program Creek


                                  Page 318 of 496
-----------------------Page 29 End-----------------------

132 Flatten Binary Tree to Linked List

Given a binary tree, flatten it to a linked list in-place.
  For example, Given
1
        / \
       2 5
      / \ \
     3 4 6


    The flattened tree should look like:
1
     \
      2
       \
        3
         \
          4
           \
            5
             \
              6




132.1 Thoughts

Go down through the left, when right is not null, push right to stack.


132.2 Java Solution

/**
 * Definition for binary tree
 * public class TreeNode {
 *    int val;
 *    TreeNode left;
 *    TreeNode right;
 *    TreeNode(int x) { val = x; }
 *  }
 */
public class Solution {




                                                                         323 | 531

                                           Page 319 of 496
-----------------------Page 30 End-----------------------

132 Flatten Binary Tree to Linked List


    public void flatten(TreeNode root) {
       Stack<TreeNode> stack = new Stack<TreeNode>();
       TreeNode p = root;

        while(p != null || !stack.empty()){

            if(p.right != null){
               stack.push(p.right);
            }

            if(p.left != null){
               p.right = p.left;
               p.left = null;
            }else if(!stack.empty()){
               TreeNode temp = stack.pop();
               p.right=temp;
            }

            p = p.right;
        }
    }
}




324 | 531                             Program Creek


                                 Page 320 of 496
-----------------------Page 31 End-----------------------

133 Path Sum

Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that
adding up all the values along the path equals the given sum.
  For example: Given the below binary tree and sum = 22,
5
             / \
            4 8
           / / \
          11 13 4
         / \     \
        7    2    1


    return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.


133.1 Java Solution 1 - Using Queue

Add all node to a queue and store sum value of each node to another queue. When it
is a leaf node, check the stored sum value.
   For the tree above, the queue would be: 5 - 4 - 8 - 11 - 13 - 4 - 7 - 2 - 1. It will check
node 13, 7, 2 and 1. This is a typical breadth first search(BFS) problem.
/**
 * Definition for binary tree
 * public class TreeNode {
 *    int val;
 *    TreeNode left;
 *    TreeNode right;
 *    TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
       if(root == null) return false;

        LinkedList<TreeNode> nodes = new LinkedList<TreeNode>();
        LinkedList<Integer> values = new LinkedList<Integer>();

        nodes.add(root);
        values.add(root.val);

        while(!nodes.isEmpty()){




                                                                                   325 | 531

                                          Page 321 of 496
-----------------------Page 32 End-----------------------

133 Path Sum


             TreeNode curr = nodes.poll();
             int sumValue = values.poll();

             if(curr.left == null && curr.right == null && sumValue==sum){
                return true;
             }

             if(curr.left != null){
                nodes.add(curr.left);
                values.add(sumValue+curr.left.val);
             }

             if(curr.right != null){
                nodes.add(curr.right);
                values.add(sumValue+curr.right.val);
             }
         }

         return false;
     }
}




133.2 Java Solution 2 - Recursion

public boolean hasPathSum(TreeNode root, int sum) {
  if (root == null)
    return false;
  if (root.val == sum && (root.left == null && root.right == null))
    return true;

    return hasPathSum(root.left, sum - root.val)
        || hasPathSum(root.right, sum - root.val);
}


    Thanks to nebulaliang, this solution is wonderful!




326 | 531                            Program Creek


                                 Page 322 of 496
-----------------------Page 33 End-----------------------

134 Path Sum II

Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals
the given sum.
  For example, given the below binary tree and sum = 22,
5
             / \
            4 8
           / / \
          11 13 4
         / \    / \
        7    2 5 1


    the method returns the following:
[
    [5,4,11,2],
    [5,8,4,5]
]




134.1 Analysis

This problem can be converted to be a typical depth-first search problem. A recursive
depth-first search algorithm usually requires a recursive method call, a reference to
the final result, a temporary result, etc.


134.2 Java Solution

public List<ArrayList<Integer>> pathSum(TreeNode root, int sum) {
   ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();
   if(root == null)
      return result;

    ArrayList<Integer> l = new ArrayList<Integer>();
    l.add(root.val);
    dfs(root, sum-root.val, result, l);
    return result;
}




                                                                             327 | 531

                                        Page 323 of 496
-----------------------Page 34 End-----------------------

134 Path Sum II


public void dfs(TreeNode t, int sum, ArrayList<ArrayList<Integer>> result,
    ArrayList<Integer> l){
   if(t.left==null && t.right==null && sum==0){
      ArrayList<Integer> temp = new ArrayList<Integer>();
      temp.addAll(l);
      result.add(temp);
   }

    //search path of left node
    if(t.left != null){
       l.add(t.left.val);
       dfs(t.left, sum-t.left.val, result, l);
       l.remove(l.size()-1);
    }

    //search path of right node
    if(t.right!=null){
       l.add(t.right.val);
       dfs(t.right, sum-t.right.val, result, l);
       l.remove(l.size()-1);
    }
}




328 | 531                         Program Creek


                              Page 324 of 496
-----------------------Page 35 End-----------------------

135 Construct Binary Tree from Inorder
    and Postorder Traversal

Given inorder and postorder traversal of a tree, construct the binary tree.


135.1 Analysis

This problem can be illustrated by using a simple example.
in-order: 4 2 5 (1) 6 7 3 8
post-order: 4 5 2 6 7 8 3 (1)


   From the post-order array, we know that last element is the root. We can find the
root in in-order array. Then we can identify the left and right sub-trees of the root
from in-order array.
   Using the length of left sub-tree, we can identify left and right sub-trees in post-
order array. Recursively, we can build up the tree.




135.2 Java Solution

public TreeNode buildTree(int[] inorder, int[] postorder) {
  int inStart = 0;
  int inEnd = inorder.length - 1;
  int postStart = 0;
  int postEnd = postorder.length - 1;

    return buildTree(inorder, inStart, inEnd, postorder, postStart, postEnd);
}

public TreeNode buildTree(int[] inorder, int inStart, int inEnd,
    int[] postorder, int postStart, int postEnd) {




                                                                              329 | 531

                                        Page 325 of 496
-----------------------Page 36 End-----------------------

135 Construct Binary Tree from Inorder and Postorder Traversal


    if (inStart > inEnd || postStart > postEnd)
      return null;

    int rootValue = postorder[postEnd];
    TreeNode root = new TreeNode(rootValue);

    int k = 0;
    for (int i = 0; i < inorder.length; i++) {
      if (inorder[i] == rootValue) {
        k = i;
        break;
      }
    }

    root.left = buildTree(inorder, inStart, k - 1, postorder, postStart,
         postStart + k - (inStart + 1));
    // Becuase k is not the length, it it need to -(inStart+1) to get the length
    root.right = buildTree(inorder, k + 1, inEnd, postorder, postStart + k-
        inStart, postEnd - 1);
    // postStart+k-inStart = postStart+k-(inStart+1) +1

    return root;
}




330 | 531                          Program Creek


                               Page 326 of 496
-----------------------Page 37 End-----------------------

136 Construct Binary Tree from Preorder
    and Inorder Traversal

Given preorder and inorder traversal of a tree, construct the binary tree.


136.1 Analysis

Consider the following example:
in-order: 4 2 5 (1) 6 7 3 8
pre-order: (1) 2 4 5 3 7 6 8


   From the pre-order array, we know that first element is the root. We can find the
root in in-order array. Then we can identify the left and right sub-trees of the root
from in-order array.
   Using the length of left sub-tree, we can identify left and right sub-trees in pre-order
array. Recursively, we can build up the tree.




136.2 Java Solution

public   TreeNode buildTree(int[] preorder, int[] inorder) {
   int   preStart = 0;
   int   preEnd = preorder.length-1;
   int   inStart = 0;
   int   inEnd = inorder.length-1;

    return construct(preorder, preStart, preEnd, inorder, inStart, inEnd);
}

public TreeNode construct(int[] preorder, int preStart, int preEnd, int[]
    inorder, int inStart, int inEnd){




                                                                                 331 | 531

                                         Page 327 of 496
-----------------------Page 38 End-----------------------

136 Construct Binary Tree from Preorder and Inorder Traversal


    if(preStart>preEnd||inStart>inEnd){
       return null;
    }

    int val = preorder[preStart];
    TreeNode p = new TreeNode(val);

    //find parent element index from inorder
    int k=0;
    for(int i=0; i<inorder.length; i++){
       if(val == inorder[i]){
          k=i;
          break;
       }
    }

    p.left = construct(preorder, preStart+1, preStart+(k-inStart), inorder,
        inStart, k-1);
    p.right= construct(preorder, preStart+(k-inStart)+1, preEnd, inorder, k+1
        , inEnd);

    return p;
}




332 | 531                          Program Creek


                               Page 328 of 496
-----------------------Page 39 End-----------------------

137 Convert Sorted Array to Binary
    Search Tree

Given an array where elements are sorted in ascending order, convert it to a height
balanced BST.


137.1 Thoughts

Straightforward! Recursively do the job.


137.2 Java Solution

// Definition for binary tree
class TreeNode {
  int val;
  TreeNode left;
  TreeNode right;

    TreeNode(int x) {
      val = x;
    }
}

public class Solution {
  public TreeNode sortedArrayToBST(int[] num) {
    if (num.length == 0)
       return null;

        return sortedArrayToBST(num, 0, num.length - 1);
    }

    public TreeNode sortedArrayToBST(int[] num, int start, int end) {
      if (start > end)
        return null;

        int mid = (start + end) / 2;
        TreeNode root = new TreeNode(num[mid]);
        root.left = sortedArrayToBST(num, start, mid - 1);
        root.right = sortedArrayToBST(num, mid + 1, end);

        return root;




                                                                         333 | 531

                                       Page 329 of 496
-----------------------Page 40 End-----------------------

137 Convert Sorted Array to Binary Search Tree


    }
}




334 | 531                          Program Creek


                               Page 330 of 496
-----------------------Page 41 End-----------------------

138 Convert Sorted List to Binary Search
    Tree

Given a singly linked list where elements are sorted in ascending order, convert it to a
height balanced BST.


138.1 Thoughts

If you are given an array, the problem is quite straightforward. But things get a little
more complicated when you have a singly linked list instead of an array. Now you no
longer have random access to an element in O(1) time. Therefore, you need to create
nodes bottom-up, and assign them to its parents. The bottom-up approach enables us
to access the list in its order at the same time as creating nodes.


138.2 Java Solution

// Definition for singly-linked list.
class ListNode {
  int val;
  ListNode next;

    ListNode(int x) {
      val = x;
      next = null;
    }
}

// Definition for binary tree
class TreeNode {
  int val;
  TreeNode left;
  TreeNode right;

    TreeNode(int x) {
      val = x;
    }
}

public class Solution {
  static ListNode h;




                                                                              335 | 531

                                        Page 331 of 496
-----------------------Page 42 End-----------------------

138 Convert Sorted List to Binary Search Tree




    public TreeNode sortedListToBST(ListNode head) {
      if (head == null)
        return null;

        h = head;
        int len = getLength(head);
        return sortedListToBST(0, len - 1);
    }

    // get list length
    public int getLength(ListNode head) {
      int len = 0;
      ListNode p = head;

        while (p != null) {
          len++;
          p = p.next;
        }
        return len;
    }

    // build tree bottom-up
    public TreeNode sortedListToBST(int start, int end) {
      if (start > end)
        return null;

        // mid
        int mid = (start + end) / 2;

        TreeNode left = sortedListToBST(start, mid - 1);
        TreeNode root = new TreeNode(h.val);
        h = h.next;
        TreeNode right = sortedListToBST(mid + 1, end);

        root.left = left;
        root.right = right;

        return root;
    }
}




336 | 531                              Program Creek


                                Page 332 of 496
-----------------------Page 43 End-----------------------

139 Minimum Depth of Binary Tree

Given a binary tree, find its minimum depth.
  The minimum depth is the number of nodes along the shortest path from the root
node down to the nearest leaf node.


139.1 Thoughts

LinkedList is a queue in Java. The add() and remove() methods are used to manipulate
the queue.


139.2 Java Solution

/**
 * Definition for binary tree
 * public class TreeNode {
 *    int val;
 *    TreeNode left;
 *    TreeNode right;
 *    TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int minDepth(TreeNode root) {
       if(root == null){
          return 0;
       }

      LinkedList<TreeNode> nodes = new LinkedList<TreeNode>();
      LinkedList<Integer> counts = new LinkedList<Integer>();

      nodes.add(root);
      counts.add(1);

      while(!nodes.isEmpty()){
         TreeNode curr = nodes.remove();
         int count = counts.remove();

         if(curr.left == null && curr.right == null){
            return count;
         }




                                                                          337 | 531

                                      Page 333 of 496
-----------------------Page 44 End-----------------------

139 Minimum Depth of Binary Tree




            if(curr.left != null){
               nodes.add(curr.left);
               counts.add(count+1);
            }

            if(curr.right != null){
               nodes.add(curr.right);
               counts.add(count+1);
            }
        }

        return 0;
    }
}




338 | 531                           Program Creek


                                Page 334 of 496
-----------------------Page 45 End-----------------------

140 Binary Tree Maximum Path Sum

Given a binary tree, find the maximum path sum. The path may start and end at any
node in the tree. For example, given the below binary tree
1
       / \
      2 3


    the result is 6.


140.1 Analysis

1) Recursively solve this problem 2) Get largest left sum and right sum 2) Compare to
the stored maximum


140.2 Java Solution

We can also use an array to store value for recursive methods.
public int maxPathSum(TreeNode root) {
  int max[] = new int[1];
  max[0] = Integer.MIN_VALUE;
  calculateSum(root, max);
  return max[0];
}

public int calculateSum(TreeNode root, int[] max) {
  if (root == null)
    return 0;

    int left = calculateSum(root.left, max);
    int right = calculateSum(root.right, max);

    int current = Math.max(root.val, Math.max(root.val + left, root.val +
        right));

    max[0] = Math.max(max[0], Math.max(current, left + root.val + right));

    return current;
}




                                                                           339 | 531

                                       Page 335 of 496
-----------------------Page 46 End-----------------------

141 Balanced Binary Tree

Given a binary tree, determine if it is height-balanced.
  For this problem, a height-balanced binary tree is defined as a binary tree in which
the depth of the two subtrees of every node never differ by more than 1.


141.1 Analysis

This is a typical tree problem that can be solve by using recursion.


141.2 Java Solution

// Definition for binary tree
class TreeNode {
  int val;
  TreeNode left;
  TreeNode right;

    TreeNode(int x) {
      val = x;
    }
}

public class Solution {
  public boolean isBalanced(TreeNode root) {
    if (root == null)
       return true;

        if (getHeight(root) == -1)
          return false;

        return true;
    }

    public int getHeight(TreeNode root) {
      if (root == null)
        return 0;

        int left = getHeight(root.left);
        int right = getHeight(root.right);

        if (left == -1 || right == -1)




                                                                            341 | 531

                                         Page 336 of 496
-----------------------Page 47 End-----------------------

141 Balanced Binary Tree


          return -1;

        if (Math.abs(left - right) > 1) {
          return -1;
        }

        return Math.max(left, right) + 1;

    }
}




342 | 531                           Program Creek


                                Page 337 of 496
-----------------------Page 48 End-----------------------

142 Symmetric Tree

142.1 Problem

Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its
center).
  For example, this binary tree is symmetric:
1
   / \
  2 2
 / \ / \
3 4 4 3


    But the following is not:
1
     / \
    2 2
     \ \
     3   3




142.2 Java Solution - Recursion

This problem can be solve by using a simple recursion. The key is finding the con-
ditions that return false, such as value is not equal, only one node(left or right) has
value.
public boolean isSymmetric(TreeNode root) {
  if (root == null)
    return true;
  return isSymmetric(root.left, root.right);
}

public boolean isSymmetric(TreeNode l, TreeNode r) {
  if (l == null && r == null) {
    return true;
  } else if (r == null || l == null) {
    return false;
  }

    if (l.val != r.val)




                                                                             343 | 531

                                       Page 338 of 496
-----------------------Page 49 End-----------------------

142 Symmetric Tree


      return false;

    if (!isSymmetric(l.left, r.right))
      return false;
    if (!isSymmetric(l.right, r.left))
      return false;

    return true;
}




344 | 531                         Program Creek


                              Page 339 of 496
-----------------------Page 50 End-----------------------

143 Binary Search Tree Iterator

143.1 Problem

Implement an iterator over a binary search tree (BST). Your iterator will be initialized
with the root node of a BST. Calling next() will return the next smallest number in
the BST. Note: next() and hasNext() should run in average O(1) time and uses O(h)
memory, where h is the height of the tree.


143.2 Java Solution

The key to solve this problem is understanding what is BST. Here is a diagram.




/**
 * Definition for binary tree
 * public class TreeNode {
 *   int val;
 *   TreeNode left;
 *   TreeNode right;
 *   TreeNode(int x) { val = x; }
 * }
 */

public class BSTIterator {
  Stack<TreeNode> stack;

  public BSTIterator(TreeNode root) {




                                                                              345 | 531

                                        Page 340 of 496
-----------------------Page 51 End-----------------------

143 Binary Search Tree Iterator


        stack = new Stack<TreeNode>();
        while (root != null) {
          stack.push(root);
          root = root.left;
        }
    }

    public boolean hasNext() {
      return !stack.isEmpty();
    }

    public int next() {
      TreeNode node = stack.pop();
      int result = node.val;
      if (node.right != null) {
        node = node.right;
        while (node != null) {
           stack.push(node);
           node = node.left;
        }
      }
      return result;
    }
}




346 | 531                             Program Creek


                                  Page 341 of 496
-----------------------Page 52 End-----------------------

144 Binary Tree Right Side View

Given a binary tree, imagine yourself standing on the right side of it, return the values
of the nodes you can see ordered from top to bottom. For example, given the following
binary tree,
1          <---
 / \
2   3        <---
 \
  5          <---


  You can see [1, 3, 5].


144.1 Analysis

This problem can be solve by using a queue. On each level of the tree, we add the
right-most element to the results.


144.2 Java Solution

public List<Integer> rightSideView(TreeNode root) {
   ArrayList<Integer> result = new ArrayList<Integer>();

   if(root == null) return result;

   LinkedList<TreeNode> queue = new LinkedList<TreeNode>();
   queue.add(root);

   while(queue.size() > 0){
      //get size here
      int size = queue.size();

        for(int i=0; i<size; i++){
           TreeNode top = queue.remove();

          //the first element in the queue (right-most of the tree)
          if(i==0){
             result.add(top.val);
          }
          //add right first
          if(top.right != null){




                                                                               347 | 531

                                        Page 342 of 496
-----------------------Page 53 End-----------------------

144 Binary Tree Right Side View


              queue.add(top.right);
            }
            //add left
            if(top.left != null){
               queue.add(top.left);
            }
        }
    }

    return result;
}




348 | 531                             Program Creek


                                  Page 343 of 496
-----------------------Page 54 End-----------------------

145 Lowest Common Ancestor of a
    Binary Search Tree

Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given
nodes in the BST.


145.1 Analysis

This problem can be solved by using BST property, i.e., left <parent <right for each
node. There are 3 cases to handle.


145.2 Java Solution

public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
   TreeNode m = root;

    if(m.val > p.val && m.val < q.val){
       return m;
    }else if(m.val>p.val && m.val > q.val){
       return lowestCommonAncestor(root.left, p, q);
    }else if(m.val<p.val && m.val < q.val){
       return lowestCommonAncestor(root.right, p, q);
    }

    return root;
}




                                                                          349 | 531

                                      Page 344 of 496
-----------------------Page 55 End-----------------------

146 Lowest Common Ancestor of a
    Binary Tree

Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the
tree.


146.1 Java Solution 1

Please use the following diagram to walk through the solution.




  Since each node is visited in the worst case, time complexity is O(n).
class Entity{
   public int count;
   public TreeNode node;

   public Entity(int count, TreeNode node){
      this.count = count;
      this.node = node;
   }




                                                                           351 | 531

                                       Page 345 of 496
-----------------------Page 56 End-----------------------

146 Lowest Common Ancestor of a Binary Tree


}

public class Solution {
   public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode
       q) {
      return lcaHelper(root, p, q).node;
   }

    public Entity lcaHelper(TreeNode root, TreeNode p, TreeNode q){
       if(root == null) return new Entity(0, null);

        Entity left = lcaHelper(root.left, p, q);
        if(left.count==2)
           return left;

        Entity right = lcaHelper(root.right,p,q);
        if(right.count==2)
           return right;

        int numTotal = left.count + right.count;
        if(root== p || root == q){
           numTotal++;
        }

        return new Entity(numTotal, root);
    }
}




146.2 Java Solution 2

public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
   if(root == null || root == p || root == q) return root;
   TreeNode left = lowestCommonAncestor(root.left, p, q);
   TreeNode right = lowestCommonAncestor(root.right, p, q);
   if(left!=null&&right!=null) return root;
   return left == null ? right : left;
}




352 | 531                          Program Creek


                               Page 346 of 496
-----------------------Page 57 End-----------------------

## Java Programming Cheatsheet.txt

Java Programming Cheatsheet - AMAN BARNWAL

Hello, World.




Editing, compiling, and executing.




Built-in data types.




Declaration and assignment statements.




Integers.
-----------------------Page 1 End-----------------------

Floating-point numbers.




Booleans.
-----------------------Page 2 End-----------------------

Comparison operators.




Printing.




Parsing command-line arguments.




Math library.
-----------------------Page 3 End-----------------------

The full java.lang.Math API.



Java library calls.




Type conversion.
-----------------------Page 4 End-----------------------

Anatomy of an if statement.




If and if-else statements.




Nested if-else statement.
-----------------------Page 5 End-----------------------

Anatomy of a while loop.




Anatomy of a for loop.




Loops.
-----------------------Page 6 End-----------------------

Break statement.




Do-while loop.




Switch statement.
-----------------------Page 7 End-----------------------

Arrays.




Inline array initialization.




Typical array-processing code.




Two-dimensional arrays.
-----------------------Page 8 End-----------------------

Inline initialization.




Our standard output library.




The full StdOut API.



Formatted printing.
-----------------------Page 9 End-----------------------

Our standard input library.




The full StdIn API.



Our standard drawing library.
-----------------------Page 10 End-----------------------

The full StdDraw API.



Our standard audio library.




The full StdAudio API.



Command line.
-----------------------Page 11 End-----------------------

Redirection and piping.





    
    
    





Functions.
-----------------------Page 12 End-----------------------

Libraries of functions.
-----------------------Page 13 End-----------------------

Our standard random library.




The full StdRandom API.



Our standard statistics library.
-----------------------Page 14 End-----------------------

The full StdStats API.



Using an object.




Instance variables.




Constructors.




Instance methods.
-----------------------Page 15 End-----------------------

Classes.




Object-oriented libraries.
-----------------------Page 16 End-----------------------

Java's String data type.
-----------------------Page 17 End-----------------------

The full java.lang.String API.




Java's Color data type.
-----------------------Page 18 End-----------------------

The full java.awt.Color API.



Our input library.




The full In API.



Our output library.
-----------------------Page 19 End-----------------------

The full Out API.



Our picture library.




The full Picture API.



Our stack data type.




The full Stack API.



Our queue data type.




The full Queue API.
-----------------------Page 20 End-----------------------

Iterable.




Our symbol table data type.




The full ST API.



Our set data type.
-----------------------Page 21 End-----------------------

The full SET API.



Our graph data type.




The full Graph API.
-----------------------Page 22 End-----------------------

## Java interview Questions.txt

                   JAVA
Basic & Advanced OOPs Interview Questions

               BY – VIKAS MAURYA

                    YOUTUBE

               1. CODE WITH VIKAS

             2. VIKAS MAUYA ACADEMY
-----------------------Page 1 End-----------------------

    1. What is meant by the term OOPs?
    OOPs refers to Object-Oriented Programming. It is the programming paradigm that is defined using objects. Objects can be
    considered as real-world instances of entities like class, that have some characteristics and behaviors.

    2. What is the need for OOPs?
    There are many reasons why OOPs is mostly preferred, but the most important among them are:

    OOPs helps users to understand the software easily, although they don’t know the actual implementation.

•   With OOPs, the readability, understandability, and maintainability of the code increase multifold.
•   Even very big software can be easily written and managed easily using OOPs.

    3. What are some major Object Oriented Programming languages?
    The programming languages that use and follow the Object-Oriented Programming paradigm or OOPs, are known as Object-
    Oriented Programming languages. Some of the major Object-Oriented Programming languages include:

•   Java
•   C++
•   Javascript
•   Python
•   PHP

    And many more.

    4.What are some other programming paradigms other than OOPs?
    Programming paradigms refers to the method of classification of programming languages based on their features. There are
    mainly two types of Programming Paradigms:

•   Imperative Programming Paradigm
•   Declarative Programming Paradigm

    Now, these paradigms can be further classified based:

    1. Imperative Programming Paradigm:

    Imperative programming focuses on HOW to execute program logic and defines control flow as statements that change a
    program state. This can be further classified as:


    a) Procedural Programming Paradigm: Procedural programming specifies the steps a program must take to reach the desired
    state, usually read in order from top to bottom.


    b) Object-Oriented Programming or OOP: Object-oriented programming (OOP) organizes programs as objects, that contain
    some data and have some behavior.
-----------------------Page 2 End-----------------------

    c) Parallel Programming: Parallel programming paradigm breaks a task into subtasks and focuses on executing them
    simultaneously at the same time.




    2. Declarative Programming Paradigm:

    Declarative programming focuses on WHAT to execute and defines program logic, but not a detailed control flow.
    Declarative paradigm can be further classified into:


    a) Logical Programming Paradigm: Logical programming paradigm is based on formal logic, which refers to a set of
    sentences expressing facts and rules about how to solve a problem
    b) Functional Programming Paradigm: Functional programming is a programming paradigm where programs are constructed
    by applying and composing functions.


    c) Database Programming Paradigm: Database programming model is used to manage data and information structured as
    fields, records, and files.




    5. What is meant by Structured Programming?
    Structured Programming refers to the method of programming which consists of a completely structured control flow. Here
    structure refers to a block, which contains a set of rules, and has a definitive control flow, such as (if/then/else), (while and
    for), block structures, and subroutines.

    Nearly all programming paradigms include Structured programming, including the OOPs model.

    6. What are the main features of OOPs?
    OOPs or Object Oriented Programming mainly comprises of the below four features, and make sure you don't miss any of
    these:

•   Inheritance
•   Encapsulation
•   Polymorphism
•   Data Abstraction

    7. What are some advantages of using OOPs?
•   OOPs is very helpful in solving very complex level of problems.
•   Highly complex programs can be created, handled, and maintained easily using object-oriented programming.
•   OOPs, promote code reuse, thereby reducing redundancy.
•   OOPs also helps to hide the unnecessary details with the help of Data Abstraction.
•   OOPs, are based on a bottom-up approach, unlike the Structural programming paradigm, which uses a top-down approach.
•   Polymorphism offers a lot of flexibility in OOPs.

    8. Why is OOPs so popular?
    OOPs programming paradigm is considered as a better style of programming. Not only it helps in writing a complex piece of
    code easily, but it also allows users to handle and maintain them easily as well. Not only that, the main pillar of OOPs - Data
-----------------------Page 3 End-----------------------

Abstraction, Encapsulation, Inheritance, and Polymorphism, makes it easy for programmers to solve complex scenarios. As a
result of these, OOPs is so popular.




                                      Advanced OOPs Interview Questions

9. What is a class?
A class can be understood as a template or a blueprint, which contains some values, known as member data or member, and
some set of rules, known as behaviors or functions. So when an object is created, it automatically takes the data and functions
that are defined in the class.
Therefore the class is basically a template or blueprint for objects. Also one can create as many objects as they want based on a
class. For example, first, a car’s template is created. Then multiple units of car are created based on that template.

10. What is an object?
An object refers to the instance of the class, which contains the instance of the members and behaviors defined in the class
template. In the real world, an object is an actual entity to which a user interacts, whereas class is just the blueprint for that
object. So the objects consume space and have some characteristic behavior.
For example, a specific car.




11. What is encapsulation?
visualize Encapsulation as the method of putting everything that is required to do the job, inside a capsule and presenting that
capsule to the user. What it means is that by Encapsulation, all the necessary data and methods are bind together and all the
unnecessary details are hidden to the normal user. So Encapsulation is the process of binding data members and methods of a
program together to do a specific job, without revealing unnecessary details.

Encapsulation can also be defined in two different ways:

1) Data hiding: Encapsulation is the process of hiding unwanted information, such as restricting access to any member of an
object.

2) Data binding: Encapsulation is the process of binding the data members and the methods together as a whole, as a class.




12. What is Polymorphism?
Polymorphism is composed of two words - “poly” which means “many”, and “morph” which means “shapes”. Therefore
Polymorphism refers to something that has many shapes.

In OOPs, Polymorphism refers to the process by which some code, data, method, or object behaves differently under different
circumstances or contexts. Compile-time polymorphism and Run time polymorphism are the two types of polymorphisms in
OOPs languages.

13. What is Compile time Polymorphism and how is it different from Runtime
Polymorphism?
-----------------------Page 4 End-----------------------

    Compile Time Polymorphism: Compile time polymorphism, also known as Static Polymorphism, refers to the type of
    Polymorphism that happens at compile time. What it means is that the compiler decides what shape or value has to be taken
    by the entity in the picture.g


    14. How does C++ support Polymorphism?
    C++ is an Object-oriented programming language and it supports Polymorphism as well:

•   Compile Time Polymorphism: C++ supports compile-time polymorphism with the help of features like templates, function
    overloading, and default arguments.
•   Runtime Polymorphism: C++ supports Runtime polymorphism with the help of features like virtual functions. Virtual
    functions take the shape of the functions based on the type of object in reference and are resolved at runtime.

    15. What is meant by Inheritance?
    The term “inheritance” means “receiving some quality or behavior from a parent to an offspring.” In object-oriented
    programming, inheritance is the mechanism by which an object or class (referred to as a child) is created using the definition of
    another object or class (referred to as a parent). Inheritance not only helps to keep the implementation simpler but also helps to
    facilitate code reuse.

    16. What is Abstraction?
    If you are a user, and you have a problem statement, you don't want to know how the components of the software work, or how
    it's made. You only want to know how the software solves your problem. Abstraction is the method of hiding unnecessary
    details from the necessary ones. It is one of the main features of OOPs.
    For example, consider a car. You only need to know how to run a car, and not how the wires are connected inside it. This is
    obtained using Abstraction.




    17. How much memory does a class occupy?
    Classes do not consume any memory. They are just a blueprint based on which objects are created. Now when objects are
    created, they actually initialize the class members and methods and therefore consume memory.

    18. Is it always necessary to create objects from class?
    No. An object is necessary to be created if the base class has non-static methods. But if the class has static methods, then
    objects don’t need to be created. You can call the class method directly in this case, using the class name.

    19. What is a constructor?
    Constructors are special methods whose name is the same as the class name. The constructors serve the special purpose of
    initializing the objects.
    For example, suppose there is a class with the name “MyClass”, then when you instantiate this class, you pass the syntax:
    MyClass myClassObject = new MyClass();

    Now here, the method called after “new” keyword - MyClass(), is the constructor of this class. This will help to instantiate
    the member data and methods and assign them to the object myClassObject.

    21. What is a copy constructor?
    Copy Constructor is a type of constructor, whose purpose is to copy an object to another. What it means is that a copy
    constructor will clone an object and its values, into another object, is provided that both the objects are of the same class.
-----------------------Page 5 End-----------------------

    22. What is a destructor?
    Contrary to constructors, which initialize objects and specify space for them, Destructors are also special methods. But
    destructors free up the resources and memory occupied by an object. Destructors are automatically called when an object is
    being destroyed.

    23. Are class and structure the same? If not, what's the difference between a class
    and a structure?
    No, class and structure are not the same. Though they appear to be similar, they have differences that make them apart. For
    example, the structure is saved in the stack memory, whereas the class is saved in the heap memory. Also, Data Abstraction
    cannot be achieved with the help of structure, but with class, Abstraction is majorly used.

    24. Explain Inheritance with an example?
    Inheritance is one of the major features of object-oriented programming, by which an entity inherits some characteristics and
    behaviors of some other entity and makes them their own. Inheritance helps to improve and facilitate code reuse.

    Let me explain to you with a common example. Let's take three different vehicles - a car, truck, or bus. These three are entirely
    different from one another with their own specific characteristics and behavior. But. in all three, you will find some common
    elements, like steering wheel, accelerator, clutch, brakes, etc. Though these elements are used in different vehicles, still they
    have their own features which are common among all vehicles. This is achieved with inheritance. The car, the truck, and the
    bus have all inherited the features like steering wheel, accelerator, clutch, brakes, etc, and used them as their own. Due to this,
    they did not have to create these components from scratch, thereby facilitating code reuse.

    25. Are there any limitations of Inheritance?
    Yes, with more powers comes more complications. Inheritance is a very powerful feature in OOPs, but it has some limitations
    too. Inheritance needs more time to process, as it needs to navigate through multiple classes for its implementation. Also, the
    classes involved in Inheritance - the base class and the child class, are very tightly coupled together. So if one needs to make
    some changes, they might need to do nested changes in both classes. Inheritance might be complex for implementation, as
    well. So if not correctly implemented, this might lead to unexpected errors or incorrect outputs.

    26. What are the various types of inheritance?
    The various types of inheritance include:

•   Single inheritance
•   Multiple inheritances
•   Multi-level inheritance
•   Hierarchical inheritance
•   Hybrid inheritance

    27. What is a subclass?
    The subclass is a part of Inheritance. The subclass is an entity, which inherits from another class. It is also known as the child
    class.

    28. Define a superclass?
    Superclass is also a part of Inheritance. The superclass is an entity, which allows subclasses or child classes to inherit from
    itself.

    29. What is an interface?
-----------------------Page 6 End-----------------------

An interface refers to a special type of class, which contains methods, but not their definition. Only the declaration of methods
is allowed inside an interface. To use an interface, you cannot create objects. Instead, you need to implement that interface and
define the methods for their implementation.

30. What is meant by static polymorphism?
Static Polymorphism is commonly known as the Compile time polymorphism. Static polymorphism is the feature by which an
object is linked with the respective function or operator based on the values during the compile time. Static or Compile time
Polymorphism can be achieved through Method overloading or operator overloading.

31. What is meant by dynamic polymorphism?
Dynamic Polymorphism or Runtime polymorphism refers to the type of Polymorphism in OOPs, by which the actual
implementation of the function is decided during the runtime or execution. The dynamic or runtime polymorphism can be
achieved with the help of method overriding.

32. What is the difference between overloading and overriding?
Overloading is a compile-time polymorphism feature in which an entity has multiple implementations with the same name. For
example, Method overloading and Operator overloading.

Whereas Overriding is a runtime polymorphism feature in which an entity has the same name, but its implementation changes
during execution. For example, Method overriding.



33. How is data abstraction accomplished?
Data abstraction is accomplished with the help of abstract methods or abstract classes.




34. What is an abstract class?
An abstract class is a special class containing abstract methods. The significance of abstract class is that the abstract methods
inside it are not implemented and only declared. So as a result, when a subclass inherits the abstract class and needs to use its
abstract methods, they need to define and implement them.

35. How is an abstract class different from an interface?
Interface and abstract class both are special types of classes that contain only the methods declaration and not their
implementation. But the interface is entirely different from an abstract class. The main difference between the two is that,
when an interface is implemented, the subclass must define all its methods and provide its implementation. Whereas when an
abstract class is inherited, the subclass does not need to provide the definition of its abstract method, until and unless the
subclass is using it.

Also, an abstract class can contain abstract methods as well as non-abstract methods.

36. What are access specifiers and what is their significance?
Access specifiers, as the name suggests, are a special type of keywords, which are used to control or specify the accessibility of
entities like classes, methods, etc. Some of the access specifiers or access modifiers include “private”, “public”, etc. These
access specifiers also play a very vital role in achieving Encapsulation - one of the major features of OOPs.

37. What is an exception?
-----------------------Page 7 End-----------------------

    An exception can be considered as a special event, which is raised during the execution of a program at runtime, that brings the
    execution to a halt. The reason for the exception is mainly due to a position in the program, where the user wants to do
    something for which the program is not specified, like undesirable input.

    38. What is meant by exception handling?
    No one wants its software to fail or crash. Exceptions are the major reason for software failure. The exceptions can be handled
    in the program beforehand and prevent the execution from stopping. This is known as exception handling.
    So exception handling is the mechanism for identifying the undesirable states that the program can reach and specifying the
    desirable                        outcomes                          of                         such                       states.
    Try-catch is the most common method used for handling exceptions in the program.

    39. What is meant by Garbage Collection in OOPs world?
    Object-oriented programming revolves around entities like objects. Each object consumes memory and there can be multiple
    objects of a class. So if these objects and their memories are not handled properly, then it might lead to certain memory-related
    errors and the system might fail.

    Garbage collection refers to this mechanism of handling the memory in the program. Through garbage collection, the
    unwanted memory is freed up by removing the objects that are no longer needed.

    40. Can we run a Java application without implementing the OOPs concept?
    No. Java applications are based on Object-oriented programming models or OOPs concept, and hence they cannot be
    implemented without it.

    However, on the other hand, C++ can be implemented without OOPs, as it also supports the C-like structural programming
    model.




    1. Why is Java a platform independent language?

    Java language was developed in such a way that it does not depend on any hardware or software due to
    the fact that the compiler compiles the code and then converts it to platform-independent byte code
    which can be run on multiple systems.

•   The only condition to run that byte code is for the machine to have a runtime environment (JRE) installed
    in it

    2. Why is Java not a pure object oriented language?

    Java supports primitive data types - byte, boolean, char, short, int, float, long, and double and hence it is
    not a pure object oriented language.

    3. Difference between Heap and Stack Memory in java. And how java utilizes this.

    Stack memory is the portion of memory that was assigned to every individual program. And it was fixed.
    On the other hand, Heap memory is the portion that was not allocated to the java program but it will be
    available for use by the java program when it is required, mostly during the runtime of the program.
-----------------------Page 8 End-----------------------

## Java Interview Questions Notes (1).txt

Java Interview Questions                                                                                                     1 / 30




Chapter 1

Object Oriented Programming (OOP)

Java is a computer programming language that is concurrent, class-based and object-oriented. The advantages of object oriented
software development are shown below:

• Modular development of code, which leads to easy maintenance and modification.
• Reusability of code.
• Improved reliability and flexibility of code.
• Increased understanding of code.

Object-oriented programming contains many significant features, such as encapsulation, inheritance, polymorphism and ab-
straction. We analyze each feature separately in the following sections.


1.1     Encapsulation

Encapsulation provides objects with the ability to hide their internal characteristics and behavior. Each object provides a number
of methods, which can be accessed by other objects and change its internal data. In Java, there are three access modifiers: public,
private and protected. Each modifier imposes different access rights to other classes, either in the same or in external packages.
Some of the advantages of using encapsulation are listed below:

• The internal state of every objected is protected by hiding its attributes.
• It increases usability and maintenance of code, because the behavior of an object can be independently changed or extended.
• It improves modularity by preventing objects to interact with each other, in an undesired way.

You can refer to our tutorial here for more details and examples on encapsulation.


1.2     Polymorphism

Polymorphism is the ability of programming languages to present the same interface for differing underlying data types. A
polymorphic type is a type whose operations can also be applied to values of some other type.


1.3     Inheritance

Inheritance provides an object with the ability to acquire the fields and methods of another class, called base class. Inheritance
provides re-usability of code and can be used to add additional features to an existing class, without modifying it.
-----------------------Page 1 End-----------------------

Java Interview Questions                                                                                                       2 / 30




1.4     Abstraction

Abstraction is the process of separating ideas from specific instances and thus, develop classes in terms of their own functionality,
instead of their implementation details. Java supports the creation and existence of abstract classes that expose interfaces, without
including the actual implementation of all methods. The abstraction technique aims to separate the implementation details of a
class from its behavior.


1.5     Differences between Abstraction and Encapsulation

Abstraction and encapsulation are complementary concepts. On the one hand, abstraction focuses on the behavior of an object.
On the other hand, encapsulation focuses on the implementation of an object’s behavior. Encapsulation is usually achieved by
hiding information about the internal state of an object and thus, can be seen as a strategy used in order to provide abstraction.
-----------------------Page 2 End-----------------------

Java Interview Questions                                                                                                       3 / 30




Chapter 2


General Questions about Java


2.1     What is JVM ? Why is Java called the Platform Independent Programming Lan-
        guage?

A Java virtual machine (JVM) is a process virtual machine that can execute Java bytecode. Each Java source file is compiled
into a bytecode file, which is executed by the JVM. Java was designed to allow application programs to be built that could be
run on any platform, without having to be rewritten or recompiled by the programmer for each separate platform. A Java virtual
machine makes this possible, because it is aware of the specific instruction lengths and other particularities of the underlying
hardware platform.


2.2     What is the Difference between JDK and JRE ?

The Java Runtime Environment (JRE) is basically the Java Virtual Machine (JVM) where your Java programs are being executed.
It also includes browser plugins for applet execution. The Java Development Kit (JDK) is the full featured Software Development
Kit for Java, including the JRE, the compilers and tools (like JavaDoc, and Java Debugger), in order for a user to develop, compile
and execute Java applications.


2.3     What does the “static” keyword mean ? Can you override private or static
        method in Java ?

The static keyword denotes that a member variable or method can be accessed, without requiring an instantiation of the class to
which it belongs. A user cannot override static methods in Java, because method overriding is based upon dynamic binding at
runtime and static methods are statically binded at compile time. A static method is not associated with any instance of a class
so the concept is not applicable.


2.4     Can you access non static variable in static context ?

A static variable in Java belongs to its class and its value remains the same for all its instances. A static variable is initialized
when the class is loaded by the JVM. If your code tries to access a non-static variable, without any instance, the compiler will
complain, because those variables are not created yet and they are not associated with any instance.
-----------------------Page 3 End-----------------------

Java Interview Questions                                                                                                    4 / 30




2.5       What are the Data Types supported by Java ? What is Autoboxing and Unbox-
          ing ?

The eight primitive data types supported by the Java programming language are:

• byte
• short
• int
• long
• float
• double
• boolean
• char

Autoboxing is the automatic conversion made by the Java compiler between the primitive types and their corresponding object
wrapper classes. For example, the compiler converts an int to an Integer, a double to a Double, and so on. If the conversion goes
the other way, this operation is called unboxing.


2.6       What is Function Overriding and Overloading in Java ?

Method overloading in Java occurs when two or more methods in the same class have the exact same name, but different
parameters. On the other hand, method overriding is defined as the case when a child class redefines the same method as a parent
class. Overridden methods must have the same name, argument list, and return type. The overriding method may not limit the
access of the method it overrides.


2.7       What is a Constructor, Constructor Overloading in Java and Copy-Constructor

A constructor gets invoked when a new object is created. Every class has a constructor. In case the programmer does not provide
a constructor for a class, the Java compiler (Javac) creates a default constructor for that class. The constructor overloading is
similar to method overloading in Java. Different constructors can be created for a single class. Each constructor must have its
own unique parameter list. Finally, Java does support copy constructors like C++, but the difference lies in the fact that Java
doesn’t create a default copy constructor if you don’t write your own.


2.8       Does Java support multiple inheritance ?

No, Java does not support multiple inheritance. Each class is able to extend only on one class, but is able to implement more than
one interfaces.


2.9       What is the difference between an Interface and an Abstract class ?

Java provides and supports the creation both of abstract classes and interfaces. Both implementations share some common
characteristics, but they differ in the following features:

• All methods in an interface are implicitly abstract. On the other hand, an abstract class may contain both abstract and non-
  abstract methods.
-----------------------Page 4 End-----------------------

Java Interview Questions                                                                                                      5 / 30



• A class may implement a number of Interfaces, but can extend only one abstract class.
• In order for a class to implement an interface, it must implement all its declared methods. However, a class may not implement
  all declared methods of an abstract class. Though, in this case, the sub-class must also be declared as abstract.

• Abstract classes can implement interfaces without even providing the implementation of interface methods.
• Variables declared in a Java interface is by default final. An abstract class may contain non-final variables.
• Members of a Java interface are public by default. A member of an abstract class can either be private, protected or public.
• An interface is absolutely abstract and cannot be instantiated. An abstract class also cannot be instantiated, but can be invoked
  if it contains a main method.

Also check out the Abstract class and Interface differences for JDK 8.


2.10     What are pass by reference and pass by value ?

When an object is passed by value, this means that a copy of the object is passed. Thus, even if changes are made to that object,
it doesn’t affect the original value. When an object is passed by reference, this means that the actual object is not passed, rather
a reference of the object is passed. Thus, any changes made by the external method, are also reflected in all places.
-----------------------Page 5 End-----------------------

Java Interview Questions                                                                                                    6 / 30




Chapter 3


Java Threads


3.1     What is the difference between processes and threads ?

A process is an execution of a program, while a Thread is a single execution sequence within a process. A process can contain
multiple threads. A Thread is sometimes called a lightweight process.


3.2     Explain different ways of creating a thread. Which one would you prefer and
        why ?

There are three ways that can be used in order for a Thread to be created:

• A class may extend the Thread class.
• A class may implement the Runnable interface.
• An application can use the Executor framework, in order to create a thread pool.

The Runnable interface is preferred, as it does not require an object to inherit the Thread class. In case your application design
requires multiple inheritance, only interfaces can help you. Also, the thread pool is very efficient and can be implemented and
used very easily.


3.3     Explain the available thread states in a high-level.

During its execution, a thread can reside in one of the following states:

• Runnable: A thread becomes ready to run, but does not necessarily start running immediately.
• Running: The processor is actively executing the thread code.

• Waiting: A thread is in a blocked state waiting for some external processing to finish.
• Sleeping: The thread is forced to sleep.
• Blocked on I/O: Waiting for an I/O operation to complete.
• Blocked on Synchronization: Waiting to acquire a lock.

• Dead: The thread has finished its execution.
-----------------------Page 6 End-----------------------

Java Interview Questions                                                                                                   7 / 30




3.4    What is the difference between a synchronized method and a synchronized
       block ?

In Java programming, each object has a lock. A thread can acquire the lock for an object by using the synchronized keyword.
The synchronized keyword can be applied in a method level (coarse grained lock) or block level of code (fine grained lock).


3.5    How does thread synchronization occurs inside a monitor ? What levels of
       synchronization can you apply ?

The JVM uses locks in conjunction with monitors. A monitor is basically a guardian that watches over a sequence of synchronized
code and ensuring that only one thread at a time executes a synchronized piece of code. Each monitor is associated with an object
reference. The thread is not allowed to execute the code until it obtains the lock.


3.6    What’s a deadlock ?

A condition that occurs when two processes are waiting for each other to complete, before proceeding. The result is that both
processes wait endlessly.


3.7    How do you ensure that N threads can access N resources without deadlock ?

A very simple way to avoid deadlock while using N threads is to impose an ordering on the locks and force each thread to follow
that ordering. Thus, if all threads lock and unlock the mutexes in the same order, no deadlocks can arise.
-----------------------Page 7 End-----------------------

Java Interview Questions                                                                                                       8 / 30




Chapter 4

Java Collections


4.1     What are the basic interfaces of Java Collections Framework ?

Java Collections Framework provides a well designed set of interfaces and classes that support operations on a collections of
objects. The most basic interfaces that reside in the Java Collections Framework are:

• Collection, which represents a group of objects known as its elements.
• Set, which is a collection that cannot contain duplicate elements.
• List, which is an ordered collection and can contain duplicate elements.
• Map, which is an object that maps keys to values and cannot contain duplicate keys.


4.2     Why Collection doesn’t extend Cloneable and Serializable interfaces ?

The Collection interface specifies groups of objects known as elements. Each concrete implementation of a Collection can choose
its own way of how to maintain and order its elements. Some collections allow duplicate keys, while some other collections don’t.
The semantics and the implications of either cloning or serialization come into play when dealing with actual implementations.
Thus, the concrete implementations of collections should decide how they can be cloned or serialized.


4.3     What is an Iterator ?

The Iterator interface provides a number of methods that are able to iterate over any Collection. Each Java Collection contains
the iterator method that returns an Iterator instance. Iterators are capable of removing elements from the underlying collection
during the iteration.


4.4     What differences exist between Iterator and ListIterator ?

The differences of these elements are listed below:

• An Iterator can be used to traverse the Set and List collections, while the ListIterator can be used to iterate only over Lists.
• The Iterator can traverse a collection only in forward direction, while the ListIterator can traverse a List in both directions.
• The ListIterator implements the Iterator interface and contains extra functionality, such as adding an element, replacing an
  element, getting the index position for previous and next elements, etc.
-----------------------Page 8 End-----------------------

Java Interview Questions                                                                                                        9 / 30




4.5     What is difference between fail-fast and fail-safe ?

The Iterator’s fail-safe property works with the clone of the underlying collection and thus, it is not affected by any modification
in the collection. All the collection classes in java.util package are fail-fast, while the collection classes in java.util.concurrent
are fail-safe. Fail-fast iterators throw a ConcurrentModificationException, while fail-safe iterator never throws such
an exception.


4.6     How HashMap works in Java ?

A HashMap in Java stores key-value pairs. The HashMap requires a hash function and uses hashCode and equals methods,
in order to put and retrieve elements to and from the collection respectively. When the put method is invoked, the HashMap
calculates the hash value of the key and stores the pair in the appropriate index inside the collection. If the key exists, its value
is updated with the new value. Some important characteristics of a HashMap are its capacity, its load factor and the threshold
resizing.


4.7     What is the importance of hashCode() and equals() methods ?

In Java, a HashMap uses the hashCode and equals methods to determine the index of the key-value pair and to detect duplicates.
More specifically, the hashCode method is used in order to determine where the specified key will be stored. Since different keys
may produce the same hash value, the equals method is used, in order to determine whether the specified key actually exists in
the collection or not. Therefore, the implementation of both methods is crucial to the accuracy and efficiency of the HashMap.


4.8     What differences exist between HashMap and Hashtable ?

Both the HashMap and Hashtable classes implement the Map interface and thus, have very similar characteristics. However, they
differ in the following features:

• A HashMap allows the existence of null keys and values, while a Hashtable doesn’t allow neither null keys, nor null values.
• A Hashtable is synchronized, while a HashMap is not. Thus, HashMap is preferred in single-threaded environments, while a
  Hashtable is suitable for multi-threaded environments.

• A HashMap provides its set of keys and a Java application can iterate over them. Thus, a HashMap is fail-fast. On the other
  hand, a Hashtable provides an Enumeration of its keys.
• The Hashtable class is considered to be a legacy class.


4.9     What is difference between Array and ArrayList ? When will you use Array over
        ArrayList ?

The Array and ArrayList classes differ on the following features:

• Arrays can contain primitive or objects, while an ArrayList can contain only objects.

• Arrays have fixed size, while an ArrayList is dynamic.
• An ArrayList provides more methods and features, such as addAll, removeAll, iterator, etc.
• For a list of primitive data types, the collections use autoboxing to reduce the coding effort. However, this approach makes
  them slower when working on fixed size primitive data types.
-----------------------Page 9 End-----------------------

Java Interview Questions                                                                                                       10 / 30




4.10      What is difference between ArrayList and LinkedList ?

Both the ArrayList and LinkedList classes implement the List interface, but they differ on the following features:

• An ArrayList is an index based data structure backed by an Array. It provides random access to its elements with a performance
  equal to O(1). On the other hand, a LinkedList stores its data as list of elements and every element is linked to its previous and
  next element. In this case, the search operation for an element has execution time equal to O(n).
• The Insertion, addition and removal operations of an element are faster in a LinkedList compared to an ArrayList, because
  there is no need of resizing an array or updating the index when an element is added in some arbitrary position inside the
  collection.
• A LinkedList consumes more memory than an ArrayList, because every node in a LinkedList stores two references, one for its
  previous element and one for its next element.

Check also our article ArrayList vs. LinkedList.


4.11      What is Comparable and Comparator interface ? List their differences.

Java provides the Comparable interface, which contains only one method, called compareTo. This method compares two objects,
in order to impose an order between them. Specifically, it returns a negative integer, zero, or a positive integer to indicate that the
input object is less than, equal or greater than the existing object. Java provides the Comparator interface, which contains two
methods, called compare and equals. The first method compares its two input arguments and imposes an order between them.
It returns a negative integer, zero, or a positive integer to indicate that the first argument is less than, equal to, or greater than
the second. The second method requires an object as a parameter and aims to decide whether the input object is equal to the
comparator. The method returns true, only if the specified object is also a comparator and it imposes the same ordering as the
comparator.


4.12      What is Java Priority Queue ?

The PriorityQueue is an unbounded queue, based on a priority heap and its elements are ordered in their natural order. At the time
of its creation, we can provide a Comparator that is responsible for ordering the elements of the PriorityQueue. A PriorityQueue
doesn’t allow null values, those objects that doesn’t provide natural ordering, or those objects that don’t have any comparator
associated with them. Finally, the Java PriorityQueue is not thread-safe and it requires O(log(n)) time for its enqueing and
dequeing operations.


4.13      What do you know about the big-O notation and can you give some examples
          with respect to different data structures ?

The Big-O notation simply describes how well an algorithm scales or performs in the worst case scenario as the number of ele-
ments in a data structure increases. The Big-O notation can also be used to describe other behavior such as memory consumption.
Since the collection classes are actually data structures, we usually use the Big-O notation to chose the best implementation to
use, based on time, memory and performance. Big-O notation can give a good indication about performance for large amounts
of data.


4.14      What is the tradeoff between using an unordered array versus an ordered
          array ?

The major advantage of an ordered array is that the search times have time complexity of O(log n), compared to that of an
unordered array, which is O (n). The disadvantage of an ordered array is that the insertion operation has a time complexity of
O(n), because the elements with higher values must be moved to make room for the new element. Instead, the insertion operation
for an unordered array takes constant time of O(1).
-----------------------Page 10 End-----------------------

Java Interview Questions                                                                                                     11 / 30




4.15     What are some of the best practices relating to the Java Collection framework
         ?

• Choosing the right type of the collection to use, based on the application’s needs, is very crucial for its performance. For
  example if the size of the elements is fixed and know a priori, we shall use an Array, instead of an ArrayList.
• Some collection classes allow us to specify their initial capacity. Thus, if we have an estimation on the number of elements
  that will be stored, we can use it to avoid rehashing or resizing.
• Always use Generics for type-safety, readability, and robustness. Also, by using Generics you avoid the ClassCastException
  during runtime.
• Use immutable classes provided by the Java Development Kit (JDK) as a key in a Map, in order to avoid the implementation
  of the hashCode and equals methods for our custom class.
• Program in terms of interface not implementation.

• Return zero-length collections or arrays as opposed to returning a null in case the underlying collection is actually empty.


4.16     What’s the difference between Enumeration and Iterator interfaces ?

Enumeration is twice as fast as compared to an Iterator and uses very less memory. However, the Iterator is much safer compared
to Enumeration, because other threads are not able to modify the collection object that is currently traversed by the iterator. Also,
Iteratorsallow the caller to remove elements from the underlying collection, something which is not possible with Enumerations.


4.17     What is the difference between HashSet and TreeSet ?

The HashSet is Implemented using a hash table and thus, its elements are not ordered. The add, remove, and contains methods of
a HashSet have constant time complexity O(1). On the other hand, a TreeSet is implemented using a tree structure. The elements
in a TreeSet are sorted, and thus, the add, remove, and contains methods have time complexity of O(logn).
-----------------------Page 11 End-----------------------

Java Interview Questions                                                                                                    12 / 30




Chapter 5


Garbage Collectors


5.1     What is the purpose of garbage collection in Java, and when is it used ?

The purpose of garbage collection is to identify and discard those objects that are no longer needed by the application, in order
for the resources to be reclaimed and reused.


5.2     What does System.gc() and Runtime.gc() methods do ?

These methods can be used as a hint to the JVM, in order to start a garbage collection. However, this it is up to the Java Virtual
Machine (JVM) to start the garbage collection immediately or later in time.


5.3     When is the finalize() called ? What is the purpose of finalization ?

The finalize method is called by the garbage collector, just before releasing the object’s memory. It is normally advised to release
resources held by the object inside the finalize method.


5.4     If an object reference is set to null, will the Garbage Collector immediately free
        the memory held by that object ?

No, the object will be available for garbage collection in the next cycle of the garbage collector.


5.5     What is structure of Java Heap ? What is Perm Gen space in Heap ?

The JVM has a heap that is the runtime data area from which memory for all class instances and arrays is allocated. It is created
at the JVM start-up. Heap memory for objects is reclaimed by an automatic memory management system which is known as a
garbage collector. Heap memory consists of live and dead objects. Live objects are accessible by the application and will not
be a subject of garbage collection. Dead objects are those which will never be accessible by the application, but have not been
collected by the garbage collector yet. Such objects occupy the heap memory space until they are eventually collected by the
garbage collector.
-----------------------Page 12 End-----------------------

Java Interview Questions                                                                                                     13 / 30




5.6     What is the difference between Serial and Throughput Garbage collector ?

The throughput garbage collector uses a parallel version of the young generation collector and is meant to be used with applica-
tions that have medium to large data sets. On the other hand, the serial collector is usually adequate for most small applications
(those requiring heaps of up to approximately 100MB on modern processors).


5.7     When does an Object becomes eligible for Garbage collection in Java ?

A Java object is subject to garbage collection when it becomes unreachable to the program in which it is currently used.


5.8     Does Garbage collection occur in permanent generation space in JVM ?

Garbage Collection does occur in PermGen space and if PermGen space is full or cross a threshold, it can trigger a full garbage
collection. If you look carefully at the output of the garbage collector, you will find that PermGen space is also garbage collected.
This is the reason why correct sizing of PermGen space is important to avoid frequent full garbage collections. Also check our
article Java 8: PermGen to Metaspace.
-----------------------Page 13 End-----------------------

Java Interview Questions                                                                                                    14 / 30




Chapter 6


Exception Handling


6.1    What are the two types of Exceptions in Java ? Which are the differences
       between them ?

Java has two types of exceptions: checked exceptions and unchecked exceptions. Unchecked exceptions do not need to be
declared in a method or a constructor’s throws clause, if they can be thrown by the execution of the method or the constructor,
and propagate outside the method or constructor boundary. On the other hand, checked exceptions must be declared in a method
or a constructor’s throws clause. See here for tips on Java exception handling.


6.2    What is the difference between Exception and Error in java ?

Exception and Error classes are both subclasses of the Throwable class. The Exception class is used for exceptional conditions
that a user’s program should catch. The Error class defines exceptions that are not excepted to be caught by the user program.


6.3    What is the difference between throw and throws ?

The throw keyword is used to explicitly raise a exception within the program. On the contrary, the throws clause is used to
indicate those exceptions that are not handled by a method. Each method must explicitly specify which exceptions does not
handle, so the callers of that method can guard against possible exceptions. Finally, multiple exceptions are separated by a
comma.


6.4    What is the importance of finally block in exception handling ?

A finally block will always be executed, whether or not an exception is actually thrown. Even in the case where the catch
statement is missing and an exception is thrown, the finally block will still be executed. Last thing to mention is that the finally
block is used to release resources like I/O buffers, database connections, etc.


6.5    What will happen to the Exception object after exception handling ?

The Exception object will be garbage collected in the next garbage collection.
-----------------------Page 14 End-----------------------

Java Interview Questions                                                                                                  15 / 30




6.6    How does finally block differ from finalize() method ?

A finally block will be executed whether or not an exception is thrown and is used to release those resources held by the
application. Finalize is a protected method of the Object class, which is called by the Java Virtual Machine (JVM) just before an
object is garbage collected.
-----------------------Page 15 End-----------------------

Java Interview Questions                                                                                                            16 / 30




Chapter 7

Java Applets


7.1     What is an Applet ?

A java applet is program that can be included in a HTML page and be executed in a java enabled client browser. Applets are used
for creating dynamic and interactive web applications.


7.2     Explain the life cycle of an Applet.

An applet may undergo the following states:

• Init: An applet is initialized each time is loaded.
• Start: Begin the execution of an applet.
• Stop: Stop the execution of an applet.
• Destroy: Perform a final cleanup, before unloading the applet.


7.3     What happens when an applet is loaded ?

First of all, an instance of the applet’s controlling class is created. Then, the applet initializes itself and finally, it starts running.


7.4     What is the difference between an Applet and a Java Application ?

Applets are executed within a java enabled browser, but a Java application is a standalone Java program that can be executed
outside of a browser. However, they both require the existence of a Java Virtual Machine (JVM). Furthermore, a Java application
requires a main method with a specific signature, in order to start its execution. Java applets don’t need such a method to start
their execution. Finally, Java applets typically use a restrictive security policy, while Java applications usually use more relaxed
security policies.


7.5     What are the restrictions imposed on Java applets ?

Mostly due to security reasons, the following restrictions are imposed on Java applets:

• An applet cannot load libraries or define native methods.
-----------------------Page 16 End-----------------------

Java Interview Questions                                                                                                      17 / 30



• An applet cannot ordinarily read or write files on the execution host.
• An applet cannot read certain system properties.
• An applet cannot make network connections except to the host that it came from.

• An applet cannot start any program on the host that’s executing it.


7.6     What are untrusted applets ?

Untrusted applets are those Java applets that cannot access or execute local system files. By default, all downloaded applets are
considered as untrusted.


7.7     What is the difference between applets loaded over the internet and applets
        loaded via the file system ?

Regarding the case where an applet is loaded over the internet, the applet is loaded by the applet classloader and is subject to the
restrictions enforced by the applet security manager. Regarding the case where an applet is loaded from the client’s local disk,
the applet is loaded by the file system loader. Applets loaded via the file system are allowed to read files, write files and to load
libraries on the client. Also, applets loaded via the file system are allowed to execute processes and finally, applets loaded via the
file system are not passed through the byte code verifier.


7.8     What is the applet class loader, and what does it provide ?

When an applet is loaded over the internet, the applet is loaded by the applet classloader. The class loader enforces the Java name
space hierarchy. Also, the class loader guarantees that a unique namespace exists for classes that come from the local file system,
and that a unique namespace exists for each network source. When a browser loads an applet over the net, that applet’s classes
are placed in a private namespace associated with the applet’s origin. Then, those classes loaded by the class loader are passed
through the verifier.The verifier checks that the class file conforms to the Java language specification . Among other things, the
verifier ensures that there are no stack overflows or underflows and that the parameters to all bytecode instructions are correct.


7.9     What is the applet security manager, and what does it provide ?

The applet security manager is a mechanism to impose restrictions on Java applets. A browser may only have one security
manager. The security manager is established at startup, and it cannot thereafter be replaced, overloaded, overridden, or extended.
-----------------------Page 17 End-----------------------

Java Interview Questions                                                                                                  18 / 30




Chapter 8

Swing


8.1    What is the difference between a Choice and a List ?

A Choice is displayed in a compact form that must be pulled down, in order for a user to be able to see the list of all available
choices. Only one item may be selected from a Choice. A List may be displayed in such a way that several List items are visible.
A List supports the selection of one or more List items.


8.2    What is a layout manager ?

A layout manager is the used to organize the components in a container.


8.3    What is the difference between a Scrollbar and a JScrollPane ?

A Scrollbar is a Component, but not a Container. A ScrollPane is a Container. A ScrollPane handles its own events and performs
its own scrolling.


8.4    Which Swing methods are thread-safe ?

There are only three thread-safe methods: repaint, revalidate, and invalidate.


8.5    Name three Component subclasses that support painting.

The Canvas, Frame, Panel, and Applet classes support painting.


8.6    What is clipping ?

Clipping is defined as the process of confining paint operations to a limited area or shape.


8.7    What is the difference between a MenuItem and a CheckboxMenuItem ?

The CheckboxMenuItem class extends the MenuItem class and supports a menu item that may be either checked or unchecked.
-----------------------Page 18 End-----------------------

Java Interview Questions                                                                                                19 / 30




8.8    How are the elements of a BorderLayout organized ?

The elements of a BorderLayout are organized at the borders (North, South, East, and West) and the center of a container.


8.9    How are the elements of a GridBagLayout organized ?

The elements of a GridBagLayout are organized according to a grid. The elements are of different sizes and may occupy more
than one row or column of the grid. Thus, the rows and columns may have different sizes.


8.10     What is the difference between a Window and a Frame ?

The Frame class extends the Window class and defines a main application window that can have a menu bar.


8.11     What is the relationship between clipping and repainting ?

When a window is repainted by the AWT painting thread, it sets the clipping regions to the area of the window that requires
repainting.


8.12     What is the relationship between an event-listener interface and an event-
         adapter class ?

An event-listener interface defines the methods that must be implemented by an event handler for a particular event. An event
adapter provides a default implementation of an event-listener interface.


8.13     How can a GUI component handle its own events ?

A GUI component can handle its own events, by implementing the corresponding event-listener interface and adding itself as its
own event listener.


8.14     What advantage do Java’s layout managers provide over traditional window-
         ing systems ?

Java uses layout managers to lay out components in a consistent manner, across all windowing platforms. Since layout man-
agers aren’t tied to absolute sizing and positioning, they are able to accomodate platform-specific differences among windowing
systems.


8.15     What is the design pattern that Java uses for all Swing components ?

The design pattern used by Java for all Swing components is the Model View Controller (MVC) pattern.
-----------------------Page 19 End-----------------------

Java Interview Questions                                                                                               20 / 30




Chapter 9


JDBC


9.1    What is JDBC ?

JDBC is an abstraction layer that allows users to choose between databases. JDBC enables developers to write database applica-
tions in Java, without having to concern themselves with the underlying details of a particular database.


9.2    Explain the role of Driver in JDBC.

The JDBC Driver provides vendor-specific implementations of the abstract classes provided by the JDBC API. Each driver
must provide implementations for the following classes of the java.sql package:Connection, Statement, PreparedStatement,
CallableStatement, ResultSet and Driver.


9.3    What is the purpose Class.forName method ?

This method is used to method is used to load the driver that will establish a connection to the database.


9.4    What is the advantage of PreparedStatement over Statement ?

PreparedStatements are precompiled and thus, their performance is much better. Also, PreparedStatement objects can be reused
with different input values to their queries.


9.5    What is the use of CallableStatement ? Name the method, which is used to
       prepare a CallableStatement.

A CallableStatement is used to execute stored procedures. Stored procedures are stored and offered by a database. Stored
procedures may take input values from the user and may return a result. The usage of stored procedures is highly encouraged,
because it offers security and modularity.The method that prepares a CallableStatement is the following: CallableStament.
prepareCall();
-----------------------Page 20 End-----------------------

Java Interview Questions                                                                                                    21 / 30




9.6    What does Connection pooling mean ?

The interaction with a database can be costly, regarding the opening and closing of database connections. Especially, when the
number of database clients increases, this cost is very high and a large number of resources is consumed.A pool of database
connections is obtained at start up by the application server and is maintained in a pool. A request for a connection is served by a
connection residing in the pool. In the end of the connection, the request is returned to the pool and can be used to satisfy future
requests.
-----------------------Page 21 End-----------------------

Java Interview Questions                                                                                                   22 / 30




Chapter 10


Remote Method Invocation (RMI)


10.1     What is RMI ?

The Java Remote Method Invocation (Java RMI) is a Java API that performs the object-oriented equivalent of remote procedure
calls (RPC), with support for direct transfer of serialized Java classes and distributed garbage collection. Remote Method Invoca-
tion (RMI) can also be seen as the process of activating a method on a remotely running object. RMI offers location transparency
because a user feels that a method is executed on a locally running object. Check some RMI Tips here.


10.2     What is the basic principle of RMI architecture ?

The RMI architecture is based on a very important principle which states that the definition of the behavior and the implemen-
tation of that behavior, are separate concepts. RMI allows the code that defines the behavior and the code that implements the
behavior to remain separate and to run on separate JVMs.


10.3     What are the layers of RMI Architecture ?

The RMI architecture consists of the following layers:

• Stub and Skeleton layer: This layer lies just beneath the view of the developer. This layer is responsible for intercepting
  method calls made by the client to the interface and redirect these calls to a remote RMI Service.

• Remote Reference Layer: The second layer of the RMI architecture deals with the interpretation of references made from
  the client to the server’s remote objects. This layer interprets and manages references made from clients to the remote service
  objects. The connection is a one-to-one (unicast) link.
• Transport layer: This layer is responsible for connecting the two JVM participating in the service. This layer is based on
  TCP/IP connections between machines in a network. It provides basic connectivity, as well as some firewall penetration
  strategies.


10.4     What is the role of Remote Interface in RMI ?

The Remote interface serves to identify interfaces whose methods may be invoked from a non-local virtual machine. Any object
that is a remote object must directly or indirectly implement this interface. A class that implements a remote interface should
declare the remote interfaces being implemented, define the constructor for each remote object and provide an implementation
for each remote method in all remote interfaces.
-----------------------Page 22 End-----------------------

Java Interview Questions                                                                                                    23 / 30




10.5      What is the role of the java.rmi.Naming Class ?

The java.rmi.Naming class provides methods for storing and obtaining references to remote objects in the remote object registry.
Each method of the Naming class takes as one of its arguments a name that is a String in URL format.


10.6      What is meant by binding in RMI ?

Binding is the process of associating or registering a name for a remote object, which can be used at a later time, in order to look
up that remote object. A remote object can be associated with a name using the bind or rebind methods of the Naming class.


10.7      What is the difference between using bind() and rebind() methods of Naming
          Class ?

The bind method bind is responsible for binding the specified name to a remote object, while the rebind method is responsible
for rebinding the specified name to a new remote object. In case a binding exists for that name, the binding is replaced.


10.8      What are the steps involved to make work a RMI program ?

The following steps must be involved in order for a RMI program to work properly:

• Compilation of all source files.
• Generatation of the stubs using rmic.
• Start the rmiregistry.
• Start the RMIServer.
• Run the client program.


10.9      What is the role of stub in RMI ?

A stub for a remote object acts as a client’s local representative or proxy for the remote object. The caller invokes a method on
the local stub, which is responsible for executing the method on the remote object. When a stub’s method is invoked, it undergoes
the following steps:

• It initiates a connection to the remote JVM containing the remote object.
• It marshals the parameters to the remote JVM.
• It waits for the result of the method invocation and execution.
• It unmarshals the return value or an exception if the method has not been successfully executed.
• It returns the value to the caller.


10.10       What is DGC ? And how does it work ?

DGC stands for Distributed Garbage Collection. Remote Method Invocation (RMI) uses DGC for automatic garbage collection.
Since RMI involves remote object references across JVM’s, garbage collection can be quite difficult. DGC uses a reference
counting algorithm to provide automatic memory management for remote objects.
-----------------------Page 23 End-----------------------

Java Interview Questions                                                                                                      24 / 30




10.11      What is the purpose of using RMISecurityManager in RMI ?

RMISecurityManager provides a security manager that can be used by RMI applications, which use downloaded code. The class
loader of RMI will not download any classes from remote locations, if the security manager has not been set.


10.12      Explain Marshalling and demarshalling.

When an application wants to pass its memory objects across a network to another host or persist it to storage, the in-memory
representation must be converted to a suitable format. This process is called marshalling and the revert operation is called
demarshalling.


10.13      Explain Serialization and Deserialization.

Java provides a mechanism, called object serialization where an object can be represented as a sequence of bytes and includes
the object’s data, as well as information about the object’s type, and the types of data stored in the object. Thus, serialization can
be seen as a way of flattening objects, in order to be stored on disk, and later, read back and reconstituted. Deserialisation is the
reverse process of converting an object from its flattened state to a live object.
-----------------------Page 24 End-----------------------

Java Interview Questions                                                                                                   25 / 30




Chapter 11


Servlets


11.1     What is a Servlet ?

The servlet is a Java programming language class used to process client requests and generate dynamic web content. Servlets are
mostly used to process or store data submitted by an HTML form, provide dynamic content and manage state information that
does not exist in the stateless HTTP protocol.


11.2     Explain the architechure of a Servlet.

The core abstraction that must be implemented by all servlets is the javax.servlet.Servlet interface. Each servlet must implement
it either directly or indirectly, either by extending javax.servlet.GenericServlet or javax.servlet.http.HTTPServlet. Finally, each
servlet is able to serve multiple requests in parallel using multithreading.


11.3     What is the difference between an Applet and a Servlet ?

An Applet is a client side java program that runs within a Web browser on the client machine. On the other hand, a servlet is a
server side component that runs on the web server.An applet can use the user interface classes, while a servlet does not have a
user interface. Instead, a servlet waits for client’s HTTP requests and generates a response in every request.


11.4     What is the difference between GenericServlet and HttpServlet ?

GenericServlet is a generalized and protocol-independent servlet that implements the Servlet and ServletConfig interfaces. Those
servlets extending the GenericServlet class shall override the service method. Finally, in order to develop an HTTP servlet for
use on the Web that serves requests using the HTTP protocol, your servlet must extend the HttpServlet instead. Check Servlet
examples here.


11.5     Explain the life cycle of a Servlet.

On every client’s request, the Servlet Engine loads the servlets and invokes its init methods, in order for the servlet to be
initialized. Then, the Servlet object handles all subsequent requests coming from that client, by invoking the service method for
each request separately. Finally, the servlet is removed by calling the server’s destroy method.
-----------------------Page 25 End-----------------------

Java Interview Questions                                                                                                     26 / 30




11.6     What is the difference between doGet() and doPost() ?

doGET: The GET method appends the name-value pairs on the request’s URL. Thus, there is a limit on the number of characters
and subsequently on the number of values that can be used in a client’s request. Furthermore, the values of the request are made
visible and thus, sensitive information must not be passed in that way.
doPOST: The POST method overcomes the limit imposed by the GET request, by sending the values of the request inside its
body. Also, there is no limitations on the number of values to be sent across. Finally, the sensitive information passed through a
POST request is not visible to an external client.


11.7     What is meant by a Web Application ?

A Web application is a dynamic extension of a Web or application server. There are two types of web applications: presentation-
oriented and service-oriented. A presentation-oriented Web application generates interactive web pages, which contain various
types of markup language and dynamic content in response to requests. On the other hand, a service-oriented web application
implements the endpoint of a web service. In general, a Web application can be seen as a collection of servlets installed under a
specific subset of the server’s URL namespace.


11.8     What is a Server Side Include (SSI) ?

Server Side Includes (SSI) is a simple interpreted server-side scripting language, used almost exclusively for the Web, and is
embedded with a servlet tag. The most frequent use of SSI is to include the contents of one or more files into a Web page on a
Web server. When a Web page is accessed by a browser, the Web server replaces the servlet tag in that Web page with the hyper
text generated by the corresponding servlet.


11.9     What is Servlet Chaining ?

Servlet Chaining is the method where the output of one servlet is sent to a second servlet. The output of the second servlet can
be sent to a third servlet, and so on. The last servlet in the chain is responsible for sending the response to the client.


11.10      How do you find out what client machine is making a request to your servlet
           ?

The ServletRequest class has functions for finding out the IP address or host name of the client machine. getRemoteAddr() gets
the IP address of the client machine and getRemoteHost() gets the host name of the client machine. See example here.


11.11      What is the structure of the HTTP response ?

The HTTP response consists of three parts:

• Status Code: describes the status of the response. It can be used to check if the request has been successfully completed. In
  case the request failed, the status code can be used to find out the reason behind the failure. If your servlet does not return a
  status code, the success status code, HttpServletResponse.SC_OK, is returned by default.
• HTTP Headers: they contain more information about the response. For example, the headers may specify the date/time after
  which the response is considered stale, or the form of encoding used to safely transfer the entity to the user. See how to retrieve
  headers in Servlet here.
• Body: it contains the content of the response. The body may contain HTML code, an image, etc. The body consists of the data
  bytes transmitted in an HTTP transaction message immediately following the headers.
-----------------------Page 26 End-----------------------

Java Interview Questions                                                                                                      27 / 30




11.12      What is a cookie ? What is the difference between session and cookie ?

A cookie is a bit of information that the Web server sends to the browser. The browser stores the cookies for each Web server
in a local file. In a future request, the browser, along with the request, sends all stored cookies for that specific Web server.The
differences between session and a cookie are the following:

• The session should work, regardless of the settings on the client browser. The client may have chosen to disable cookies.
  However, the sessions still work, as the client has no ability to disable them in the server side.
• The session and cookies also differ in the amount of information the can store. The HTTP session is capable of storing any
  Java object, while a cookie can only store String objects.


11.13      Which protocol will be used by browser and servlet to communicate ?

The browser communicates with a servlet by using the HTTP protocol.


11.14      What is HTTP Tunneling ?

HTTP Tunneling is a technique by which, communications performed using various network protocols are encapsulated using
the HTTP or HTTPS protocols. The HTTP protocol therefore acts as a wrapper for a channel that the network protocol being
tunneled uses to communicate. The masking of other protocol requests as HTTP requests is HTTP Tunneling.


11.15      What’s the difference between sendRedirect and forward methods ?

The sendRedirect method creates a new request, while the forward method just forwards a request to a new target. The previous
request scope objects are not available after a redirect, because it results in a new request. On the other hand, the previous request
scope objects are available after forwarding. FInally, in general, the sendRedirect method is considered to be slower compare to
the forward method.


11.16      What is URL Encoding and URL Decoding ?

The URL encoding procedure is responsible for replacing all the spaces and every other extra special character of a URL, into
their corresponding Hex representation. In correspondence, URL decoding is the exact opposite procedure.
-----------------------Page 27 End-----------------------

Java Interview Questions                                                                                                      28 / 30




Chapter 12


JSP


12.1     What is a JSP Page ?

A Java Server Page (JSP) is a text document that contains two types of text: static data and JSP elements. Static data can be
expressed in any text-based format, such as HTML or XML. JSP is a technology that mixes static content with dynamically-
generated content. See JSP example here.


12.2     How are the JSP requests handled ?

On the arrival of a JSP request, the browser first requests a page with a .jsp extension. Then, the Web server reads the request and
using the JSP compiler, the Web server converts the JSP page into a servlet class. Notice that the JSP file is compiled only on
the first request of the page, or if the JSP file has changed.The generated servlet class is invoked, in order for the handle the browser’s
request. Once the execution of the request is over, the servlet sends a response back to the client. See how to get Request
parameters in a JSP.


12.3     What are the advantages of JSP ?

The advantages of using the JSP technology are shown below:

• JSP pages are dynamically compiled into servlets and thus, the developers can easily make updates to presentation code.

• JSP pages can be pre-compiled.
• JSP pages can be easily combined to static templates, including HTML or XML fragments, with code that generates dynamic
  content.
• Developers can offer customized JSP tag libraries that page authors access using an XML-like syntax.

• Developers can make logic changes at the component level, without editing the individual pages that use the application’s logic.


12.4     What are Directives ? What are the different types of Directives available in
         JSP ?

Directives are instructions that are processed by the JSP engine, when the page is compiled to a servlet. Directives are used to
set page-level instructions, insert data from external files, and specify custom tag libraries. Directives are defined between < %@
and % >. The different types of directives are shown below:
-----------------------Page 28 End-----------------------

Java Interview Questions                                                                                                   29 / 30



• Include directive: it is used to include a file and merges the content of the file with the current page.
• Page directive: it is used to define specific attributes in the JSP page, like error page and buffer.
• Taglib: it is used to declare a custom tag library which is used in the page.


12.5     What are JSP actions ?

JSP actions use constructs in XML syntax to control the behavior of the servlet engine. JSP actions are executed when a JSP
page is requested. They can be dynamically inserted into a file, re-use JavaBeans components, forward the user to another page,
or generate HTML for the Java plugin.Some of the available actions are listed below:

• jsp:include - includes a file, when the JSP page is requested.
• jsp:useBean - finds or instantiates a JavaBean.
• jsp:setProperty - sets the property of a JavaBean.
• jsp:getProperty - gets the property of a JavaBean.
• jsp:forward - forwards the requester to a new page.
• jsp:plugin - generates browser-specific code.


12.6     What are Scriptlets ?

In Java Server Pages (JSP) technology, a scriptlet is a piece of Java-code embedded in a JSP page. The scriptlet is everything
inside the tags. Between these tags, a user can add any valid scriplet.


12.7     What are Decalarations ?

Declarations are similar to variable declarations in Java. Declarations are used to declare variables for subsequent use in expres-
sions or scriptlets. To add a declaration, you must use the sequences to enclose your declarations.


12.8     What are Expressions ?

A JSP expression is used to insert the value of a scripting language expression, converted into a string, into the data stream
returned to the client, by the web server. Expressions are defined between <% =and %> tags.


12.9     What is meant by implicit objects and what are they ?

JSP implicit objects are those Java objects that the JSP Container makes available to developers in each page. A developer can
call them directly, without being explicitly declared. JSP Implicit Objects are also called pre-defined variables.The following
objects are considered implicit in a JSP page:

• application
• page
• request
• response
-----------------------Page 29 End-----------------------

Java Interview Questions   30 / 30



• session
• exception
• out

• config
• pageContext
-----------------------Page 30 End-----------------------

## Spring Boot Annotations cheat sheet.txt

-----------------------Page 1 End-----------------------

## Java Interview Questions Guru99.txt

(This file was empty)

## Practical List of Java.txt

Practical No. 1
Aim: Write a program to check whether a number is even or odd.
Program:
class evenodd
{
public static void main (String args[])
{
int n=10;
if (n%2==0)
{
System.out.println("even");
}
else
{
System.out.println("odd");
}
}
}
Output:
Practical No. 2
Aim: Write a program to find the factorial of a given number.
Program:
class fact
{
public static void main(String args[])
{
int n=5, f=1, i;
for(i=1;i<=n;i++)
{
f=f*i;
}
System.out.println("Factorial of " +n+ " is " +f);
}
}
Output:
Practical No. 3
Aim: Write a program to find the sum of n different numbers.
Program:
class sumofn
{
public static void main(String args[])
{
int n=10, i, sum=0;
for(i=1;i<=n;i++)
{
sum=sum+i;
}
System.out.println("Sum of " +n+ " numbers is " +sum);
}
}
Output:
Practical No. 4
Aim: Write a program to find the sum and average of n different numbers.
Program:
class avg
{
public static void main(String args[])
{
int n=10, i, sum=0, avg;
for(i=1;i<=n;i++)
{
sum=sum+i;
}
avg=sum/n;
System.out.println("Sum of " +n+ " numbers is " +sum);
System.out.println("Average of " +n+ " numbers is " +avg);
}
}
Output:
Practical No. 5
Aim: Write a program to find the greatest of three different numbers.
Program:
class greatest
{
public static void main(String args[])
{
int a=10, b=20, c=30;
if(a>b && a>c)
{
System.out.println(a+ "is greatest");
}
else if(b>a && b>c)
{
System.out.println(b+ "is greatest");
}
else
{
System.out.println(c+ "is greatest");
}
}
}
Output:
Practical No. 6
Aim: Write a program to find the roots of a quadratic equation.
Program:
import java.util.Scanner;
public class QuadraticEquation
{
public static void main(String[] Strings)
{
Scanner input = new Scanner(System.in);
System.out.print("Enter the value of a: ");
double a = input.nextDouble();
System.out.print("Enter the value of b: ");
double b = input.nextDouble();
System.out.print("Enter the value of c: ");
double c = input.nextDouble();
double d= b * b - 4.0 * a * c;
if (d> 0.0)
{
double r1 = (-b + Math.pow(d, 0.5)) / (2.0 * a);
double r2 = (-b - Math.pow(d, 0.5)) / (2.0 * a);
System.out.println("The roots are " + r1 + " and " + r2);
}
else if (d == 0.0)
{
double r1 = -b / (2.0 * a);
System.out.println("The root is " + r1);
}
else
{
System.out.println("Roots are not real.");
}
}
}
Output:
Practical No. 7
Aim: Write a program to find the grade of a student.
Program:
import java.util.Scanner;
class Grade
{
public static void main(String args[])
{
int marks;
Scanner in = new Scanner(System.in);
System.out.println("Enter the marks");
marks = in.nextInt();
if(marks>85)
{
System.out.println("Grade A");
}
else if(marks>70 && marks<=85)
{
System.out.println("Grade B");
}
else if(marks>50 && marks<=70)
{
System.out.println("Grade C");
}
else
{
System.out.println("Grade D");
}
}
}
Output:
Practical No. 8
Aim: Write a program to print the Fibonacci series.
Program:
class fibo
{
public static void main(String args[])
{
int n1=0, n2=1, n3, i, n=10;
System.out.println("Fibonacci series is");
System.out.println(n1);
System.out.println(n2);
for(i=2;i<n;i++)
{
n3=n1+n2;
System.out.println(n3);
n1=n2;
n2=n3;
}
}
}
Output:
Practical No. 9
Aim: Write a program to check whether a number is prime or not.
Program:
class prime
{
public static void main(String args[])
{
int n=11, i, flag=0;
for(i=2;i<n;i++)
{
if(n%i==0)
{
flag=1;
break;
}
}
if(flag==0)
{
System.out.println("Prime");
}
else
{
System.out.println("Not Prime");
}
}
}
Output:
Practical No. 10
Aim: Write a program to check whether a number is Armstrong or not.
Program:
class armstrong
{
public static void main(String args[])
{
int n=153, r, sum=0, temp;
temp=n;
while(n>0)
{
r=n%10;
sum=sum+r*r*r;
n=n/10;
}
if(sum==temp)
{
System.out.println("Armstrong number");
}
else
{
System.out.println("Not Armstrong");
}
}
}
Output:
Practical No. 11
Aim: Write a program to check whether a number is palindrome or not.
Program:
class palindrome
{
public static void main(String args[])
{
int n=121, r, sum=0, temp;
temp=n;
while(n>0)
{
r=n%10;
sum=sum*10+r;
n=n/10;
}
if(sum==temp)
{
System.out.println("Palindrome");
}
else
{
System.out.println("Not Palindrome");
}
}
}
Output:
Practical No. 12
Aim: Write a program to print the table of a given number.
Program:
class table
{
public static void main(String args[])
{
int n=5, i;
for(i=1;i<=10;i++)
{
System.out.println(n+ " * " +i+ " = " +n*i);
}
}
}
Output:
Practical No. 13
Aim: Write a program to demonstrate the use of break and continue statements.
Program:
class breakcontinue
{
public static void main(String args[])
{
int i;
for(i=1;i<=10;i++)
{
if(i==5)
{
break;
}
System.out.println(i);
}
for(i=1;i<=10;i++)
{
if(i==5)
{
continue;
}
System.out.println(i);
}
}
}
Output:
Practical No. 14
Aim: Write a program to demonstrate the use of this keyword.
Program:
class student
{
int rollno;
String name;
student(int rollno, String name)
{
this.rollno=rollno;
this.name=name;
}
void display()
{
System.out.println(rollno+ " " +name);
}
}
class test
{
public static void main(String args[])
{
student s1=new student(1, "abc");
student s2=new student(2, "xyz");
s1.display();
s2.display();
}
}
Output:
Practical No. 15
Aim: Write a program to demonstrate the use of static keyword.
Program:
class student
{
int rollno;
String name;
static String college="ITS";
student(int rollno, String name)
{
this.rollno=rollno;
this.name=name;
}
void display()
{
System.out.println(rollno+ " " +name+ " " +college);
}
}
class test
{
public static void main(String args[])
{
student s1=new student(1, "abc");
student s2=new student(2, "xyz");
s1.display();
s2.display();
}
}
Output:
Practical No. 16
Aim: Write a program to demonstrate the use of super keyword.
Program:
class animal
{
String color="white";
}
class dog extends animal
{
String color="black";
void printcolor()
{
System.out.println(color);
System.out.println(super.color);
}
}
class test
{
public static void main(String args[])
{
dog d=new dog();
d.printcolor();
}
}
Output:
Practical No. 17
Aim: Write a program to demonstrate the use of final keyword.
Program:
class bike
{
final void run()
{
System.out.println("running");
}
}
class honda extends bike
{
void run()
{
System.out.println("running safely");
}
public static void main(String args[])
{
honda h=new honda();
h.run();
}
}
Output:
Practical No. 18
Aim: Write a program to demonstrate the use of abstract keyword.
Program:
abstract class shape
{
abstract void draw();
}
class rectangle extends shape
{
void draw()
{
System.out.println("drawing rectangle");
}
}
class circle extends shape
{
void draw()
{
System.out.println("drawing circle");
}
}
class test
{
public static void main(String args[])
{
shape s=new circle();
s.draw();
}
}
Output:
Practical No. 19
Aim: Write a program to demonstrate the use of interface.
Program:
interface drawable
{
void draw();
}
class rectangle implements drawable
{
public void draw()
{
System.out.println("drawing rectangle");
}
}
class circle implements drawable
{
public void draw()
{
System.out.println("drawing circle");
}
}
class test
{
public static void main(String args[])
{
drawable d=new circle();
d.draw();
}
}
Output:
Practical No. 20
Aim: Write a program to demonstrate the use of package.
Program:
package mypack;
public class simple
{
public static void main(String args[])
{
System.out.println("Welcome to package");
}
}
Output:
Practical No. 21
Aim: Write a program to demonstrate the use of exception handling.
Program:
class exception
{
public static void main(String args[])
{
try
{
int a=10, b=0, c;
c=a/b;
System.out.println(c);
}
catch(Exception e)
{
System.out.println(e);
}
}
}
Output:
Practical No. 22
Aim: Write a program to demonstrate the use of multithreading.
Program:
class multithread extends Thread
{
public void run()
{
System.out.println("thread is running");
}
public static void main(String args[])
{
multithread t1=new multithread();
t1.start();
}
}
Output:
Practical No. 23
Aim: Write a program to demonstrate the use of applet.
Program:
import java.applet.Applet;
import java.awt.Graphics;
public class first extends Applet
{
public void paint(Graphics g)
{
g.drawString("welcome",150,150);
}
}
Output:
Practical No. 24
Aim: Write a program to demonstrate the use of swing.
Program:
import javax.swing.*;
public class first
{
public static void main(String args[])
{
JFrame f=new JFrame();
JButton b=new JButton("click");
b.setBounds(130,100,100, 40);
f.add(b);
f.setSize(400,500);
f.setLayout(null);
f.setVisible(true);
}
}
Output:
Practical No. 25
Aim: Write a program to demonstrate the use of JDBC.
Program:
import java.sql.*;
class MysqlCon
{
public static void main(String args[])
{
try
{
Class.forName("com.mysql.jdbc.Driver");
Connection con=DriverManager.getConnection("jdbc:mysql://localhost:3306/sonoo","root","root");
Statement stmt=con.createStatement();
ResultSet rs=stmt.executeQuery("select * from emp");
while(rs.next())
System.out.println(rs.getInt(1)+" "+rs.getString(2)+" "+rs.getString(3));
con.close();
}
catch(Exception e)
{
System.out.println(e);
}
}
}
Output:
Practical No. 26
Aim: Write a program to demonstrate the use of AWT.
Program:
import java.awt.*;
class first extends Frame
{
first()
{
Button b=new Button("click me");
b.setBounds(30,100,80,30);
add(b);
setSize(300,300);
setLayout(null);
setVisible(true);
}
public static void main(String args[])
{
first f=new first();
}
}
Output:
Practical No. 27
Aim: Write a program to demonstrate the use of collections.
Program:
import java.util.*;
class test
{
public static void main(String args[])
{
ArrayList<String> list=new ArrayList<String>();
list.add("Ravi");
list.add("Vijay");
list.add("Ravi");
list.add("Ajay");
Iterator itr=list.iterator();
while(itr.hasNext())
{
System.out.println(itr.next());
}
}
}
Output:
Practical No. 28
Aim: Write a program to demonstrate the use of method overriding.
Program:
class vehicle
{
void run()
{
System.out.println("Vehicle is running");
}
}
class bike extends vehicle
{
void run()
{
System.out.println("Bike is running safely");
}
public static void main(String args[])
{
bike obj = new bike();
obj.run();
}
}
Output:
Practical No. 29
Aim: Write a program to demonstrate the use of method overloading.
Program:
class adder
{
static int add(int a,int b)
{
return a+b;
}
static int add(int a,int b,int c)
{
return a+b+c;
}
}
class test
{
public static void main(String[] args)
{
System.out.println(adder.add(11,11));
System.out.println(adder.add(11,11,11));
}
}
Output:
Practical No. 30
Aim: Write a program to demonstrate the use of constructor.
Program:
class student
{
int id;
String name;
student(int i,String n)
{
id=i;
name=n;
}
void display()
{
System.out.println(id+" "+name);
}
public static void main(String args[])
{
student s1=new student(111,"Karan");
student s2=new student(222,"Aryan");
s1.display();
s2.display();
}
}
Output:

## Java Interview Questions and Answers.txt

-----------------------Page 1 End-----------------------

Java Interview Questions                              i




                           Java Interview Questions
-----------------------Page 2 End-----------------------

Java Interview Questions                                                                                                             ii




Contents


1   Object Oriented Programming (OOP)                                                                                                1
    1.1   Encapsulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    1
    1.2   Polymorphism . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     1
    1.3   Inheritance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    1
    1.4   Abstraction . . . . . . . . . . . . . . . . . . . . . .. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    2
    1.5   Differences between Abstraction and Encapsulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .        2

2   General Questions about Java                                                                                                     3
    2.1   What is JVM ? Why is Java called the Platform Independent Programming Language? . . . . . . . . . . . . . .                3
    2.2   What is the Difference between JDK and JRE ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .         3
    2.3   What does the “static” keyword mean ? Can you override private or static method in Java ? . . . . . . . . . . . .          3
    2.4   Can you access non static variable in static context ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     3
    2.5   What are the Data Types supported by Java ? What is Autoboxing and Unboxing ? . . . . . . . . . . . . . . . .              4
    2.6   What is Function Overriding and Overloading in Java ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .        4
    2.7   What is a Constructor, Constructor Overloading in Java and Copy-Constructor . . . . . . . . . . . . . . . . . . .          4
    2.8   Does Java support multiple inheritance ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     4
    2.9   What is the difference between an Interface and an Abstract class ? . . . . . . . . . . . . . . . . . . . . . . . . .      4
    2.10 What are pass by reference and pass by value ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .        5

3   Java Threads                                                                                                                     6
    3.1   What is the difference between processes and threads ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       6
    3.2   Explain different ways of creating a thread. Which one would you prefer and why ? . . . . . . . . . . . . . . . .          6
    3.3   Explain the available thread states in a high-level. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   6
    3.4   What is the difference between a synchronized method and a synchronized block ? . . . . . . . . . . . . . . . .            7
    3.5   How does thread synchronization occurs inside a monitor ? What levels of synchronization can you apply ? . . .             7
    3.6   What’s a deadlock ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    7
    3.7   How do you ensure that N threads can access N resources without deadlock ? . . . . . . . . . . . . . . . . . . .           7
-----------------------Page 3 End-----------------------

Java Interview Questions                                                                                                              iii



4   Java Collections                                                                                                                   8
    4.1   What are the basic interfaces of Java Collections Framework ? . . . . . . . . . . . . . . . . . . . . . . . . . . .         8
    4.2   Why Collection doesn’t extend Cloneable and Serializable interfaces ? . . . . . . . . . . . . . . . . . . . . . . .         8
    4.3   What is an Iterator ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   8
    4.4   What differences exist between Iterator and ListIterator ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      8
    4.5   What is difference between fail-fast and fail-safe ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     9
    4.6   How HashMap works in Java ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .         9
    4.7   What is the importance of hashCode() and equals() methods ? . . . . . . . . . . . . . . . . . . . . . . . . . . .           9
    4.8   What differences exist between HashMap and Hashtable ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . .             9
    4.9   What is difference between Array and ArrayList ? When will you use Array over ArrayList ? . . . . . . . . . . .             9
    4.10 What is difference between ArrayList and LinkedList ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
    4.11 What is Comparable and Comparator interface ? List their differences. . . . . . . . . . . . . . . . . . . . . . . . 10
    4.12 What is Java Priority Queue ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
    4.13 What do you know about the big-O notation and can you give some examples with respect to different data
         structures ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
    4.14 What is the tradeoff between using an unordered array versus an ordered array ? . . . . . . . . . . . . . . . . . . 10
    4.15 What are some of the best practices relating to the Java Collection framework ? . . . . . . . . . . . . . . . . . . 11
    4.16 What’s the difference between Enumeration and Iterator interfaces ? . . . . . . . . . . . . . . . . . . . . . . . . 11
    4.17 What is the difference between HashSet and TreeSet ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11

5   Garbage Collectors                                                                                                                12
    5.1   What is the purpose of garbage collection in Java, and when is it used ? . . . . . . . . . . . . . . . . . . . . . . 12
    5.2   What does System.gc() and Runtime.gc() methods do ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
    5.3   When is the finalize() called ? What is the purpose of finalization ? . . . . . . . . . . . . . . . . . . . . . . . . . 12
    5.4   If an object reference is set to null, will the Garbage Collector immediately free the memory held by that object ?         12
    5.5   What is structure of Java Heap ? What is Perm Gen space in Heap ? . . . . . . . . . . . . . . . . . . . . . . . . 12
    5.6   What is the difference between Serial and Throughput Garbage collector ? . . . . . . . . . . . . . . . . . . . . . 13
    5.7   When does an Object becomes eligible for Garbage collection in Java ? . . . . . . . . . . . . . . . . . . . . . . 13
    5.8   Does Garbage collection occur in permanent generation space in JVM ? . . . . . . . . . . . . . . . . . . . . . . 13

6   Exception Handling                                                                                                                14
    6.1   What are the two types of Exceptions in Java ? Which are the differences between them ? . . . . . . . . . . . . . 14
    6.2   What is the difference between Exception and Error in java ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
    6.3   What is the difference between throw and throws ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
    6.4   What is the importance of finally block in exception handling ? . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
    6.5   What will happen to the Exception object after exception handling ? . . . . . . . . . . . . . . . . . . . . . . . . 14
    6.6   How does finally block differ from finalize() method ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
-----------------------Page 4 End-----------------------

Java Interview Questions                                                                                                           iv



7   Java Applets                                                                                                                  16
    7.1   What is an Applet ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
    7.2   Explain the life cycle of an Applet. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
    7.3   What happens when an applet is loaded ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
    7.4   What is the difference between an Applet and a Java Application ? . . . . . . . . . . . . . . . . . . . . . . . . . 16
    7.5   What are the restrictions imposed on Java applets ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
    7.6   What are untrusted applets ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
    7.7   What is the difference between applets loaded over the internet and applets loaded via the file system ? . . . . . . 17
    7.8   What is the applet class loader, and what does it provide ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
    7.9   What is the applet security manager, and what does it provide ? . . . . . . . . . . . . . . . . . . . . . . . . . . . 17

8   Swing                                                                                                                         18
    8.1   What is the difference between a Choice and a List ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
    8.2   What is a layout manager ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
    8.3   What is the difference between a Scrollbar and a JScrollPane ? . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
    8.4   Which Swing methods are thread-safe ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
    8.5   Name three Component subclasses that support painting. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
    8.6   What is clipping ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
    8.7   What is the difference between a MenuItem and a CheckboxMenuItem ? . . . . . . . . . . . . . . . . . . . . . . 18
    8.8   How are the elements of a BorderLayout organized ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
    8.9   How are the elements of a GridBagLayout organized ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
    8.10 What is the difference between a Window and a Frame ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
    8.11 What is the relationship between clipping and repainting ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
    8.12 What is the relationship between an event-listener interface and an event-adapter class ? . . . . . . . . . . . . . . 19
    8.13 How can a GUI component handle its own events ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
    8.14 What advantage do Java’s layout managers provide over traditional windowing systems ? . . . . . . . . . . . . . 19
    8.15 What is the design pattern that Java uses for all Swing components ? . . . . . . . . . . . . . . . . . . . . . . . . 19

9   JDBC                                                                                                                          20
    9.1   What is JDBC ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
    9.2   Explain the role of Driver in JDBC. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
    9.3   What is the purpose Class.forName method ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
    9.4   What is the advantage of PreparedStatement over Statement ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
    9.5   What is the use of CallableStatement ? Name the method, which is used to prepare a CallableStatement. . . . . . 20
    9.6   What does Connection pooling mean ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
-----------------------Page 5 End-----------------------

Java Interview Questions                                                                                                         v



10 Remote Method Invocation (RMI)                                                                                               22
   10.1 What is RMI ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
   10.2 What is the basic principle of RMI architecture ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
   10.3 What are the layers of RMI Architecture ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
   10.4 What is the role of Remote Interface in RMI ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
   10.5 What is the role of the java.rmi.Naming Class ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
   10.6 What is meant by binding in RMI ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
   10.7 What is the difference between using bind() and rebind() methods of Naming Class ? . . . . . . . . . . . . . . . 23
   10.8 What are the steps involved to make work a RMI program ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
   10.9 What is the role of stub in RMI ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
   10.10What is DGC ? And how does it work ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
   10.11What is the purpose of using RMISecurityManager in RMI ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
   10.12Explain Marshalling and demarshalling. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
   10.13Explain Serialization and Deserialization. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24

11 Servlets                                                                                                                     25
   11.1 What is a Servlet ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
   11.2 Explain the architechure of a Servlet. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
   11.3 What is the difference between an Applet and a Servlet ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
   11.4 What is the difference between GenericServlet and HttpServlet ? . . . . . . . . . . . . . . . . . . . . . . . . . . 25
   11.5 Explain the life cycle of a Servlet. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
   11.6 What is the difference between doGet() and doPost() ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
   11.7 What is meant by a Web Application ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
   11.8 What is a Server Side Include (SSI) ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
   11.9 What is Servlet Chaining ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
   11.10How do you find out what client machine is making a request to your servlet ? . . . . . . . . . . . . . . . . . . . 26
   11.11What is the structure of the HTTP response ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
   11.12What is a cookie ? What is the difference between session and cookie ? . . . . . . . . . . . . . . . . . . . . . . 27
   11.13Which protocol will be used by browser and servlet to communicate ? . . . . . . . . . . . . . . . . . . . . . . . 27
   11.14What is HTTP Tunneling ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
   11.15What’s the difference between sendRedirect and forward methods ? . . . . . . . . . . . . . . . . . . . . . . . . 27
   11.16What is URL Encoding and URL Decoding ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27

12 JSP                                                                                                                          28
   12.1 What is a JSP Page ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
   12.2 How are the JSP requests handled ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
   12.3 What are the advantages of JSP ? . . . . . . . . . . . . . . . . . . . . . .. . . . . . . . . . . . . . . . . . . . . . 28
   12.4 What are Directives ? What are the different types of Directives available in JSP ? . . . . . . . . . . . . . . . . . 28
   12.5 What are JSP actions ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
   12.6 What are Scriptlets ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
   12.7 What are Decalarations ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
   12.8 What are Expressions ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
   12.9 What is meant by implicit objects and what are they ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
-----------------------Page 6 End-----------------------

Java Interview Questions                                              vi




Copyright (c) Exelixis Media P.C., 2014

All rights reserved. Without limiting the rights under
copyright reserved above, no part of this publication
may be reproduced, stored or introduced into a retrieval system, or
transmitted, in any form or by any means (electronic, mechanical,
photocopying, recording or otherwise), without the prior written
permission of the copyright owner.
-----------------------Page 7 End-----------------------

Java Interview Questions                                                                                                        vii




Preface

In this guide we will discuss about different types of questions that can be used in a Java interview, in order for the employer to
test your skills in Java and object-oriented programming in general.
In the following sections we will discuss about object-oriented programming and its characteristics, general questions regarding
Java and its functionality, collections in Java, garbage collectors, exception handling, Java applets, Swing, JDBC, Remote Method
Invocation (RMI), Servlets and JSP.
-----------------------Page 8 End-----------------------

Java Interview Questions                                                                                                  viii




About the Author

Sotirios-Efstathios (Stathis) Maneas is a postgraduate student at the Department of Informatics and Telecommunications of The
National and Kapodistrian University of Athens. His main interests include distributed systems, web crawling, model checking,
operating systems, programming languages and web applications.
-----------------------Page 9 End-----------------------

Java Interview Questions                                                                                                     1 / 30




Chapter 1

Object Oriented Programming (OOP)

Java is a computer programming language that is concurrent, class-based and object-oriented. The advantages of object oriented
software development are shown below:

• Modular development of code, which leads to easy maintenance and modification.
• Reusability of code.
• Improved reliability and flexibility of code.
• Increased understanding of code.

Object-oriented programming contains many significant features, such as encapsulation, inheritance, polymorphism and ab-
straction. We analyze each feature separately in the following sections.


1.1     Encapsulation

Encapsulation provides objects with the ability to hide their internal characteristics and behavior. Each object provides a number
of methods, which can be accessed by other objects and change its internal data. In Java, there are three access modifiers: public,
private and protected. Each modifier imposes different access rights to other classes, either in the same or in external packages.
Some of the advantages of using encapsulation are listed below:

• The internal state of every objected is protected by hiding its attributes.
• It increases usability and maintenance of code, because the behavior of an object can be independently changed or extended.
• It improves modularity by preventing objects to interact with each other, in an undesired way.

You can refer to our tutorial here for more details and examples on encapsulation.


1.2     Polymorphism

Polymorphism is the ability of programming languages to present the same interface for differing underlying data types. A
polymorphic type is a type whose operations can also be applied to values of some other type.


1.3     Inheritance

Inheritance provides an object with the ability to acquire the fields and methods of another class, called base class. Inheritance
provides re-usability of code and can be used to add additional features to an existing class, without modifying it.
-----------------------Page 10 End-----------------------

Java Interview Questions                                                                                                       2 / 30




1.4     Abstraction

Abstraction is the process of separating ideas from specific instances and thus, develop classes in terms of their own functionality,
instead of their implementation details. Java supports the creation and existence of abstract classes that expose interfaces, without
including the actual implementation of all methods. The abstraction technique aims to separate the implementation details of a
class from its behavior.


1.5     Differences between Abstraction and Encapsulation

Abstraction and encapsulation are complementary concepts. On the one hand, abstraction focuses on the behavior of an object.
On the other hand, encapsulation focuses on the implementation of an object’s behavior. Encapsulation is usually achieved by
hiding information about the internal state of an object and thus, can be seen as a strategy used in order to provide abstraction.
-----------------------Page 11 End-----------------------

Java Interview Questions                                                                                                       3 / 30




Chapter 2


General Questions about Java


2.1     What is JVM ? Why is Java called the Platform Independent Programming Lan-
        guage?

A Java virtual machine (JVM) is a process virtual machine that can execute Java bytecode. Each Java source file is compiled
into a bytecode file, which is executed by the JVM. Java was designed to allow application programs to be built that could be
run on any platform, without having to be rewritten or recompiled by the programmer for each separate platform. A Java virtual
machine makes this possible, because it is aware of the specific instruction lengths and other particularities of the underlying
hardware platform.


2.2     What is the Difference between JDK and JRE ?

The Java Runtime Environment (JRE) is basically the Java Virtual Machine (JVM) where your Java programs are being executed.
It also includes browser plugins for applet execution. The Java Development Kit (JDK) is the full featured Software Development
Kit for Java, including the JRE, the compilers and tools (like JavaDoc, and Java Debugger), in order for a user to develop, compile
and execute Java applications.


2.3     What does the “static” keyword mean ? Can you override private or static
        method in Java ?

The static keyword denotes that a member variable or method can be accessed, without requiring an instantiation of the class to
which it belongs. A user cannot override static methods in Java, because method overriding is based upon dynamic binding at
runtime and static methods are statically binded at compile time. A static method is not associated with any instance of a class
so the concept is not applicable.


2.4     Can you access non static variable in static context ?

A static variable in Java belongs to its class and its value remains the same for all its instances. A static variable is initialized
when the class is loaded by the JVM. If your code tries to access a non-static variable, without any instance, the compiler will
complain, because those variables are not created yet and they are not associated with any instance.
-----------------------Page 12 End-----------------------

Java Interview Questions                                                                                                    4 / 30




2.5       What are the Data Types supported by Java ? What is Autoboxing and Unbox-
          ing ?

The eight primitive data types supported by the Java programming language are:

• byte
• short
• int
• long
• float
• double
• boolean
• char

Autoboxing is the automatic conversion made by the Java compiler between the primitive types and their corresponding object
wrapper classes. For example, the compiler converts an int to an Integer, a double to a Double, and so on. If the conversion goes
the other way, this operation is called unboxing.


2.6       What is Function Overriding and Overloading in Java ?

Method overloading in Java occurs when two or more methods in the same class have the exact same name, but different
parameters. On the other hand, method overriding is defined as the case when a child class redefines the same method as a parent
class. Overridden methods must have the same name, argument list, and return type. The overriding method may not limit the
access of the method it overrides.


2.7       What is a Constructor, Constructor Overloading in Java and Copy-Constructor

A constructor gets invoked when a new object is created. Every class has a constructor. In case the programmer does not provide
a constructor for a class, the Java compiler (Javac) creates a default constructor for that class. The constructor overloading is
similar to method overloading in Java. Different constructors can be created for a single class. Each constructor must have its
own unique parameter list. Finally, Java does support copy constructors like C++, but the difference lies in the fact that Java
doesn’t create a default copy constructor if you don’t write your own.


2.8       Does Java support multiple inheritance ?

No, Java does not support multiple inheritance. Each class is able to extend only on one class, but is able to implement more than
one interfaces.


2.9       What is the difference between an Interface and an Abstract class ?

Java provides and supports the creation both of abstract classes and interfaces. Both implementations share some common
characteristics, but they differ in the following features:

• All methods in an interface are implicitly abstract. On the other hand, an abstract class may contain both abstract and non-
  abstract methods.
-----------------------Page 13 End-----------------------

Java Interview Questions                                                                                                      5 / 30



• A class may implement a number of Interfaces, but can extend only one abstract class.
• In order for a class to implement an interface, it must implement all its declared methods. However, a class may not implement
  all declared methods of an abstract class. Though, in this case, the sub-class must also be declared as abstract.

• Abstract classes can implement interfaces without even providing the implementation of interface methods.
• Variables declared in a Java interface is by default final. An abstract class may contain non-final variables.
• Members of a Java interface are public by default. A member of an abstract class can either be private, protected or public.
• An interface is absolutely abstract and cannot be instantiated. An abstract class also cannot be instantiated, but can be invoked
  if it contains a main method.

Also check out the Abstract class and Interface differences for JDK 8.


2.10     What are pass by reference and pass by value ?

When an object is passed by value, this means that a copy of the object is passed. Thus, even if changes are made to that object,
it doesn’t affect the original value. When an object is passed by reference, this means that the actual object is not passed, rather
a reference of the object is passed. Thus, any changes made by the external method, are also reflected in all places.
-----------------------Page 14 End-----------------------

Java Interview Questions                                                                                                    6 / 30




Chapter 3


Java Threads


3.1     What is the difference between processes and threads ?

A process is an execution of a program, while a Thread is a single execution sequence within a process. A process can contain
multiple threads. A Thread is sometimes called a lightweight process.


3.2     Explain different ways of creating a thread. Which one would you prefer and
        why ?

There are three ways that can be used in order for a Thread to be created:

• A class may extend the Thread class.
• A class may implement the Runnable interface.
• An application can use the Executor framework, in order to create a thread pool.

The Runnable interface is preferred, as it does not require an object to inherit the Thread class. In case your application design
requires multiple inheritance, only interfaces can help you. Also, the thread pool is very efficient and can be implemented and
used very easily.


3.3     Explain the available thread states in a high-level.

During its execution, a thread can reside in one of the following states:

• Runnable: A thread becomes ready to run, but does not necessarily start running immediately.
• Running: The processor is actively executing the thread code.

• Waiting: A thread is in a blocked state waiting for some external processing to finish.
• Sleeping: The thread is forced to sleep.
• Blocked on I/O: Waiting for an I/O operation to complete.
• Blocked on Synchronization: Waiting to acquire a lock.

• Dead: The thread has finished its execution.
-----------------------Page 15 End-----------------------

Java Interview Questions                                                                                                   7 / 30




3.4    What is the difference between a synchronized method and a synchronized
       block ?

In Java programming, each object has a lock. A thread can acquire the lock for an object by using the synchronized keyword.
The synchronized keyword can be applied in a method level (coarse grained lock) or block level of code (fine grained lock).


3.5    How does thread synchronization occurs inside a monitor ? What levels of
       synchronization can you apply ?

The JVM uses locks in conjunction with monitors. A monitor is basically a guardian that watches over a sequence of synchronized
code and ensuring that only one thread at a time executes a synchronized piece of code. Each monitor is associated with an object
reference. The thread is not allowed to execute the code until it obtains the lock.


3.6    What’s a deadlock ?

A condition that occurs when two processes are waiting for each other to complete, before proceeding. The result is that both
processes wait endlessly.


3.7    How do you ensure that N threads can access N resources without deadlock ?

A very simple way to avoid deadlock while using N threads is to impose an ordering on the locks and force each thread to follow
that ordering. Thus, if all threads lock and unlock the mutexes in the same order, no deadlocks can arise.
-----------------------Page 16 End-----------------------

Java Interview Questions                                                                                                       8 / 30




Chapter 4

Java Collections


4.1     What are the basic interfaces of Java Collections Framework ?

Java Collections Framework provides a well designed set of interfaces and classes that support operations on a collections of
objects. The most basic interfaces that reside in the Java Collections Framework are:

• Collection, which represents a group of objects known as its elements.
• Set, which is a collection that cannot contain duplicate elements.
• List, which is an ordered collection and can contain duplicate elements.
• Map, which is an object that maps keys to values and cannot contain duplicate keys.


4.2     Why Collection doesn’t extend Cloneable and Serializable interfaces ?

The Collection interface specifies groups of objects known as elements. Each concrete implementation of a Collection can choose
its own way of how to maintain and order its elements. Some collections allow duplicate keys, while some other collections don’t.
The semantics and the implications of either cloning or serialization come into play when dealing with actual implementations.
Thus, the concrete implementations of collections should decide how they can be cloned or serialized.


4.3     What is an Iterator ?

The Iterator interface provides a number of methods that are able to iterate over any Collection. Each Java Collection contains
the iterator method that returns an Iterator instance. Iterators are capable of removing elements from the underlying collection
during the iteration.


4.4     What differences exist between Iterator and ListIterator ?

The differences of these elements are listed below:

• An Iterator can be used to traverse the Set and List collections, while the ListIterator can be used to iterate only over Lists.
• The Iterator can traverse a collection only in forward direction, while the ListIterator can traverse a List in both directions.
• The ListIterator implements the Iterator interface and contains extra functionality, such as adding an element, replacing an
  element, getting the index position for previous and next elements, etc.
-----------------------Page 17 End-----------------------

Java Interview Questions                                                                                                        9 / 30




4.5     What is difference between fail-fast and fail-safe ?

The Iterator’s fail-safe property works with the clone of the underlying collection and thus, it is not affected by any modification
in the collection. All the collection classes in java.util package are fail-fast, while the collection classes in java.util.concurrent
are fail-safe. Fail-fast iterators throw a ConcurrentModificationException, while fail-safe iterator never throws such
an exception.


4.6     How HashMap works in Java ?

A HashMap in Java stores key-value pairs. The HashMap requires a hash function and uses hashCode and equals methods,
in order to put and retrieve elements to and from the collection respectively. When the put method is invoked, the HashMap
calculates the hash value of the key and stores the pair in the appropriate index inside the collection. If the key exists, its value
is updated with the new value. Some important characteristics of a HashMap are its capacity, its load factor and the threshold
resizing.


4.7     What is the importance of hashCode() and equals() methods ?

In Java, a HashMap uses the hashCode and equals methods to determine the index of the key-value pair and to detect duplicates.
More specifically, the hashCode method is used in order to determine where the specified key will be stored. Since different keys
may produce the same hash value, the equals method is used, in order to determine whether the specified key actually exists in
the collection or not. Therefore, the implementation of both methods is crucial to the accuracy and efficiency of the HashMap.


4.8     What differences exist between HashMap and Hashtable ?

Both the HashMap and Hashtable classes implement the Map interface and thus, have very similar characteristics. However, they
differ in the following features:

• A HashMap allows the existence of null keys and values, while a Hashtable doesn’t allow neither null keys, nor null values.
• A Hashtable is synchronized, while a HashMap is not. Thus, HashMap is preferred in single-threaded environments, while a
  Hashtable is suitable for multi-threaded environments.

• A HashMap provides its set of keys and a Java application can iterate over them. Thus, a HashMap is fail-fast. On the other
  hand, a Hashtable provides an Enumeration of its keys.
• The Hashtable class is considered to be a legacy class.


4.9     What is difference between Array and ArrayList ? When will you use Array over
        ArrayList ?

The Array and ArrayList classes differ on the following features:

• Arrays can contain primitive or objects, while an ArrayList can contain only objects.

• Arrays have fixed size, while an ArrayList is dynamic.
• An ArrayList provides more methods and features, such as addAll, removeAll, iterator, etc.
• For a list of primitive data types, the collections use autoboxing to reduce the coding effort. However, this approach makes
  them slower when working on fixed size primitive data types.
-----------------------Page 18 End-----------------------

Java Interview Questions                                                                                                       10 / 30




4.10      What is difference between ArrayList and LinkedList ?

Both the ArrayList and LinkedList classes implement the List interface, but they differ on the following features:

• An ArrayList is an index based data structure backed by an Array. It provides random access to its elements with a performance
  equal to O(1). On the other hand, a LinkedList stores its data as list of elements and every element is linked to its previous and
  next element. In this case, the search operation for an element has execution time equal to O(n).
• The Insertion, addition and removal operations of an element are faster in a LinkedList compared to an ArrayList, because
  there is no need of resizing an array or updating the index when an element is added in some arbitrary position inside the
  collection.
• A LinkedList consumes more memory than an ArrayList, because every node in a LinkedList stores two references, one for its
  previous element and one for its next element.

Check also our article ArrayList vs. LinkedList.


4.11      What is Comparable and Comparator interface ? List their differences.

Java provides the Comparable interface, which contains only one method, called compareTo. This method compares two objects,
in order to impose an order between them. Specifically, it returns a negative integer, zero, or a positive integer to indicate that the
input object is less than, equal or greater than the existing object. Java provides the Comparator interface, which contains two
methods, called compare and equals. The first method compares its two input arguments and imposes an order between them.
It returns a negative integer, zero, or a positive integer to indicate that the first argument is less than, equal to, or greater than
the second. The second method requires an object as a parameter and aims to decide whether the input object is equal to the
comparator. The method returns true, only if the specified object is also a comparator and it imposes the same ordering as the
comparator.


4.12      What is Java Priority Queue ?

The PriorityQueue is an unbounded queue, based on a priority heap and its elements are ordered in their natural order. At the time
of its creation, we can provide a Comparator that is responsible for ordering the elements of the PriorityQueue. A PriorityQueue
doesn’t allow null values, those objects that doesn’t provide natural ordering, or those objects that don’t have any comparator
associated with them. Finally, the Java PriorityQueue is not thread-safe and it requires O(log(n)) time for its enqueing and
dequeing operations.


4.13      What do you know about the big-O notation and can you give some examples
          with respect to different data structures ?

The Big-O notation simply describes how well an algorithm scales or performs in the worst case scenario as the number of ele-
ments in a data structure increases. The Big-O notation can also be used to describe other behavior such as memory consumption.
Since the collection classes are actually data structures, we usually use the Big-O notation to chose the best implementation to
use, based on time, memory and performance. Big-O notation can give a good indication about performance for large amounts
of data.


4.14      What is the tradeoff between using an unordered array versus an ordered
          array ?

The major advantage of an ordered array is that the search times have time complexity of O(log n), compared to that of an
unordered array, which is O (n). The disadvantage of an ordered array is that the insertion operation has a time complexity of
O(n), because the elements with higher values must be moved to make room for the new element. Instead, the insertion operation
for an unordered array takes constant time of O(1).
-----------------------Page 19 End-----------------------

Java Interview Questions                                                                                                     11 / 30




4.15     What are some of the best practices relating to the Java Collection framework
         ?

• Choosing the right type of the collection to use, based on the application’s needs, is very crucial for its performance. For
  example if the size of the elements is fixed and know a priori, we shall use an Array, instead of an ArrayList.
• Some collection classes allow us to specify their initial capacity. Thus, if we have an estimation on the number of elements
  that will be stored, we can use it to avoid rehashing or resizing.
• Always use Generics for type-safety, readability, and robustness. Also, by using Generics you avoid the ClassCastException
  during runtime.
• Use immutable classes provided by the Java Development Kit (JDK) as a key in a Map, in order to avoid the implementation
  of the hashCode and equals methods for our custom class.
• Program in terms of interface not implementation.

• Return zero-length collections or arrays as opposed to returning a null in case the underlying collection is actually empty.


4.16     What’s the difference between Enumeration and Iterator interfaces ?

Enumeration is twice as fast as compared to an Iterator and uses very less memory. However, the Iterator is much safer compared
to Enumeration, because other threads are not able to modify the collection object that is currently traversed by the iterator. Also,
Iteratorsallow the caller to remove elements from the underlying collection, something which is not possible with Enumerations.


4.17     What is the difference between HashSet and TreeSet ?

The HashSet is Implemented using a hash table and thus, its elements are not ordered. The add, remove, and contains methods of
a HashSet have constant time complexity O(1). On the other hand, a TreeSet is implemented using a tree structure. The elements
in a TreeSet are sorted, and thus, the add, remove, and contains methods have time complexity of O(logn).
-----------------------Page 20 End-----------------------

Java Interview Questions                                                                                                    12 / 30




Chapter 5


Garbage Collectors


5.1     What is the purpose of garbage collection in Java, and when is it used ?

The purpose of garbage collection is to identify and discard those objects that are no longer needed by the application, in order
for the resources to be reclaimed and reused.


5.2     What does System.gc() and Runtime.gc() methods do ?

These methods can be used as a hint to the JVM, in order to start a garbage collection. However, this it is up to the Java Virtual
Machine (JVM) to start the garbage collection immediately or later in time.


5.3     When is the finalize() called ? What is the purpose of finalization ?

The finalize method is called by the garbage collector, just before releasing the object’s memory. It is normally advised to release
resources held by the object inside the finalize method.


5.4     If an object reference is set to null, will the Garbage Collector immediately free
        the memory held by that object ?

No, the object will be available for garbage collection in the next cycle of the garbage collector.


5.5     What is structure of Java Heap ? What is Perm Gen space in Heap ?

The JVM has a heap that is the runtime data area from which memory for all class instances and arrays is allocated. It is created
at the JVM start-up. Heap memory for objects is reclaimed by an automatic memory management system which is known as a
garbage collector. Heap memory consists of live and dead objects. Live objects are accessible by the application and will not
be a subject of garbage collection. Dead objects are those which will never be accessible by the application, but have not been
collected by the garbage collector yet. Such objects occupy the heap memory space until they are eventually collected by the
garbage collector.
-----------------------Page 21 End-----------------------

Java Interview Questions                                                                                                     13 / 30




5.6     What is the difference between Serial and Throughput Garbage collector ?

The throughput garbage collector uses a parallel version of the young generation collector and is meant to be used with applica-
tions that have medium to large data sets. On the other hand, the serial collector is usually adequate for most small applications
(those requiring heaps of up to approximately 100MB on modern processors).


5.7     When does an Object becomes eligible for Garbage collection in Java ?

A Java object is subject to garbage collection when it becomes unreachable to the program in which it is currently used.


5.8     Does Garbage collection occur in permanent generation space in JVM ?

Garbage Collection does occur in PermGen space and if PermGen space is full or cross a threshold, it can trigger a full garbage
collection. If you look carefully at the output of the garbage collector, you will find that PermGen space is also garbage collected.
This is the reason why correct sizing of PermGen space is important to avoid frequent full garbage collections. Also check our
article Java 8: PermGen to Metaspace.
-----------------------Page 22 End-----------------------

Java Interview Questions                                                                                                    14 / 30




Chapter 6


Exception Handling


6.1    What are the two types of Exceptions in Java ? Which are the differences
       between them ?

Java has two types of exceptions: checked exceptions and unchecked exceptions. Unchecked exceptions do not need to be
declared in a method or a constructor’s throws clause, if they can be thrown by the execution of the method or the constructor,
and propagate outside the method or constructor boundary. On the other hand, checked exceptions must be declared in a method
or a constructor’s throws clause. See here for tips on Java exception handling.


6.2    What is the difference between Exception and Error in java ?

Exception and Error classes are both subclasses of the Throwable class. The Exception class is used for exceptional conditions
that a user’s program should catch. The Error class defines exceptions that are not excepted to be caught by the user program.


6.3    What is the difference between throw and throws ?

The throw keyword is used to explicitly raise a exception within the program. On the contrary, the throws clause is used to
indicate those exceptions that are not handled by a method. Each method must explicitly specify which exceptions does not
handle, so the callers of that method can guard against possible exceptions. Finally, multiple exceptions are separated by a
comma.


6.4    What is the importance of finally block in exception handling ?

A finally block will always be executed, whether or not an exception is actually thrown. Even in the case where the catch
statement is missing and an exception is thrown, the finally block will still be executed. Last thing to mention is that the finally
block is used to release resources like I/O buffers, database connections, etc.


6.5    What will happen to the Exception object after exception handling ?

The Exception object will be garbage collected in the next garbage collection.
-----------------------Page 23 End-----------------------

Java Interview Questions                                                                                                  15 / 30




6.6    How does finally block differ from finalize() method ?

A finally block will be executed whether or not an exception is thrown and is used to release those resources held by the
application. Finalize is a protected method of the Object class, which is called by the Java Virtual Machine (JVM) just before an
object is garbage collected.
-----------------------Page 24 End-----------------------

Java Interview Questions                                                                                                            16 / 30




Chapter 7

Java Applets


7.1     What is an Applet ?

A java applet is program that can be included in a HTML page and be executed in a java enabled client browser. Applets are used
for creating dynamic and interactive web applications.


7.2     Explain the life cycle of an Applet.

An applet may undergo the following states:

• Init: An applet is initialized each time is loaded.
• Start: Begin the execution of an applet.
• Stop: Stop the execution of an applet.
• Destroy: Perform a final cleanup, before unloading the applet.


7.3     What happens when an applet is loaded ?

First of all, an instance of the applet’s controlling class is created. Then, the applet initializes itself and finally, it starts running.


7.4     What is the difference between an Applet and a Java Application ?

Applets are executed within a java enabled browser, but a Java application is a standalone Java program that can be executed
outside of a browser. However, they both require the existence of a Java Virtual Machine (JVM). Furthermore, a Java application
requires a main method with a specific signature, in order to start its execution. Java applets don’t need such a method to start
their execution. Finally, Java applets typically use a restrictive security policy, while Java applications usually use more relaxed
security policies.


7.5     What are the restrictions imposed on Java applets ?

Mostly due to security reasons, the following restrictions are imposed on Java applets:

• An applet cannot load libraries or define native methods.
-----------------------Page 25 End-----------------------

Java Interview Questions                                                                                                      17 / 30



• An applet cannot ordinarily read or write files on the execution host.
• An applet cannot read certain system properties.
• An applet cannot make network connections except to the host that it came from.

• An applet cannot start any program on the host that’s executing it.


7.6     What are untrusted applets ?

Untrusted applets are those Java applets that cannot access or execute local system files. By default, all downloaded applets are
considered as untrusted.


7.7     What is the difference between applets loaded over the internet and applets
        loaded via the file system ?

Regarding the case where an applet is loaded over the internet, the applet is loaded by the applet classloader and is subject to the
restrictions enforced by the applet security manager. Regarding the case where an applet is loaded from the client’s local disk,
the applet is loaded by the file system loader. Applets loaded via the file system are allowed to read files, write files and to load
libraries on the client. Also, applets loaded via the file system are allowed to execute processes and finally, applets loaded via the
file system are not passed through the byte code verifier.


7.8     What is the applet class loader, and what does it provide ?

When an applet is loaded over the internet, the applet is loaded by the applet classloader. The class loader enforces the Java name
space hierarchy. Also, the class loader guarantees that a unique namespace exists for classes that come from the local file system,
and that a unique namespace exists for each network source. When a browser loads an applet over the net, that applet’s classes
are placed in a private namespace associated with the applet’s origin. Then, those classes loaded by the class loader are passed
through the verifier.The verifier checks that the class file conforms to the Java language specification . Among other things, the
verifier ensures that there are no stack overflows or underflows and that the parameters to all bytecode instructions are correct.


7.9     What is the applet security manager, and what does it provide ?

The applet security manager is a mechanism to impose restrictions on Java applets. A browser may only have one security
manager. The security manager is established at startup, and it cannot thereafter be replaced, overloaded, overridden, or extended.
-----------------------Page 26 End-----------------------

Java Interview Questions                                                                                                  18 / 30




Chapter 8

Swing


8.1    What is the difference between a Choice and a List ?

A Choice is displayed in a compact form that must be pulled down, in order for a user to be able to see the list of all available
choices. Only one item may be selected from a Choice. A List may be displayed in such a way that several List items are visible.
A List supports the selection of one or more List items.


8.2    What is a layout manager ?

A layout manager is the used to organize the components in a container.


8.3    What is the difference between a Scrollbar and a JScrollPane ?

A Scrollbar is a Component, but not a Container. A ScrollPane is a Container. A ScrollPane handles its own events and performs
its own scrolling.


8.4    Which Swing methods are thread-safe ?

There are only three thread-safe methods: repaint, revalidate, and invalidate.


8.5    Name three Component subclasses that support painting.

The Canvas, Frame, Panel, and Applet classes support painting.


8.6    What is clipping ?

Clipping is defined as the process of confining paint operations to a limited area or shape.


8.7    What is the difference between a MenuItem and a CheckboxMenuItem ?

The CheckboxMenuItem class extends the MenuItem class and supports a menu item that may be either checked or unchecked.
-----------------------Page 27 End-----------------------

Java Interview Questions                                                                                                19 / 30




8.8    How are the elements of a BorderLayout organized ?

The elements of a BorderLayout are organized at the borders (North, South, East, and West) and the center of a container.


8.9    How are the elements of a GridBagLayout organized ?

The elements of a GridBagLayout are organized according to a grid. The elements are of different sizes and may occupy more
than one row or column of the grid. Thus, the rows and columns may have different sizes.


8.10     What is the difference between a Window and a Frame ?

The Frame class extends the Window class and defines a main application window that can have a menu bar.


8.11     What is the relationship between clipping and repainting ?

When a window is repainted by the AWT painting thread, it sets the clipping regions to the area of the window that requires
repainting.


8.12     What is the relationship between an event-listener interface and an event-
         adapter class ?

An event-listener interface defines the methods that must be implemented by an event handler for a particular event. An event
adapter provides a default implementation of an event-listener interface.


8.13     How can a GUI component handle its own events ?

A GUI component can handle its own events, by implementing the corresponding event-listener interface and adding itself as its
own event listener.


8.14     What advantage do Java’s layout managers provide over traditional window-
         ing systems ?

Java uses layout managers to lay out components in a consistent manner, across all windowing platforms. Since layout man-
agers aren’t tied to absolute sizing and positioning, they are able to accomodate platform-specific differences among windowing
systems.


8.15     What is the design pattern that Java uses for all Swing components ?

The design pattern used by Java for all Swing components is the Model View Controller (MVC) pattern.
-----------------------Page 28 End-----------------------

Java Interview Questions                                                                                               20 / 30




Chapter 9


JDBC


9.1    What is JDBC ?

JDBC is an abstraction layer that allows users to choose between databases. JDBC enables developers to write database applica-
tions in Java, without having to concern themselves with the underlying details of a particular database.


9.2    Explain the role of Driver in JDBC.

The JDBC Driver provides vendor-specific implementations of the abstract classes provided by the JDBC API. Each driver
must provide implementations for the following classes of the java.sql package:Connection, Statement, PreparedStatement,
CallableStatement, ResultSet and Driver.


9.3    What is the purpose Class.forName method ?

This method is used to method is used to load the driver that will establish a connection to the database.


9.4    What is the advantage of PreparedStatement over Statement ?

PreparedStatements are precompiled and thus, their performance is much better. Also, PreparedStatement objects can be reused
with different input values to their queries.


9.5    What is the use of CallableStatement ? Name the method, which is used to
       prepare a CallableStatement.

A CallableStatement is used to execute stored procedures. Stored procedures are stored and offered by a database. Stored
procedures may take input values from the user and may return a result. The usage of stored procedures is highly encouraged,
because it offers security and modularity.The method that prepares a CallableStatement is the following: CallableStament.
prepareCall();
-----------------------Page 29 End-----------------------

Java Interview Questions                                                                                                    21 / 30




9.6    What does Connection pooling mean ?

The interaction with a database can be costly, regarding the opening and closing of database connections. Especially, when the
number of database clients increases, this cost is very high and a large number of resources is consumed.A pool of database
connections is obtained at start up by the application server and is maintained in a pool. A request for a connection is served by a
connection residing in the pool. In the end of the connection, the request is returned to the pool and can be used to satisfy future
requests.
-----------------------Page 30 End-----------------------

Java Interview Questions                                                                                                   22 / 30




Chapter 10


Remote Method Invocation (RMI)


10.1     What is RMI ?

The Java Remote Method Invocation (Java RMI) is a Java API that performs the object-oriented equivalent of remote procedure
calls (RPC), with support for direct transfer of serialized Java classes and distributed garbage collection. Remote Method Invoca-
tion (RMI) can also be seen as the process of activating a method on a remotely running object. RMI offers location transparency
because a user feels that a method is executed on a locally running object. Check some RMI Tips here.


10.2     What is the basic principle of RMI architecture ?

The RMI architecture is based on a very important principle which states that the definition of the behavior and the implemen-
tation of that behavior, are separate concepts. RMI allows the code that defines the behavior and the code that implements the
behavior to remain separate and to run on separate JVMs.


10.3     What are the layers of RMI Architecture ?

The RMI architecture consists of the following layers:

• Stub and Skeleton layer: This layer lies just beneath the view of the developer. This layer is responsible for intercepting
  method calls made by the client to the interface and redirect these calls to a remote RMI Service.

• Remote Reference Layer: The second layer of the RMI architecture deals with the interpretation of references made from
  the client to the server’s remote objects. This layer interprets and manages references made from clients to the remote service
  objects. The connection is a one-to-one (unicast) link.
• Transport layer: This layer is responsible for connecting the two JVM participating in the service. This layer is based on
  TCP/IP connections between machines in a network. It provides basic connectivity, as well as some firewall penetration
  strategies.


10.4     What is the role of Remote Interface in RMI ?

The Remote interface serves to identify interfaces whose methods may be invoked from a non-local virtual machine. Any object
that is a remote object must directly or indirectly implement this interface. A class that implements a remote interface should
declare the remote interfaces being implemented, define the constructor for each remote object and provide an implementation
for each remote method in all remote interfaces.
-----------------------Page 31 End-----------------------

Java Interview Questions                                                                                                    23 / 30




10.5      What is the role of the java.rmi.Naming Class ?

The java.rmi.Naming class provides methods for storing and obtaining references to remote objects in the remote object registry.
Each method of the Naming class takes as one of its arguments a name that is a String in URL format.


10.6      What is meant by binding in RMI ?

Binding is the process of associating or registering a name for a remote object, which can be used at a later time, in order to look
up that remote object. A remote object can be associated with a name using the bind or rebind methods of the Naming class.


10.7      What is the difference between using bind() and rebind() methods of Naming
          Class ?

The bind method bind is responsible for binding the specified name to a remote object, while the rebind method is responsible
for rebinding the specified name to a new remote object. In case a binding exists for that name, the binding is replaced.


10.8      What are the steps involved to make work a RMI program ?

The following steps must be involved in order for a RMI program to work properly:

• Compilation of all source files.
• Generatation of the stubs using rmic.
• Start the rmiregistry.
• Start the RMIServer.
• Run the client program.


10.9      What is the role of stub in RMI ?

A stub for a remote object acts as a client’s local representative or proxy for the remote object. The caller invokes a method on
the local stub, which is responsible for executing the method on the remote object. When a stub’s method is invoked, it undergoes
the following steps:

• It initiates a connection to the remote JVM containing the remote object.
• It marshals the parameters to the remote JVM.
• It waits for the result of the method invocation and execution.
• It unmarshals the return value or an exception if the method has not been successfully executed.
• It returns the value to the caller.


10.10       What is DGC ? And how does it work ?

DGC stands for Distributed Garbage Collection. Remote Method Invocation (RMI) uses DGC for automatic garbage collection.
Since RMI involves remote object references across JVM’s, garbage collection can be quite difficult. DGC uses a reference
counting algorithm to provide automatic memory management for remote objects.
-----------------------Page 32 End-----------------------

Java Interview Questions                                                                                                      24 / 30




10.11      What is the purpose of using RMISecurityManager in RMI ?

RMISecurityManager provides a security manager that can be used by RMI applications, which use downloaded code. The class
loader of RMI will not download any classes from remote locations, if the security manager has not been set.


10.12      Explain Marshalling and demarshalling.

When an application wants to pass its memory objects across a network to another host or persist it to storage, the in-memory
representation must be converted to a suitable format. This process is called marshalling and the revert operation is called
demarshalling.


10.13      Explain Serialization and Deserialization.

Java provides a mechanism, called object serialization where an object can be represented as a sequence of bytes and includes
the object’s data, as well as information about the object’s type, and the types of data stored in the object. Thus, serialization can
be seen as a way of flattening objects, in order to be stored on disk, and later, read back and reconstituted. Deserialisation is the
reverse process of converting an object from its flattened state to a live object.
-----------------------Page 33 End-----------------------

Java Interview Questions                                                                                                   25 / 30




Chapter 11


Servlets


11.1     What is a Servlet ?

The servlet is a Java programming language class used to process client requests and generate dynamic web content. Servlets are
mostly used to process or store data submitted by an HTML form, provide dynamic content and manage state information that
does not exist in the stateless HTTP protocol.


11.2     Explain the architechure of a Servlet.

The core abstraction that must be implemented by all servlets is the javax.servlet.Servlet interface. Each servlet must implement
it either directly or indirectly, either by extending javax.servlet.GenericServlet or javax.servlet.http.HTTPServlet. Finally, each
servlet is able to serve multiple requests in parallel using multithreading.


11.3     What is the difference between an Applet and a Servlet ?

An Applet is a client side java program that runs within a Web browser on the client machine. On the other hand, a servlet is a
server side component that runs on the web server.An applet can use the user interface classes, while a servlet does not have a
user interface. Instead, a servlet waits for client’s HTTP requests and generates a response in every request.


11.4     What is the difference between GenericServlet and HttpServlet ?

GenericServlet is a generalized and protocol-independent servlet that implements the Servlet and ServletConfig interfaces. Those
servlets extending the GenericServlet class shall override the service method. Finally, in order to develop an HTTP servlet for
use on the Web that serves requests using the HTTP protocol, your servlet must extend the HttpServlet instead. Check Servlet
examples here.


11.5     Explain the life cycle of a Servlet.

On every client’s request, the Servlet Engine loads the servlets and invokes its init methods, in order for the servlet to be
initialized. Then, the Servlet object handles all subsequent requests coming from that client, by invoking the service method for
each request separately. Finally, the servlet is removed by calling the server’s destroy method.
-----------------------Page 34 End-----------------------

Java Interview Questions                                                                                                     26 / 30




11.6     What is the difference between doGet() and doPost() ?

doGET: The GET method appends the name-value pairs on the request’s URL. Thus, there is a limit on the number of characters
and subsequently on the number of values that can be used in a client’s request. Furthermore, the values of the request are made
visible and thus, sensitive information must not be passed in that way.
doPOST: The POST method overcomes the limit imposed by the GET request, by sending the values of the request inside its
body. Also, there is no limitations on the number of values to be sent across. Finally, the sensitive information passed through a
POST request is not visible to an external client.


11.7     What is meant by a Web Application ?

A Web application is a dynamic extension of a Web or application server. There are two types of web applications: presentation-
oriented and service-oriented. A presentation-oriented Web application generates interactive web pages, which contain various
types of markup language and dynamic content in response to requests. On the other hand, a service-oriented web application
implements the endpoint of a web service. In general, a Web application can be seen as a collection of servlets installed under a
specific subset of the server’s URL namespace.


11.8     What is a Server Side Include (SSI) ?

Server Side Includes (SSI) is a simple interpreted server-side scripting language, used almost exclusively for the Web, and is
embedded with a servlet tag. The most frequent use of SSI is to include the contents of one or more files into a Web page on a
Web server. When a Web page is accessed by a browser, the Web server replaces the servlet tag in that Web page with the hyper
text generated by the corresponding servlet.


11.9     What is Servlet Chaining ?

Servlet Chaining is the method where the output of one servlet is sent to a second servlet. The output of the second servlet can
be sent to a third servlet, and so on. The last servlet in the chain is responsible for sending the response to the client.


11.10      How do you find out what client machine is making a request to your servlet
           ?

The ServletRequest class has functions for finding out the IP address or host name of the client machine. getRemoteAddr() gets
the IP address of the client machine and getRemoteHost() gets the host name of the client machine. See example here.


11.11      What is the structure of the HTTP response ?

The HTTP response consists of three parts:

• Status Code: describes the status of the response. It can be used to check if the request has been successfully completed. In
  case the request failed, the status code can be used to find out the reason behind the failure. If your servlet does not return a
  status code, the success status code, HttpServletResponse.SC_OK, is returned by default.
• HTTP Headers: they contain more information about the response. For example, the headers may specify the date/time after
  which the response is considered stale, or the form of encoding used to safely transfer the entity to the user. See how to retrieve
  headers in Servlet here.
• Body: it contains the content of the response. The body may contain HTML code, an image, etc. The body consists of the data
  bytes transmitted in an HTTP transaction message immediately following the headers.
-----------------------Page 35 End-----------------------

Java Interview Questions                                                                                                      27 / 30




11.12      What is a cookie ? What is the difference between session and cookie ?

A cookie is a bit of information that the Web server sends to the browser. The browser stores the cookies for each Web server
in a local file. In a future request, the browser, along with the request, sends all stored cookies for that specific Web server.The
differences between session and a cookie are the following:

• The session should work, regardless of the settings on the client browser. The client may have chosen to disable cookies.
  However, the sessions still work, as the client has no ability to disable them in the server side.
• The session and cookies also differ in the amount of information the can store. The HTTP session is capable of storing any
  Java object, while a cookie can only store String objects.


11.13      Which protocol will be used by browser and servlet to communicate ?

The browser communicates with a servlet by using the HTTP protocol.


11.14      What is HTTP Tunneling ?

HTTP Tunneling is a technique by which, communications performed using various network protocols are encapsulated using
the HTTP or HTTPS protocols. The HTTP protocol therefore acts as a wrapper for a channel that the network protocol being
tunneled uses to communicate. The masking of other protocol requests as HTTP requests is HTTP Tunneling.


11.15      What’s the difference between sendRedirect and forward methods ?

The sendRedirect method creates a new request, while the forward method just forwards a request to a new target. The previous
request scope objects are not available after a redirect, because it results in a new request. On the other hand, the previous request
scope objects are available after forwarding. FInally, in general, the sendRedirect method is considered to be slower compare to
the forward method.


11.16      What is URL Encoding and URL Decoding ?

The URL encoding procedure is responsible for replacing all the spaces and every other extra special character of a URL, into
their corresponding Hex representation. In correspondence, URL decoding is the exact opposite procedure.
-----------------------Page 36 End-----------------------

Java Interview Questions                                                                                                      28 / 30




Chapter 12


JSP


12.1     What is a JSP Page ?

A Java Server Page (JSP) is a text document that contains two types of text: static data and JSP elements. Static data can be
expressed in any text-based format, such as HTML or XML. JSP is a technology that mixes static content with dynamically-
generated content. See JSP example here.


12.2     How are the JSP requests handled ?

On the arrival of a JSP request, the browser first requests a page with a .jsp extension. Then, the Web server reads the request and
using the JSP compiler, the Web server converts the JSP page into a servlet class. Notice that the JSP file is compiled only on
the first request of the page, or if the JSP file has changed.The generated servlet class is invoked, in order to handle the browser’s
request. Once the execution of the request is over, the servlet sends a response back to the client. See how to get Request
parameters in a JSP.


12.3     What are the advantages of JSP ?

The advantages of using the JSP technology are shown below:

• JSP pages are dynamically compiled into servlets and thus, the developers can easily make updates to presentation code.

• JSP pages can be pre-compiled.
• JSP pages can be easily combined to static templates, including HTML or XML fragments, with code that generates dynamic
  content.
• Developers can offer customized JSP tag libraries that page authors access using an XML-like syntax.

• Developers can make logic changes at the component level, without editing the individual pages that use the application’s logic.


12.4     What are Directives ? What are the different types of Directives available in
         JSP ?

Directives are instructions that are processed by the JSP engine, when the page is compiled to a servlet. Directives are used to
set page-level instructions, insert data from external files, and specify custom tag libraries. Directives are defined between < %@
and % >. The different types of directives are shown below:
-----------------------Page 37 End-----------------------

Java Interview Questions                                                                                                   29 / 30



• Include directive: it is used to include a file and merges the content of the file with the current page.
• Page directive: it is used to define specific attributes in the JSP page, like error page and buffer.
• Taglib: it is used to declare a custom tag library which is used in the page.


12.5     What are JSP actions ?

JSP actions use constructs in XML syntax to control the behavior of the servlet engine. JSP actions are executed when a JSP
page is requested. They can be dynamically inserted into a file, re-use JavaBeans components, forward the user to another page,
or generate HTML for the Java plugin.Some of the available actions are listed below:

• jsp:include - includes a file, when the JSP page is requested.
• jsp:useBean - finds or instantiates a JavaBean.
• jsp:setProperty - sets the property of a JavaBean.
• jsp:getProperty - gets the property of a JavaBean.
• jsp:forward - forwards the requester to a new page.
• jsp:plugin - generates browser-specific code.


12.6     What are Scriptlets ?

In Java Server Pages (JSP) technology, a scriptlet is a piece of Java-code embedded in a JSP page. The scriptlet is everything
inside the tags. Between these tags, a user can add any valid scriplet.


12.7     What are Decalarations ?

Declarations are similar to variable declarations in Java. Declarations are used to declare variables for subsequent use in expres-
sions or scriptlets. To add a declaration, you must use the sequences to enclose your declarations.


12.8     What are Expressions ?

A JSP expression is used to insert the value of a scripting language expression, converted into a string, into the data stream
returned to the client, by the web server. Expressions are defined between <% =and %> tags.


12.9     What is meant by implicit objects and what are they ?

JSP implicit objects are those Java objects that the JSP Container makes available to developers in each page. A developer can
call them directly, without being explicitly declared. JSP Implicit Objects are also called pre-defined variables.The following
objects are considered implicit in a JSP page:

• application
• page
• request
• response
-----------------------Page 38 End-----------------------

Java Interview Questions   30 / 30



• session
• exception
• out

• config
• pageContext
-----------------------Page 39 End-----------------------

147 Verify Preorder Serialization of a
    Binary Tree

One way to serialize a binary tree is to use pre-order traversal. When we encounter
a non-null node, we record the node’s value. If it is a null node, we record using a
sentinel value such as #.
9
    /   \
   3     2
  / \   / \
 4 1    # 6
/ \ /   \ / \
# # #   # # #


   For example, the above binary tree can be serialized to the string "9,3,4,#,#,1,#,#,2,#,6,#,#",
where # represents a null node.
   Given a string of comma separated values, verify whether it is a correct preorder
traversal serialization of a binary tree. Find an algorithm without reconstructing the
tree.


147.1 Java Solution - Stack

We can keep removing the leaf node until there is no one to remove. If a sequence
is like "4 # #", change it to "#" and continue. We need a stack so that we can record
previous removed nodes.




                                                                                   353 | 531

                                          Page 347 of 496
-----------------------Page 58 End-----------------------

147 Verify Preorder Serialization of a Binary Tree



public boolean isValidSerialization(String preorder) {
   LinkedList<String> stack = new LinkedList<String>();
   String[] arr = preorder.split(",");

    for(int i=0; i<arr.length; i++){
       stack.add(arr[i]);

        while(stack.size()>=3
           && stack.get(stack.size()-1).equals("#")
           && stack.get(stack.size()-2).equals("#")
           && !stack.get(stack.size()-3).equals("#")){

            stack.remove(stack.size()-1);
            stack.remove(stack.size()-1);
            stack.remove(stack.size()-1);

            stack.add("#");
        }

    }

    if(stack.size()==1 && stack.get(0).equals("#"))
       return true;
    else
       return false;
}




354 | 531                            Program Creek


                                 Page 348 of 496
-----------------------Page 59 End-----------------------

148 Populating Next Right Pointers in
    Each Node

Given the following perfect binary tree,
1
        /   \
       2     3
      / \   / \
     4 5    6 7


    After calling your function, the tree should look like:
1 -> NULL
      / \
     2 -> 3 -> NULL
    / \ / \
   4->5->6->7 -> NULL




148.1 Java Solution

This solution is easier to understand. You can use the example tree above to walk
through the algorithm. The basic idea is have 4 pointers to move towards right on two
levels (see comments in the code).




public void connect(TreeLinkNode root) {




                                                                           355 | 531

                                          Page 349 of 496
-----------------------Page 60 End-----------------------

148 Populating Next Right Pointers in Each Node


    if(root == null)
       return;

    TreeLinkNode   lastHead = root;//prevous level’s head
    TreeLinkNode   lastCurrent = null;//previous level’s pointer
    TreeLinkNode   currentHead = null;//currnet level’s head
    TreeLinkNode   current = null;//current level’s pointer

    while(lastHead!=null){
       lastCurrent = lastHead;

        while(lastCurrent!=null){
           if(currentHead == null){
              currentHead = lastCurrent.left;
              current = lastCurrent.left;
           }else{
              current.next = lastCurrent.left;
              current = current.next;
           }

            if(currentHead != null){
               current.next = lastCurrent.right;
               current = current.next;
            }

            lastCurrent = lastCurrent.next;
        }

        //update last head
        lastHead = currentHead;
        currentHead = null;
    }

}




356 | 531                             Program Creek


                                  Page 350 of 496
-----------------------Page 61 End-----------------------

149 Populating Next Right Pointers in
    Each Node II

Follow up for problem "Populating Next Right Pointers in Each Node".
  What if the given tree could be any binary tree? Would your previous solution still
work?


149.1 Analysis

Similar to Populating Next Right Pointers in Each Node, we have 4 pointers at 2 levels
of the tree.




149.2 Java Solution

public void connect(TreeLinkNode root) {
   if(root == null)
      return;

   TreeLinkNode   lastHead = root;//prevous level’s head
   TreeLinkNode   lastCurrent = null;//previous level’s pointer
   TreeLinkNode   currentHead = null;//currnet level’s head
   TreeLinkNode   current = null;//current level’s pointer

   while(lastHead!=null){
      lastCurrent = lastHead;

      while(lastCurrent!=null){
         //left child is not null
         if(lastCurrent.left!=null) {




                                                                            357 | 531

                                       Page 351 of 496
-----------------------Page 62 End-----------------------

149 Populating Next Right Pointers in Each Node II


                if(currentHead == null){
                   currentHead = lastCurrent.left;
                   current = lastCurrent.left;
                }else{
                   current.next = lastCurrent.left;
                   current = current.next;
                }
            }

            //right child is not null
            if(lastCurrent.right!=null){
               if(currentHead == null){
                  currentHead = lastCurrent.right;
                  current = lastCurrent.right;
               }else{
                  current.next = lastCurrent.right;
                  current = current.next;
               }
            }

            lastCurrent = lastCurrent.next;
        }

        //update last head
        lastHead = currentHead;
        currentHead = null;
    }
}




358 | 531                             Program Creek


                                  Page 352 of 496
-----------------------Page 63 End-----------------------

150 Unique Binary Search Trees

Given n, how many structurally unique BST’s (binary search trees) that store values
1...n?
   For example, Given n = 3, there are a total of 5 unique BST’s.
1         3      3     2      1
     \       /    /     / \       \
      3     2    1     1 3         2
     /     /      \                 \
    2     1        2                 3




150.1 Analysis

Let count[i] be the number of unique binary search trees for i. The number of trees are
determined by the number of subtrees which have different root node. For example,
i=0, count[0]=1 //empty tree

i=1, count[1]=1 //one tree

i=2, count[2]=count[0]*count[1] // 0 is root
         + count[1]*count[0] // 1 is root

i=3, count[3]=count[0]*count[2] // 1 is root
         + count[1]*count[1] // 2 is root
         + count[2]*count[0] // 3 is root

i=4, count[4]=count[0]*count[3]          // 1   is root
         + count[1]*count[2] //          2 is   root
         + count[2]*count[1] //          3 is   root
         + count[3]*count[0] //          4 is   root
..
..
..

i=n, count[n] = sum(count[0..k]*count[k+1...n]) 0 <= k < n-1


    Use dynamic programming to solve the problem.


150.2 Java Solution




                                                                             359 | 531

                                            Page 353 of 496
-----------------------Page 64 End-----------------------

150 Unique Binary Search Trees



public int numTrees(int n) {
  int[] count = new int[n + 1];

    count[0] = 1;
    count[1] = 1;

    for (int i = 2; i <= n; i++) {
      for (int j = 0; j <= i - 1; j++) {
        count[i] = count[i] + count[j] * count[i - j - 1];
      }
    }

    return count[n];
}


    Check out how to get all unique binary search trees.




360 | 531                            Program Creek


                                 Page 354 of 496
-----------------------Page 65 End-----------------------

151 Unique Binary Search Trees II

Given n, generate all structurally unique BST’s (binary search trees) that store values
1...n.
   For example, Given n = 3, your program should return all 5 unique BST’s shown
below.
1         3      3     2      1
     \       /    /     / \       \
      3     2    1     1 3         2
     /     /      \                 \
    2     1        2                 3




151.1 Analysis

Check out Unique Binary Search Trees I.
  This problem can be solved by recursively forming left and right subtrees. The
different combinations of left and right subtrees form the set of all unique binary
search trees.


151.2 Java Solution

public List<TreeNode> generateTrees(int n) {
   return generateTrees(1, n);
}

public List<TreeNode> generateTrees(int start, int end) {
   List<TreeNode> list = new LinkedList<>();

    if (start > end) {
       list.add(null);
       return list;
    }

    for (int i = start; i <= end; i++) {
       List<TreeNode> lefts = generateTrees(start, i - 1);
       List<TreeNode> rights = generateTrees(i + 1, end);
       for (TreeNode left : lefts) {
          for (TreeNode right : rights) {
             TreeNode node = new TreeNode(i);




                                                                             361 | 531

                                         Page 355 of 496
-----------------------Page 66 End-----------------------

151 Unique Binary Search Trees II


                node.left = left;
                node.right = right;
                list.add(node);
            }
        }
    }

    return list;
}




362 | 531                             Program Creek


                                 Page 356 of 496
-----------------------Page 67 End-----------------------

152 Sum Root to Leaf Numbers

Given a binary tree containing digits from 0-9 only, each root-to-leaf path could repre-
sent a number. Find the total sum of all root-to-leaf numbers.
  For example,
1
     / \
    2 3


  The root-to-leaf path 1->2 represents the number 12. The root-to-leaf path 1->3
represents the number 13. Return the sum = 12 + 13 = 25.


152.1 Java Solution - Recursive

This problem can be solved by a typical DFS approach.
public int sumNumbers(TreeNode root) {
   int result = 0;
   if(root==null)
      return result;

     ArrayList<ArrayList<TreeNode>> all = new ArrayList<ArrayList<TreeNode>>();
     ArrayList<TreeNode> l = new ArrayList<TreeNode>();
     l.add(root);
     dfs(root, l, all);

     for(ArrayList<TreeNode> a: all){
        StringBuilder sb = new StringBuilder();
        for(TreeNode n: a){
           sb.append(String.valueOf(n.val));
        }
        int currValue = Integer.valueOf(sb.toString());
        result = result + currValue;
     }

     return result;
}

public void dfs(TreeNode n, ArrayList<TreeNode> l,
    ArrayList<ArrayList<TreeNode>> all){
   if(n.left==null && n.right==null){
      ArrayList<TreeNode> t = new ArrayList<TreeNode>();




                                                                              363 | 531

                                        Page 357 of 496
-----------------------Page 68 End-----------------------

152 Sum Root to Leaf Numbers


        t.addAll(l);
        all.add(t);
    }

    if(n.left!=null){
       l.add(n.left);
       dfs(n.left, l, all);
       l.remove(l.size()-1);
    }

    if(n.right!=null){
       l.add(n.right);
       dfs(n.right, l, all);
       l.remove(l.size()-1);
    }

}


    Same approach, but simpler coding style.
public int sumNumbers(TreeNode root) {
   if(root == null)
      return 0;

    return dfs(root, 0, 0);
}

public int dfs(TreeNode node, int num, int sum){
   if(node == null) return sum;

    num = num*10 + node.val;

    // leaf
    if(node.left == null && node.right == null) {
       sum += num;
       return sum;
    }

    // left subtree + right subtree
    sum = dfs(node.left, num, sum) + dfs(node.right, num, sum);
    return sum;
}




364 | 531                           Program Creek


                                Page 358 of 496
-----------------------Page 69 End-----------------------

153 Count Complete Tree Nodes

Given a complete binary tree, count the number of nodes.


153.1 Analysis

Steps to solve this problem: 1) get the height of left-most part 2) get the height of
right-most part 3) when they are equal, the # of nodes = 2hˆ -1 4) when they are not
equal, recursively get # of nodes from left&right sub-trees




  Time complexity is O(hˆ2).


153.2 Java Solution

public int countNodes(TreeNode root) {
   if(root==null)
      return 0;

   int left = getLeftHeight(root)+1;
   int right = getRightHeight(root)+1;




                                                                           365 | 531

                                      Page 359 of 496
-----------------------Page 70 End-----------------------

153 Count Complete Tree Nodes


    if(left==right){
       return (2<<(left-1))-1;
    }else{
       return countNodes(root.left)+countNodes(root.right)+1;
    }
}

public int getLeftHeight(TreeNode n){
   if(n==null) return 0;

    int height=0;
    while(n.left!=null){
       height++;
       n = n.left;
    }
    return height;
}

public int getRightHeight(TreeNode n){
   if(n==null) return 0;

    int height=0;
    while(n.right!=null){
       height++;
       n = n.right;
    }
    return height;
}




366 | 531                         Program Creek


                              Page 360 of 496
-----------------------Page 71 End-----------------------

154 Closest Binary Search Tree Value

Given a non-empty binary search tree and a target value, find the value in the BST
that is closest to the target.


154.1 Java Solution

Recursively traverse down the root. When target is less than root, go left; when target
is greater than root, go right.
public class Solution {
   int goal;
   double min = Double.MAX_VALUE;

    public int closestValue(TreeNode root, double target) {
       helper(root, target);
       return goal;
    }

    public void helper(TreeNode root, double target){
       if(root==null)
          return;

        if(Math.abs(root.val - target) < min){
           min = Math.abs(root.val-target);
           goal = root.val;
        }

        if(target < root.val){
           helper(root.left, target);
        }else{
           helper(root.right, target);
        }
    }
}




                                                                             367 | 531

                                       Page 361 of 496
-----------------------Page 72 End-----------------------

155 Binary Tree Paths

Given a binary tree, return all root-to-leaf paths.


155.1 Java Solution

A typical depth-first search problem.
public List<String> binaryTreePaths(TreeNode root) {
   ArrayList<String> finalResult = new ArrayList<String>();

    if(root==null)
       return finalResult;

    ArrayList<String> curr = new ArrayList<String>();
    ArrayList<ArrayList<String>> results = new ArrayList<ArrayList<String>>();

    dfs(root, results, curr);

    for(ArrayList<String> al : results){
       StringBuilder sb = new StringBuilder();
       sb.append(al.get(0));
       for(int i=1; i<al.size();i++){
          sb.append("->"+al.get(i));
       }

        finalResult.add(sb.toString());
    }

    return finalResult;
}

public void dfs(TreeNode root, ArrayList<ArrayList<String>> list,
    ArrayList<String> curr){
   curr.add(String.valueOf(root.val));

    if(root.left==null && root.right==null){
       list.add(curr);
       return;
    }

    if(root.left!=null){
       ArrayList<String> temp = new ArrayList<String>(curr);
       dfs(root.left, list, temp);




                                                                       369 | 531

                                         Page 362 of 496
-----------------------Page 73 End-----------------------

155 Binary Tree Paths


    }

    if(root.right!=null){
       ArrayList<String> temp = new ArrayList<String>(curr);
       dfs(root.right, list, temp);
    }
}




370 | 531                         Program Creek


                              Page 363 of 496
-----------------------Page 74 End-----------------------

156 Merge K Sorted Arrays in Java

This is a classic interview question. Another similar problem is "merge k sorted lists".
  This problem can be solved by using a heap. The time is O(nlog(n)).
  Given m arrays, the minimum elements of all arrays can form a heap. It takes
O(log(m)) to insert an element to the heap and it takes O(1) to delete the minimum
element.
class ArrayContainer implements Comparable<ArrayContainer> {
  int[] arr;
  int index;

    public ArrayContainer(int[] arr, int index) {
      this.arr = arr;
      this.index = index;
    }

    @Override
    public int compareTo(ArrayContainer o) {
      return this.arr[this.index] - o.arr[o.index];
    }
}


public class KSortedArray {
  public static int[] mergeKSortedArray(int[][] arr) {
    //PriorityQueue is heap in Java
    PriorityQueue<ArrayContainer> queue = new PriorityQueue<ArrayContainer>();
    int total=0;

      //add arrays to   heap
      for (int i = 0;   i < arr.length; i++) {
        queue.add(new   ArrayContainer(arr[i], 0));
        total = total   + arr[i].length;
      }

      int m=0;
      int result[] = new int[total];

      //while heap is not empty
      while(!queue.isEmpty()){
        ArrayContainer ac = queue.poll();
        result[m++]=ac.arr[ac.index];




                                                                              371 | 531

                                        Page 364 of 496
-----------------------Page 75 End-----------------------

156 Merge K Sorted Arrays in Java


            if(ac.index < ac.arr.length-1){
              queue.add(new ArrayContainer(ac.arr, ac.index+1));
            }
        }

        return result;
    }

    public static void main(String[] args) {
      int[] arr1 = { 1, 3, 5, 7 };
      int[] arr2 = { 2, 4, 6, 8 };
      int[] arr3 = { 0, 9, 10, 11 };

        int[] result = mergeKSortedArray(new int[][] { arr1, arr2, arr3 });
        System.out.println(Arrays.toString(result));
    }
}




372 | 531                             Program Creek


                                  Page 365 of 496
-----------------------Page 76 End-----------------------

157 Merge k Sorted Lists

Merge k sorted linked lists and return it as one sorted list. Analyze and describe its
complexity.


157.1 Analysis

The simplest solution is using PriorityQueue. The elements of the priority queue
are ordered according to their natural ordering, or by a comparator provided at the
construction time (in this case).


157.2 Java Solution

import java.util.ArrayList;
import java.util.Comparator;
import java.util.PriorityQueue;

// Definition for singly-linked list.
class ListNode {
  int val;
  ListNode next;

    ListNode(int x) {
      val = x;
      next = null;
    }
}

public class Solution {
  public ListNode mergeKLists(ArrayList<ListNode> lists) {
    if (lists.size() == 0)
       return null;

      //PriorityQueue is a sorted queue
      PriorityQueue<ListNode> q = new PriorityQueue<ListNode>(lists.size(),
          new Comparator<ListNode>() {
             public int compare(ListNode a, ListNode b) {
               if (a.val > b.val)
                 return 1;
               else if(a.val == b.val)
                 return 0;




                                                                            373 | 531

                                       Page 366 of 496
-----------------------Page 77 End-----------------------

157 Merge k Sorted Lists


                    else
                      return -1;
                }
              });

        //add first node of each list to the queue
        for (ListNode list : lists) {
          if (list != null)
            q.add(list);
        }

        ListNode head = new ListNode(0);
        ListNode p = head; // serve as a pointer/cursor

        while (q.size() > 0) {
          ListNode temp = q.poll();
          //poll() retrieves and removes the head of the queue - q.
          p.next = temp;

            //keep adding next element of each list
            if (temp.next != null)
              q.add(temp.next);

            p = p.next;
        }

        return head.next;
    }
}


    Time: log(k) * n. k is number of list and n is number of total elements.




374 | 531                              Program Creek


                                   Page 367 of 496
-----------------------Page 78 End-----------------------

158 Find Median from Data Stream

Median is the middle value in an ordered integer list. If the size of the list is even,
there is no middle value. So the median is the mean of the two middle value.


158.1 Analysis

First of all, it seems that the best time complexity we can get for this problem is
O(log(n)) of add() and O(1) of getMedian(). This data structure seems highly likely to
be a tree.
   We can use heap to solve this problem. In Java, the PriorityQueue class is a priority
heap. We can use two heaps to store the lower half and the higher half of the data
stream. The size of the two heaps differs at most 1.




158.2 Java Solution

class MedianFinder {
   PriorityQueue<Integer> maxHeap;//lower half
   PriorityQueue<Integer> minHeap;//higher half

   public MedianFinder(){
      maxHeap = new PriorityQueue<Integer>(Collections.reverseOrder());
      minHeap = new PriorityQueue<Integer>();
   }




                                                                              375 | 531

                                        Page 368 of 496
-----------------------Page 79 End-----------------------

158 Find Median from Data Stream




    // Adds a number into the data structure.
    public void addNum(int num) {
       maxHeap.offer(num);
       minHeap.offer(maxHeap.poll());

        if(maxHeap.size() < minHeap.size()){
           maxHeap.offer(minHeap.poll());
        }
    }

    // Returns the median of current data stream
    public double findMedian() {
       if(maxHeap.size()==minHeap.size()){
          return (double)(maxHeap.peek()+(minHeap.peek()))/2;
       }else{
          return maxHeap.peek();
       }
    }
}




376 | 531                          Program Creek


                               Page 369 of 496
-----------------------Page 80 End-----------------------

159 Implement Trie (Prefix Tree)

Implement a trie with insert, search, and startsWith methods.


159.1 Java Solution 1

A trie node should contains the character, its children and the flag that marks if it is a
leaf node. You can use this diagram to walk though the Java solution.




class TrieNode {
   char c;
   HashMap<Character, TrieNode> children = new HashMap<Character, TrieNode>();
   boolean isLeaf;

    public TrieNode() {}

    public TrieNode(char c){
       this.c = c;
    }
}


public class Trie {
   private TrieNode root;

    public Trie() {
       root = new TrieNode();
    }




                                                                                377 | 531

                                        Page 370 of 496
-----------------------Page 81 End-----------------------

159 Implement Trie (Prefix Tree)




   // Inserts a word into the trie.
   public void insert(String word) {
      HashMap<Character, TrieNode> children = root.children;

       for(int i=0; i<word.length(); i++){
          char c = word.charAt(i);

            TrieNode t;
            if(children.containsKey(c)){
                  t = children.get(c);
            }else{
               t = new TrieNode(c);
               children.put(c, t);
            }

            children = t.children;

            //set leaf node
            if(i==word.length()-1)
               t.isLeaf = true;
       }
   }

   // Returns if the word is in the trie.
   public boolean search(String word) {
      TrieNode t = searchNode(word);

       if(t != null && t.isLeaf)
          return true;
       else
          return false;
   }

   // Returns if there is any word in the trie
   // that starts with the given prefix.
   public boolean startsWith(String prefix) {
      if(searchNode(prefix) == null)
         return false;
      else
         return true;
   }

   public TrieNode searchNode(String str){
      Map<Character, TrieNode> children = root.children;
      TrieNode t = null;
      for(int i=0; i<str.length(); i++){
         char c = str.charAt(i);
         if(children.containsKey(c)){
            t = children.get(c);




378 | 531                              Program Creek


                                   Page 371 of 496
-----------------------Page 82 End-----------------------

                                                          159 Implement Trie (Prefix Tree)


               children = t.children;
            }else{
               return null;
            }
        }

        return t;
    }
}




159.2 Java Solution 2 - Improve Performance by Using an
            Array

Each trie node can only contains ’a’-’z’ characters. So we can use a small array to store
the character.
class TrieNode {
   TrieNode[] arr;
   boolean isEnd;
   // Initialize your data structure here.
   public TrieNode() {
      this.arr = new TrieNode[26];
   }

}

public class Trie {
   private TrieNode root;

    public Trie() {
       root = new TrieNode();
    }

    // Inserts a word into the trie.
    public void insert(String word) {
       TrieNode p = root;
       for(int i=0; i<word.length(); i++){
          char c = word.charAt(i);
          int index = c-’a’;
          if(p.arr[index]==null){
             TrieNode temp = new TrieNode();
             p.arr[index]=temp;
             p = temp;
          }else{
             p=p.arr[index];
          }
       }
       p.isEnd=true;




                                     Program Creek                              379 | 531

                                        Page 372 of 496
-----------------------Page 83 End-----------------------

159 Implement Trie (Prefix Tree)


    }

    // Returns if the word is in the trie.
    public boolean search(String word) {
       TrieNode p = searchNode(word);
       if(p==null){
          return false;
       }else{
          if(p.isEnd)
             return true;
       }

        return false;
    }

    // Returns if there is any word in the trie
    // that starts with the given prefix.
    public boolean startsWith(String prefix) {
       TrieNode p = searchNode(prefix);
       if(p==null){
          return false;
       }else{
          return true;
       }
    }

    public TrieNode searchNode(String s){
       TrieNode p = root;
       for(int i=0; i<s.length(); i++){
          char c= s.charAt(i);
          int index = c-’a’;
          if(p.arr[index]!=null){
             p = p.arr[index];
          }else{
             return null;
          }
       }

        if(p==root)
           return null;

        return p;
    }
}




380 | 531                              Program Creek


                                   Page 373 of 496
-----------------------Page 84 End-----------------------

160 Add and Search Word Data structure
    design

Design a data structure that supports the following two operations:
void addWord(word)
bool search(word)


   search(word) can search a literal word or a regular expression string containing only
letters a-z or .. A . means it can represent any one letter.


160.1 Java Solution 1

This problem is similar with Implement Trie. The solution 1 below uses the same
definition of a trie node. To handle the "." case for this problem, we need to search all
possible paths, instead of one path.
  TrieNode
class TrieNode{
   char c;
   HashMap<Character, TrieNode> children = new HashMap<Character, TrieNode>();
   boolean isLeaf;

    public TrieNode() {}

    public TrieNode(char c){
       this.c = c;
    }
}


    WordDictionary
public class WordDictionary {
   private TrieNode root;

    public WordDictionary(){
       root = new TrieNode();
    }

    // Adds a word into the data structure.
    public void addWord(String word) {
       HashMap<Character, TrieNode> children = root.children;




                                                                               381 | 531

                                        Page 374 of 496
-----------------------Page 85 End-----------------------

160 Add and Search Word Data structure design




       for(int i=0; i<word.length(); i++){
          char c = word.charAt(i);

            TrieNode t = null;
            if(children.containsKey(c)){
               t = children.get(c);
            }else{
               t = new TrieNode(c);
               children.put(c,t);
            }

            children = t.children;

            if(i == word.length()-1){
               t.isLeaf = true;
            }
       }
   }

   // Returns if the word is in the data structure. A word could
   // contain the dot character ’.’ to represent any one letter.
   public boolean search(String word) {
     return dfsSearch(root.children, word, 0);

   }

   public boolean dfsSearch(HashMap<Character, TrieNode> children, String
       word, int start) {
     if(start == word.length()){
        if(children.size()==0)
           return true;
        else
           return false;
     }

       char c = word.charAt(start);

       if(children.containsKey(c)){
          if(start == word.length()-1 && children.get(c).isLeaf){
             return true;
          }

          return dfsSearch(children.get(c).children, word, start+1);
       }else if(c == ’.’){
          boolean result = false;
          for(Map.Entry<Character, TrieNode> child: children.entrySet()){
             if(start == word.length()-1 && child.getValue().isLeaf){
                return true;
             }




382 | 531                            Program Creek


                                Page 375 of 496
-----------------------Page 86 End-----------------------

                                     160 Add and Search Word Data structure design




              //if any path is true, set result to be true;
              if(dfsSearch(child.getValue().children, word, start+1)){
                 result = true;
              }
          }

           return result;
        }else{
           return false;
        }
    }
}




160.2 Java Solution 2 - Using Array Instead of HashMap

class TrieNode{
   TrieNode[] arr;
   boolean isLeaf;

    public TrieNode(){
       arr = new TrieNode[26];
    }
}

public class WordDictionary {
   TrieNode root;

    public WordDictionary(){
       root = new TrieNode();
    }
    // Adds a word into the data structure.
    public void addWord(String word) {
       TrieNode p= root;
       for(int i=0; i<word.length(); i++){
          char c=word.charAt(i);
          int index = c-’a’;
          if(p.arr[index]==null){
             TrieNode temp = new TrieNode();
             p.arr[index]=temp;
             p=temp;
          }else{
             p=p.arr[index];
          }
       }

        p.isLeaf=true;




                                  Program Creek                          383 | 531

                                     Page 376 of 496
-----------------------Page 87 End-----------------------

160 Add and Search Word Data structure design


    }

    // Returns if the word is in the data structure. A word could
    // contain the dot character ’.’ to represent any one letter.
    public boolean search(String word) {
       return dfsSearch(root, word, 0);
    }

    public boolean dfsSearch(TrieNode p, String word, int start) {
      if (p.isLeaf && start == word.length())
        return true;

        if (start >= word.length())
          return false;

        char c = word.charAt(start);

        if (c == ’.’) {
          boolean tResult = false;
          for (int j = 0; j < 26; j++) {
            if (p.arr[j] != null) {
               if (dfsSearch(p.arr[j], word, start + 1)) {
                 tResult = true;
                 break;
               }
            }
          }

          if (tResult)
            return true;
        } else {
          int index = c - ’a’;

            if (p.arr[index] != null) {
              return dfsSearch(p.arr[index], word, start + 1);
            } else {
              return false;
            }
        }

        return false;
    }
}




384 | 531                              Program Creek


                                  Page 377 of 496
-----------------------Page 88 End-----------------------

161 Range Sum Query Mutable

Given an integer array nums, find the sum of the elements between indices i and j (i
≤ j), inclusive. The update(i, val) function modifies nums by updating the element at
index i to val.


161.1 Java Solution




class TreeNode{
   int start;
   int end;
   int sum;
   TreeNode leftChild;
   TreeNode rightChild;

   public TreeNode(int left, int right, int sum){
      this.start=left;
      this.end=right;
      this.sum=sum;
   }
   public TreeNode(int left, int right){
      this.start=left;




                                                                           385 | 531

                                      Page 378 of 496
-----------------------Page 89 End-----------------------

161 Range Sum Query Mutable


        this.end=right;
        this.sum=0;
    }
}

public class NumArray {
   TreeNode root = null;

    public NumArray(int[] nums) {
       if(nums==null || nums.length==0)
          return;

        this.root = buildTree(nums, 0, nums.length-1);
    }

    void update(int i, int val) {
       updateHelper(root, i, val);
    }

    void updateHelper(TreeNode root, int i, int val){
       if(root==null)
          return;




        int mid = root.start + (root.end-root.start)/2;
        if(i<=mid){
           updateHelper(root.leftChild, i, val);
        }else{
           updateHelper(root.rightChild, i, val);
        }

        if(root.start==root.end&& root.start==i){
           root.sum=val;
           return;
        }

        root.sum=root.leftChild.sum+root.rightChild.sum;
    }

    public int sumRange(int i, int j) {
       return sumRangeHelper(root, i, j);
    }

    public int sumRangeHelper(TreeNode root, int i, int j){
       if(root==null || j<root.start || i > root.end ||i>j )
          return 0;

        if(i<=root.start && j>=root.end){
           return root.sum;




386 | 531                          Program Creek


                               Page 379 of 496
-----------------------Page 90 End-----------------------

                                                       161 Range Sum Query Mutable


        }
        int mid = root.start + (root.end-root.start)/2;
        int result = sumRangeHelper(root.leftChild, i, Math.min(mid, j))
                 +sumRangeHelper(root.rightChild, Math.max(mid+1, i), j);

        return result;
    }

    public TreeNode buildTree(int[] nums, int i, int j){
       if(nums==null || nums.length==0|| i>j)
          return null;

        if(i==j){
           return new TreeNode(i, j, nums[i]);
        }

        TreeNode current = new TreeNode(i, j);

        int mid = i + (j-i)/2;

        current.leftChild = buildTree(nums, i, mid);
        current.rightChild = buildTree(nums, mid+1, j);

        current.sum = current.leftChild.sum+current.rightChild.sum;

        return current;
    }
}




                                  Program Creek                          387 | 531

                                     Page 380 of 496
-----------------------Page 91 End-----------------------

162 The Skyline Problem

162.1 Analysis

This problem is essentially a problem of processing 2*n edges. Each edge has a x-axis
value and a height value. The key part is how to use the height heap to process each
edge.


162.2 Java Solution

class Edge {
  int x;
  int height;
  boolean isStart;

    public Edge(int x, int height, boolean isStart) {
      this.x = x;
      this.height = height;
      this.isStart = isStart;
    }
}


public List<int[]> getSkyline(int[][] buildings) {
  List<int[]> result = new ArrayList<int[]>();

    if (buildings == null || buildings.length == 0
        || buildings[0].length == 0) {
      return result;
    }

    List<Edge> edges = new ArrayList<Edge>();

    // add all left/right edges
    for (int[] building : buildings) {
      Edge startEdge = new Edge(building[0], building[2], true);
      edges.add(startEdge);
      Edge endEdge = new Edge(building[1], building[2], false);
      edges.add(endEdge);
    }

    // sort edges




                                                                           389 | 531

                                      Page 381 of 496
-----------------------Page 92 End-----------------------

162 The Skyline Problem


    Collections.sort(edges, new Comparator<Edge>() {
      public int compare(Edge a, Edge b) {
        if (a.x != b.x)
           return Integer.compare(a.x, b.x);

            if (a.isStart && b.isStart) {
              return Integer.compare(b.height, a.height);
            }

            if (!a.isStart && !b.isStart) {
              return Integer.compare(a.height, b.height);
            }

            return a.isStart ? -1 : 1;
      }
    });

    // process edges
    PriorityQueue<Integer> heightHeap = new PriorityQueue<Integer>(10,
        Collections.reverseOrder());

    for (Edge edge : edges) {
      if (edge.isStart) {
        if (heightHeap.isEmpty() || edge.height > heightHeap.peek()) {
           result.add(new int[] { edge.x, edge.height });
        }
        heightHeap.add(edge.height);
      } else {
        heightHeap.remove(edge.height);

            if(heightHeap.isEmpty()){
              result.add(new int[] {edge.x, 0});
            }else if(edge.height > heightHeap.peek()){
              result.add(new int[]{edge.x, heightHeap.peek()});
            }
        }
    }

    return result;
}




390 | 531                                Program Creek


                                  Page 382 of 496
-----------------------Page 93 End-----------------------

163 Clone Graph Java

LeetCode Problem:
     Clone an undirected graph. Each node in the graph contains a label and a list of its
    neighbors.




163.1 Key to Solve This Problem

   • A queue is used to do breath first traversal.
   • a map is used to store the visited nodes. It is the map between original node and
     copied node.

  It would be helpful if you draw a diagram and visualize the problem.



                                                                               391 | 531

                                        Page 383 of 496
-----------------------Page 94 End-----------------------

163 Clone Graph Java




/**
 * Definition for undirected graph.
 * class UndirectedGraphNode {
 *     int label;
 *     ArrayList<UndirectedGraphNode> neighbors;
 *     UndirectedGraphNode(int x) { label = x; neighbors = new
      ArrayList<UndirectedGraphNode>(); }
 * };
 */
public class Solution {
    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
        if(node == null)
           return null;

      LinkedList<UndirectedGraphNode> queue = new
          LinkedList<UndirectedGraphNode>();
      HashMap<UndirectedGraphNode, UndirectedGraphNode> map =
                          new
                              HashMap<UndirectedGraphNode,UndirectedGraphNode>();

      UndirectedGraphNode newHead = new UndirectedGraphNode(node.label);

      queue.add(node);
      map.put(node, newHead);




392 | 531                           Program Creek


                                Page 384 of 496
-----------------------Page 95 End-----------------------

                                                             163 Clone Graph Java




        while(!queue.isEmpty()){
           UndirectedGraphNode curr = queue.pop();
           ArrayList<UndirectedGraphNode> currNeighbors = curr.neighbors;

          for(UndirectedGraphNode aNeighbor: currNeighbors){
             if(!map.containsKey(aNeighbor)){
                UndirectedGraphNode copy = new
                    UndirectedGraphNode(aNeighbor.label);
                map.put(aNeighbor,copy);
                map.get(curr).neighbors.add(copy);
                queue.add(aNeighbor);
             }else{
                map.get(curr).neighbors.add(map.get(aNeighbor));
             }
          }

        }
        return newHead;
    }
}




                                  Program Creek                         393 | 531

                                     Page 385 of 496
-----------------------Page 96 End-----------------------

164 Course Schedule

There are a total of n courses you have to take, labeled from 0 to n - 1. Some courses
may have prerequisites, for example to take course 0 you have to first take course 1,
which is expressed as a pair: [0,1]. Given the total number of courses and a list of
prerequisite pairs, is it possible for you to finish all courses?
  For example, given 2 and [[1,0]], there are a total of 2 courses to take. To take course
1 you should have finished course 0. So it is possible.
  For another example, given 2 and [[1,0],[0,1]], there are a total of 2 courses to take.
To take course 1 you should have finished course 0, and to take course 0 you should
also have finished course 1. So it is impossible.


164.1 Analysis

This problem can be converted to finding if a graph contains a cycle.


164.2 Java Solution 1 - BFS

This solution uses breath-first search and it is easy to understand.
public boolean canFinish(int numCourses, int[][] prerequisites) {
   if(prerequisites == null){
      throw new IllegalArgumentException("illegal prerequisites array");
   }

   int len = prerequisites.length;

   if(numCourses == 0 || len == 0){
      return true;
   }

   // counter for number of prerequisites
   int[] pCounter = new int[numCourses];
   for(int i=0; i<len; i++){
      pCounter[prerequisites[i][0]]++;
   }

   //store courses that have no prerequisites
   LinkedList<Integer> queue = new LinkedList<Integer>();
   for(int i=0; i<numCourses; i++){
      if(pCounter[i]==0){
         queue.add(i);




                                                                                395 | 531

                                        Page 386 of 496
-----------------------Page 97 End-----------------------

164 Course Schedule


        }
    }

    // number of courses that have no prerequisites
    int numNoPre = queue.size();

    while(!queue.isEmpty()){
       int top = queue.remove();
       for(int i=0; i<len; i++){
          // if a course’s prerequisite can be satisfied by a course in queue
          if(prerequisites[i][1]==top){
             pCounter[prerequisites[i][0]]--;
             if(pCounter[prerequisites[i][0]]==0){
                numNoPre++;
                queue.add(prerequisites[i][0]);
             }
          }
       }
    }

    return numNoPre == numCourses;
}




164.3 Java Solution 2 - DFS

public boolean canFinish(int numCourses, int[][] prerequisites) {
   if(prerequisites == null){
      throw new IllegalArgumentException("illegal prerequisites array");
   }

    int len = prerequisites.length;

    if(numCourses == 0 || len == 0){
       return true;
    }

    //track visited courses
    int[] visit = new int[numCourses];

    // use the map to store what courses depend on a course
    HashMap<Integer,ArrayList<Integer>> map = new
        HashMap<Integer,ArrayList<Integer>>();
    for(int[] a: prerequisites){
       if(map.containsKey(a[1])){
          map.get(a[1]).add(a[0]);
       }else{
          ArrayList<Integer> l = new ArrayList<Integer>();




396 | 531                         Program Creek


                              Page 387 of 496
-----------------------Page 98 End-----------------------

                                                           164 Course Schedule


            l.add(a[0]);
            map.put(a[1], l);
        }
    }

    for(int i=0; i<numCourses; i++){
       if(!canFinishDFS(map, visit, i))
          return false;
    }

    return true;
}

private boolean canFinishDFS(HashMap<Integer,ArrayList<Integer>> map, int[]
    visit, int i){
   if(visit[i]==-1)
      return false;
   if(visit[i]==1)
      return true;

    visit[i]=-1;
    if(map.containsKey(i)){
       for(int j: map.get(i)){
          if(!canFinishDFS(map, visit, j))
             return false;
       }
    }

    visit[i]=1;

    return true;
}


    Topological Sort Video from Coursera.




                                    Program Creek                     397 | 531

                                       Page 388 of 496
-----------------------Page 99 End-----------------------

165 Course Schedule II

This is an extension of Course Schedule. This time a valid sequence of courses is
required as output.


165.1 Analysis

If we use the DFS solution of Course Schedule, a valid sequence can easily be recorded.


165.2 Java Solution

public int[] findOrder(int numCourses, int[][] prerequisites) {
   if(prerequisites == null){
      throw new IllegalArgumentException("illegal prerequisites array");
   }

   int len = prerequisites.length;

   //if there is no prerequisites, return a sequence of courses
   if(len == 0){
      int[] res = new int[numCourses];
      for(int m=0; m<numCourses; m++){
         res[m]=m;
      }
      return res;
   }

   //records the number of prerequisites each course (0,...,numCourses-1)
       requires
   int[] pCounter = new int[numCourses];
   for(int i=0; i<len; i++){
      pCounter[prerequisites[i][0]]++;
   }

   //stores courses that have no prerequisites
   LinkedList<Integer> queue = new LinkedList<Integer>();
   for(int i=0; i<numCourses; i++){
      if(pCounter[i]==0){
         queue.add(i);
      }
   }




                                                                             399 | 531

                                       Page 389 of 496
-----------------------Page 100 End-----------------------

165 Course Schedule II


    int numNoPre = queue.size();

    //initialize result
    int[] result = new int[numCourses];
    int j=0;

    while(!queue.isEmpty()){
       int c = queue.remove();
       result[j++]=c;

        for(int i=0; i<len; i++){
           if(prerequisites[i][1]==c){
              pCounter[prerequisites[i][0]]--;
              if(pCounter[prerequisites[i][0]]==0){
                 queue.add(prerequisites[i][0]);
                 numNoPre++;
              }
           }

        }
    }

    //return result
    if(numNoPre==numCourses){
       return result;
    }else{
       return new int[0];
    }
}




400 | 531                            Program Creek


                                 Page 390 of 496
-----------------------Page 101 End-----------------------

166 Reconstruct Itinerary

Given a list of airline tickets represented by pairs of departure and arrival airports
[from, to], reconstruct the itinerary in order. All of the tickets belong to a man who
departs from JFK. Thus, the itinerary must begin with JFK.


166.1 Analysis

This is an application of Hierholzer’s algorithm to find a Eulerian path.
  PriorityQueue should be used instead of TreeSet, because there are duplicate entries.


166.2 Java Solution

public class Solution{
  HashMap<String, PriorityQueue<String>> map = new HashMap<String,
      PriorityQueue<String>>();
  LinkedList<String> result = new LinkedList<String>();

    public List<String> findItinerary(String[][] tickets) {
      for (String[] ticket : tickets) {
        if (!map.containsKey(ticket[0])) {
           PriorityQueue<String> q = new PriorityQueue<String>();
           map.put(ticket[0], q);
        }
        map.get(ticket[0]).offer(ticket[1]);
      }

        dfs("JFK");
        return result;
    }

    public void dfs(String s) {
      PriorityQueue<String> q = map.get(s);

        while (q != null && !q.isEmpty()) {
          dfs(q.poll());
        }

        result.addFirst(s);
    }
}




                                                                             401 | 531

                                       Page 391 of 496
-----------------------Page 102 End-----------------------

167 How Developers Sort in Java?

While analyzing source code of a large number of open source Java projects, I found
Java developers frequently sort in two ways. One is using the sort() method of Col-
lections or Arrays, and the other is using sorted data structures, such as TreeMap and
TreeSet.


167.1 Using sort() Method

If it is a collection, use Collections.sort() method.
// Collections.sort
List<ObjectName> list = new ArrayList<ObjectName>();
Collections.sort(list, new Comparator<ObjectName>() {
  public int compare(ObjectName o1, ObjectName o2) {
    return o1.toString().compareTo(o2.toString());
  }
});


  If it is an array, use Arrays.sort() method.
// Arrays.sort
ObjectName[] arr = new ObjectName[10];
Arrays.sort(arr, new Comparator<ObjectName>() {
  public int compare(ObjectName o1, ObjectName o2) {
    return o1.toString().compareTo(o2.toString());
  }
});


  This is very convenient if a collection or an array is already set up.


167.2 Using Sorted Data Structures

If it is a list or set, use TreeSet to sort.
// TreeSet
Set<ObjectName> sortedSet = new TreeSet<ObjectName>(new
    Comparator<ObjectName>() {
  public int compare(ObjectName o1, ObjectName o2) {
     return o1.toString().compareTo(o2.toString());
  }
});
sortedSet.addAll(unsortedSet);




                                                                            403 | 531

                                               Page 392 of 496
-----------------------Page 103 End-----------------------

167 How Developers Sort in Java?




  If it is a map, use TreeMap to sort. TreeMap is sorted by key.
// TreeMap - using String.CASE_INSENSITIVE_ORDER which is a Comparator that
    orders Strings by compareToIgnoreCase
Map<String, Integer> sortedMap = new TreeMap<String,
    Integer>(String.CASE_INSENSITIVE_ORDER);
sortedMap.putAll(unsortedMap);


//TreeMap - In general, defined comparator
Map<ObjectName, String> sortedMap = new TreeMap<ObjectName, String>(new
    Comparator<ObjectName>() {
  public int compare(ObjectName o1, ObjectName o2) {
     return o1.toString().compareTo(o2.toString());
  }
});
sortedMap.putAll(unsortedMap);


  This approach is very useful, if you would do a lot of search operations for the
collection. The sorted data structure will give time complexity of O(logn), which is
lower than O(n).


167.3 Bad Practices

There are still bad practices, such as using self-defined sorting algorithm. Take the
code below for example, not only the algorithm is not efficient, but also it is not
readable. This happens a lot in different forms of variations.
double t;
for (int i = 0; i < 2; i++)
  for (int j = i + 1; j < 3; j++)
    if (r[j] < r[i]) {
       t = r[i];
       r[i] = r[j];
       r[j] = t;
    }




404 | 531                           Program Creek


                                Page 393 of 496
-----------------------Page 104 End-----------------------

168 Solution Merge Sort LinkedList in
    Java

LeetCode - Sort List:
     Sort a linked list in O(n log n) time using constant space complexity.


168.1 Keys for solving the problem

    • Break the list to two in the middle
    • Recursively sort the two sub lists
    • Merge the two sub lists

    This is my accepted answer for the problem.
package algorithm.sort;

class ListNode {
  int val;
  ListNode next;

    ListNode(int x) {
      val = x;
      next = null;
    }
}

public class SortLinkedList {

    // merge sort
    public static ListNode mergeSortList(ListNode head) {

      if (head == null || head.next == null)
        return head;

      // count total number of elements
      int count = 0;
      ListNode p = head;
      while (p != null) {
        count++;
        p = p.next;
      }




                                                                              405 | 531

                                           Page 394 of 496
-----------------------Page 105 End-----------------------

168 Solution Merge Sort LinkedList in Java


      // break up to two list
      int middle = count / 2;

      ListNode l = head, r = null;
      ListNode p2 = head;
      int countHalf = 0;
      while (p2 != null) {
        countHalf++;
        ListNode next = p2.next;

          if (countHalf == middle) {
            p2.next = null;
            r = next;
          }
          p2 = next;
      }

      // now we have two parts l and r, recursively sort them
      ListNode h1 = mergeSortList(l);
      ListNode h2 = mergeSortList(r);

      // merge together
      ListNode merged = merge(h1, h2);

      return merged;
  }

  public static ListNode merge(ListNode l, ListNode r) {
    ListNode p1 = l;
    ListNode p2 = r;

      ListNode fakeHead = new ListNode(100);
      ListNode pNew = fakeHead;

      while (p1 != null || p2 != null) {

          if (p1 == null) {
            pNew.next = new ListNode(p2.val);
            p2 = p2.next;
            pNew = pNew.next;
          } else if (p2 == null) {
            pNew.next = new ListNode(p1.val);
            p1 = p1.next;
            pNew = pNew.next;
          } else {
            if (p1.val < p2.val) {
              // if(fakeHead)
              pNew.next = new ListNode(p1.val);
              p1 = p1.next;
              pNew = pNew.next;




406 | 531                              Program Creek


                                Page 395 of 496
-----------------------Page 106 End-----------------------

                                            168 Solution Merge Sort LinkedList in Java


            } else if (p1.val == p2.val) {
              pNew.next = new ListNode(p1.val);
              pNew.next.next = new ListNode(p1.val);
              pNew = pNew.next.next;
              p1 = p1.next;
              p2 = p2.next;

            } else {
              pNew.next = new ListNode(p2.val);
              p2 = p2.next;
              pNew = pNew.next;
            }
        }
    }

    // printList(fakeHead.next);
    return fakeHead.next;
}

public static       void main(String[] args) {
  ListNode n1       = new ListNode(2);
  ListNode n2       = new ListNode(3);
  ListNode n3       = new ListNode(4);

    ListNode n4 = new ListNode(3);
    ListNode n5 = new ListNode(4);
    ListNode n6 = new ListNode(5);

    n1.next    =   n2;
    n2.next    =   n3;
    n3.next    =   n4;
    n4.next    =   n5;
    n5.next    =   n6;

    n1 = mergeSortList(n1);

    printList(n1);
}

public static void printList(ListNode x) {
  if(x != null){
    System.out.print(x.val + " ");
    while (x.next != null) {
       System.out.print(x.next.val + " ");
       x = x.next;
    }
    System.out.println();
  }

}




                                    Program Creek                           407 | 531

                                       Page 396 of 496
-----------------------Page 107 End-----------------------

168 Solution Merge Sort LinkedList in Java


}


    Output:
    233445




408 | 531                           Program Creek


                                Page 397 of 496
-----------------------Page 108 End-----------------------

169 Quicksort Array in Java

Quicksort is a divide and conquer algorithm. It first divides a large list into two
smaller sub-lists and then recursively sort the two sub-lists. If we want to sort an array
without any extra space, quicksort is a good option. On average, time complexity is
O(n log(n)).
  The basic step of sorting an array are as follows:
   • Select a pivot, normally the middle one
   • From both ends, swap elements and make all elements on the left less than the
     pivot and all elements on the right greater than the pivot
   • Recursively sort left part and right part
  Here is a very good animation of quicksort.
public class QuickSort {
  public static void main(String[] args) {
    int[] x = { 9, 2, 4, 7, 3, 7, 10 };
    System.out.println(Arrays.toString(x));

      int low = 0;
      int high = x.length - 1;

      quickSort(x, low, high);
      System.out.println(Arrays.toString(x));
  }

  public static void quickSort(int[] arr, int low, int high) {
    if (arr == null || arr.length == 0)
      return;

      if (low >= high)
        return;

      // pick the pivot
      int middle = low + (high - low) / 2;
      int pivot = arr[middle];

      // make left < pivot and right > pivot
      int i = low, j = high;
      while (i <= j) {
        while (arr[i] < pivot) {
          i++;
        }




                                                                                409 | 531

                                        Page 398 of 496
-----------------------Page 109 End-----------------------

169 Quicksort Array in Java




            while (arr[j] > pivot) {
              j--;
            }

            if (i <= j) {
              int temp = arr[i];
              arr[i] = arr[j];
              arr[j] = temp;
              i++;
              j--;
            }
        }

        // recursively sort two sub parts
        if (low < j)
          quickSort(arr, low, j);

        if (high > i)
          quickSort(arr, i, high);
    }
}


    Output:
    9 2 4 7 3 7 10 2 3 4 7 7 9 10




410 | 531                               Program Creek


                                    Page 399 of 496
-----------------------Page 110 End-----------------------

170 Solution Sort a linked list using
    insertion sort in Java

Insertion Sort List:
      Sort a linked list using insertion sort.
  This is my accepted answer for LeetCode problem - Sort a linked list using insertion
sort in Java. It is a complete program.
  Before coding for that, here is an example of insertion sort from wiki. You can get
an idea of what is insertion sort.




    Code:
package algorithm.sort;

class ListNode {
  int val;
  ListNode next;

    ListNode(int x) {
      val = x;
      next = null;
    }
}

public class SortLinkedList {
  public static ListNode insertionSortList(ListNode head) {




                                                                            411 | 531

                                       Page 400 of 496
-----------------------Page 111 End-----------------------

170 Solution Sort a linked list using insertion sort in Java


      if (head == null || head.next == null)
        return head;

      ListNode newHead = new ListNode(head.val);
      ListNode pointer = head.next;

      // loop through each element in the list
      while (pointer != null) {
        // insert this element to the new list

          ListNode innerPointer = newHead;
          ListNode next = pointer.next;

          if (pointer.val <= newHead.val) {
            ListNode oldHead = newHead;
            newHead = pointer;
            newHead.next = oldHead;
          } else {
            while (innerPointer.next != null) {

                  if (pointer.val > innerPointer.val && pointer.val <=
                      innerPointer.next.val) {
                    ListNode oldNext = innerPointer.next;
                    innerPointer.next = pointer;
                    pointer.next = oldNext;
                  }

                  innerPointer = innerPointer.next;
              }

              if (innerPointer.next == null && pointer.val > innerPointer.val) {
                innerPointer.next = pointer;
                pointer.next = null;
              }
          }

          // finally
          pointer = next;
      }

      return newHead;
  }

  public static        void main(String[] args) {
    ListNode n1        = new ListNode(2);
    ListNode n2        = new ListNode(3);
    ListNode n3        = new ListNode(4);

      ListNode n4 = new ListNode(3);
      ListNode n5 = new ListNode(4);




412 | 531                              Program Creek


                                   Page 401 of 496
-----------------------Page 112 End-----------------------

                               170 Solution Sort a linked list using insertion sort in Java


        ListNode n6 = new ListNode(5);

        n1.next   =   n2;
        n2.next   =   n3;
        n3.next   =   n4;
        n4.next   =   n5;
        n5.next   =   n6;

        n1 = insertionSortList(n1);

        printList(n1);

    }

    public static void printList(ListNode x) {
      if(x != null){
        System.out.print(x.val + " ");
        while (x.next != null) {
           System.out.print(x.next.val + " ");
           x = x.next;
        }
        System.out.println();
      }

    }
}


    Output:
    233445




                                      Program Creek                             413 | 531

                                         Page 402 of 496
-----------------------Page 113 End-----------------------

171 Maximum Gap

Given an unsorted array, find the maximum difference between the successive ele-
ments in its sorted form.
  Try to solve it in linear time/space. Return 0 if the array contains less than 2 ele-
ments. You may assume all elements in the array are non-negative integers and fit in
the 32-bit signed integer range.


171.1 Analysis

We can use a bucket-sort like algorithm to solve this problem in time of O(n) and space
O(n). The basic idea is to project each element of the array to an array of buckets. Each
bucket tracks the maximum and minimum elements. Finally, scanning the bucket list,
we can get the maximum gap.
  The key part is to get the interval:
From: interval * (num[i] - min) = 0 and interval * (max -num[i]) = n
interval = num.length / (max - min)


  See the internal comment for more details.


171.2 Java Solution

class Bucket{
   int low;
   int high;
   public Bucket(){
      low = -1;
      high = -1;
   }
}

public int maximumGap(int[] num) {
   if(num == null || num.length < 2){
      return 0;
   }

   int max = num[0];
   int min = num[0];
   for(int i=1; i<num.length; i++){
      max = Math.max(max, num[i]);




                                                                               415 | 531

                                        Page 403 of 496
-----------------------Page 114 End-----------------------

171 Maximum Gap


        min = Math.min(min, num[i]);
    }

    // initialize an array of buckets
    Bucket[] buckets = new Bucket[num.length+1]; //project to (0 - n)
    for(int i=0; i<buckets.length; i++){
       buckets[i] = new Bucket();
    }

    double interval = (double) num.length / (max - min);
    //distribute every number to a bucket array
    for(int i=0; i<num.length; i++){
       int index = (int) ((num[i] - min) * interval);

        if(buckets[index].low == -1){
           buckets[index].low = num[i];
           buckets[index].high = num[i];
        }else{
           buckets[index].low = Math.min(buckets[index].low, num[i]);
           buckets[index].high = Math.max(buckets[index].high, num[i]);
        }
    }

    //scan buckets to find maximum gap
    int result = 0;
    int prev = buckets[0].high;
    for(int i=1; i<buckets.length; i++){
       if(buckets[i].low != -1){
          result = Math.max(result, buckets[i].low-prev);
          prev = buckets[i].high;
       }

    }

    return result;
}




416 | 531                          Program Creek


                               Page 404 of 496
-----------------------Page 115 End-----------------------

172 First Missing Positive

Given an unsorted integer array, find the first missing positive integer. For example,
given [1,2,0] return 3 and [3,4,-1,1] return 2.
  Your algorithm should run in O(n) time and uses constant space.


172.1 Analysis

This problem can solve by using a bucket-sort like algorithm. Let’s consider finding
first missing positive and 0 first. The key fact is that the ith element should be i, so we
have: i==A[i] A[i]==A[A[i]]
   For example, given an array 1,2,0,4, the algorithm does the following:




int firstMissingPositiveAnd0(int A[]) {
  int n = A.length;
  for (int i = 0; i < n; i++) {
    // when the ith element is not i
    while (A[i] != i) {
       // no need to swap when ith element is out of range [0,n]
       if (A[i] < 0 || A[i] >= n)
         break;

       //handle duplicate elements
       if(A[i]==A[A[i]])
                  break;
       // swap elements
       int temp = A[i];




                                                                                 417 | 531

                                         Page 405 of 496
-----------------------Page 116 End-----------------------

172 First Missing Positive


            A[i] = A[temp];
            A[temp] = temp;
        }
    }

    for (int i = 0; i < n; i++) {
      if (A[i] != i)
        return i;
    }

    return n;
}




172.2 Java Solution

This problem only considers positive numbers, so we need to shift 1 offset. The ith
element is i+1.
public int firstMissingPositive(int[] A) {
      int n = A.length;

        for (int i = 0; i < n; i++) {
          while (A[i] != i + 1) {
            if (A[i] <= 0 || A[i] >= n)
               break;

                    if(A[i]==A[A[i]-1])
                        break;

                int temp = A[i];
                A[i] = A[temp - 1];
                A[temp - 1] = temp;
            }
        }

        for (int i = 0; i < n; i++){
          if (A[i] != i + 1){
            return i + 1;
          }
        }

        return n + 1;
}




418 | 531                                 Program Creek


                                      Page 406 of 496
-----------------------Page 117 End-----------------------

173 Sort Colors

Given an array with n objects colored red, white or blue, sort them so that objects of
the same color are adjacent, with the colors in the order red, white and blue.
  Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue
respectively.


173.1 Java Solution 1 - Counting Sort

Check out this animation to understand how counting sort works.
public void sortColors(int[] nums) {
   if(nums==null||nums.length<2){
      return;
   }

    int[] countArray = new int[3];
    for(int i=0; i<nums.length; i++){
       countArray[nums[i]]++;
    }

    for(int i=1; i<=2; i++){
       countArray[i]=countArray[i-1]+countArray[i];
    }

    int[] sorted = new int[nums.length];
    for(int i=0;i<nums.length; i++){
       int index = countArray[nums[i]]-1;
       countArray[nums[i]] = countArray[nums[i]]-1;
       sorted[index]=nums[i];
    }

    System.arraycopy(sorted, 0, nums, 0, nums.length);
}




173.2 Java Solution 2 - Improved Counting Sort

In solution 1, two arrays are created. One is for counting, and the other is for storing
the sorted array (space is O(n)). We can improve the solution so that it only uses
constant space. Since we already get the count of each element, we can directly project
them to the original array, instead of creating a new one.



                                                                              419 | 531

                                        Page 407 of 496
-----------------------Page 118 End-----------------------

173 Sort Colors



public void sortColors(int[] nums) {
   if(nums==null||nums.length<2){
      return;
   }

    int[] countArray = new int[3];
    for(int i=0; i<nums.length; i++){
       countArray[nums[i]]++;
    }

    int j = 0;
    int k = 0;
    while(j<=2){
       if(countArray[j]!=0){
          nums[k++]=j;
          countArray[j] = countArray[j]-1;
       }else{
          j++;
       }
    }
}




420 | 531                         Program Creek


                              Page 408 of 496
-----------------------Page 119 End-----------------------

174 Edit Distance in Java

From Wiki:
      In computer science, edit distance is a way of quantifying how dissimilar two strings
     (e.g., words) are to one another by counting the minimum number of operations required
     to transform one string into the other.
   There are three operations permitted on a word: replace, delete, insert. For example,
the edit distance between "a" and "b" is 1, the edit distance between "abc" and "def" is
3. This post analyzes how to calculate edit distance by using dynamic programming.


174.1 Key Analysis

Let dp[i][j] stands for the edit distance between two strings with length i and j, i.e.,
word1[0,...,i-1] and word2[0,...,j-1]. There is a relation between dp[i][j] and dp[i-1][j-1].
Let’s say we transform from one string to another. The first string has length i and
it’s last character is "x"; the second string has length j and its last character is "y". The
following diagram shows the relation.




   • if x == y, then dp[i][j] == dp[i-1][j-1]
   • if x != y, and we insert y for word1, then dp[i][j] = dp[i][j-1] + 1



                                                                                  421 | 531

                                          Page 409 of 496
-----------------------Page 120 End-----------------------

174 Edit Distance in Java


    • if x != y, and we delete x for word1, then dp[i][j] = dp[i-1][j] + 1
    • if x != y, and we replace x with y for word1, then dp[i][j] = dp[i-1][j-1] + 1
    • When x!=y, dp[i][j] is the min of the three situations.

    Initial condition: dp[i][0] = i, dp[0][j] = j


174.2 Java Code

After the analysis above, the code is just a representation of it.
public static int minDistance(String word1, String word2) {
  int len1 = word1.length();
  int len2 = word2.length();

    // len1+1, len2+1, because finally return dp[len1][len2]
    int[][] dp = new int[len1 + 1][len2 + 1];

    for (int i = 0; i <= len1; i++) {
      dp[i][0] = i;
    }

    for (int j = 0; j <= len2; j++) {
      dp[0][j] = j;
    }

    //iterate though, and check last char
    for (int i = 0; i < len1; i++) {
      char c1 = word1.charAt(i);
      for (int j = 0; j < len2; j++) {
        char c2 = word2.charAt(j);

            //if last two chars equal
            if (c1 == c2) {
              //update dp value for +1 length
              dp[i + 1][j + 1] = dp[i][j];
            } else {
              int replace = dp[i][j] + 1;
              int insert = dp[i][j + 1] + 1;
              int delete = dp[i + 1][j] + 1;

                int min = replace > insert ? insert : replace;
                min = delete > min ? min : delete;
                dp[i + 1][j + 1] = min;
            }
        }
    }

    return dp[len1][len2];
}




422 | 531                                Program Creek


                                     Page 410 of 496
-----------------------Page 121 End-----------------------

175 Distinct Subsequences Total

Given a string S and a string T, count the number of distinct subsequences of T in S.
  A subsequence of a string is a new string which is formed from the original string by
deleting some (can be none) of the characters without disturbing the relative positions
of the remaining characters. (ie, "ACE" is a subsequence of "ABCDE" while "AEC" is
not).
  Here is an example: S = "rabbbit", T = "rabbit"
  Return 3.


175.1 Analysis

The problem itself is very difficult to understand. It can be stated like this: Give a
sequence S and T, how many distinct sub sequences from S equals to T? How do you
define "distinct" subsequence? Clearly, the ’distinct’ here mean different operation
combination, not the final string of subsequence. Otherwise, the result is always 0 or
1. – from Jason’s comment
   When you see string problem that is about subsequence or matching, dynamic pro-
gramming method should come to mind naturally. The key is to find the initial and
changing condition.


175.2 Java Solution 1

Let W(i, j) stand for the number of subsequences of S(0, i) equals to T(0, j). If S.charAt(i)
== T.charAt(j), W(i, j) = W(i-1, j-1) + W(i-1,j); Otherwise, W(i, j) = W(i-1,j).
public int numDistincts(String S, String T) {
  int[][] table = new int[S.length() + 1][T.length() + 1];

  for (int i = 0; i < S.length(); i++)
    table[i][0] = 1;

  for (int i = 1; i <= S.length(); i++) {
    for (int j = 1; j <= T.length(); j++) {
      if (S.charAt(i - 1) == T.charAt(j - 1)) {
         table[i][j] += table[i - 1][j] + table[i - 1][j - 1];
      } else {
         table[i][j] += table[i - 1][j];
      }
    }
  }




                                                                                  425 | 531

                                          Page 411 of 496
-----------------------Page 122 End-----------------------

175 Distinct Subsequences Total




    return table[S.length()][T.length()];
}




175.3 Java Solution 2

Do NOT write something like this, even it can also pass the online judge.
public int numDistinct(String S, String T) {
  HashMap<Character, ArrayList<Integer>> map = new HashMap<Character,
      ArrayList<Integer>>();

    for (int i = 0; i < T.length(); i++) {
      if (map.containsKey(T.charAt(i))) {
        map.get(T.charAt(i)).add(i);
      } else {
        ArrayList<Integer> temp = new ArrayList<Integer>();
        temp.add(i);
        map.put(T.charAt(i), temp);
      }
    }

    int[] result = new int[T.length() + 1];
    result[0] = 1;

    for (int i = 0; i < S.length(); i++) {
      char c = S.charAt(i);

        if (map.containsKey(c)) {
          ArrayList<Integer> temp = map.get(c);
          int[] old = new int[temp.size()];

            for (int j = 0; j < temp.size(); j++)
              old[j] = result[temp.get(j)];

            // the relation
            for (int j = 0; j < temp.size(); j++)
              result[temp.get(j) + 1] = result[temp.get(j) + 1] + old[j];
        }
    }

    return result[T.length()];
}




426 | 531                             Program Creek


                                  Page 412 of 496
-----------------------Page 123 End-----------------------

176 Longest Palindromic Substring

Finding the longest palindromic substring is a classic problem of coding interview.
This post summarizes 3 different solutions for this problem.


176.1 Naive Approach

Naively, we can simply examine every substring and check if it is palindromic. The
time complexity is O(nˆ3). If this is submitted to LeetCode onlinejudge, an error mes-
sage will be returned - "Time Limit Exceeded". Therefore, this approach is just a start,
we need a better algorithm.
public static String longestPalindrome1(String s) {

    int maxPalinLength = 0;
    String longestPalindrome = null;
    int length = s.length();

    // check all possible sub strings
    for (int i = 0; i < length; i++) {
      for (int j = i + 1; j < length; j++) {
        int len = j - i;
        String curr = s.substring(i, j + 1);
        if (isPalindrome(curr)) {
           if (len > maxPalinLength) {
             longestPalindrome = curr;
             maxPalinLength = len;
           }
        }
      }
    }

    return longestPalindrome;
}

public static boolean isPalindrome(String s) {

    for (int i = 0; i < s.length() - 1; i++) {
      if (s.charAt(i) != s.charAt(s.length() - 1 - i)) {
        return false;
      }
    }




                                                                              427 | 531

                                        Page 413 of 496
-----------------------Page 124 End-----------------------

176 Longest Palindromic Substring


    return true;
}




176.2 Dynamic Programming

Let s be the input string, i and j are two indices of the string. Define a 2-dimension
array "table" and let table[i][j] denote whether a substring from i to j is palindrome.
  Start condition:
table[i][i] == 1;
table[i][i+1] == 1 => s.charAt(i) == s.charAt(i+1)


    Changing condition:
table[i+1][j-1] == 1 && s.charAt(i) == s.charAt(j)
=>
table[i][j] == 1


    Time O(nˆ2) Space O(nˆ2)
public static String longestPalindrome2(String s) {
  if (s == null)
    return null;

    if(s.length() <=1)
      return s;

    int maxLen = 0;
    String longestStr = null;

    int length = s.length();

    int[][] table = new int[length][length];

    //every single letter is palindrome
    for (int i = 0; i < length; i++) {
      table[i][i] = 1;
    }
    printTable(table);

    //e.g. bcba
    //two consecutive same letters are palindrome
    for (int i = 0; i <= length - 2; i++) {
      if (s.charAt(i) == s.charAt(i + 1)){
        table[i][i + 1] = 1;
        longestStr = s.substring(i, i + 2);
      }
    }




428 | 531                           Program Creek


                                Page 414 of 496
-----------------------Page 125 End-----------------------

                                                         176 Longest Palindromic Substring


    printTable(table);
    //condition for calculate whole table
    for (int l = 3; l <= length; l++) {
      for (int i = 0; i <= length-l; i++) {
        int j = i + l - 1;
        if (s.charAt(i) == s.charAt(j)) {
           table[i][j] = table[i + 1][j - 1];
           if (table[i][j] == 1 && l > maxLen)
             longestStr = s.substring(i, j + 1);
        } else {
           table[i][j] = 0;
        }
        printTable(table);
      }
    }

  return longestStr;
}
public static void printTable(int[][] x){
  for(int [] y : x){
    for(int z: y){
       System.out.print(z + " ");
    }
    System.out.println();
  }
  System.out.println("------");
}


  Given a string, we can use the printTable() method to examine the table after ex-
ecution. For example, if the input string is "dabcba", the final matrix would be the
following:
1   0   0   0   0   0
0   1   0   0   0   1
0   0   1   0   1   0
0   0   0   1   0   0
0   0   0   0   1   0
0   0   0   0   0   1


    From the table, we can clearly see that the longest string is in cell table[1][5].


176.3 A Simple Algorithm

Time O(nˆ2), Space O(1)
public String longestPalindrome(String s) {
  if (s.isEmpty()) {
    return null;
  }




                                       Program Creek                               429 | 531

                                           Page 415 of 496
-----------------------Page 126 End-----------------------

176 Longest Palindromic Substring




    if (s.length() == 1) {
      return s;
    }

    String longest = s.substring(0, 1);
    for (int i = 0; i < s.length(); i++) {
      // get longest palindrome with center of i
      String tmp = helper(s, i, i);
      if (tmp.length() > longest.length()) {
        longest = tmp;
      }

        // get longest palindrome with center of i, i+1
        tmp = helper(s, i, i + 1);
        if (tmp.length() > longest.length()) {
          longest = tmp;
        }
    }

    return longest;
}

// Given a center, either one letter or two letter,
// Find longest palindrome
public String helper(String s, int begin, int end) {
  while (begin >= 0 && end <= s.length() - 1 && s.charAt(begin) ==
      s.charAt(end)) {
    begin--;
    end++;
  }
  return s.substring(begin + 1, end);
}




176.4 Manacher’s Algorithm

Manacher’s algorithm is much more complicated to figure out, even though it will
bring benefit of time complexity of O(n). Since it is not typical, there is no need to
waste time on that.




430 | 531                           Program Creek


                                Page 416 of 496
-----------------------Page 127 End-----------------------

177 Word Break

          Given a string s and a dictionary of words dict, determine if s can be segmented into
         a space-separated sequence of one or more dictionary words. For example, given s =
         "leetcode", dict = ["leet", "code"]. Return true because "leetcode" can be segmented as
         "leet code".



177.1 Naive Approach

This problem can be solve by using a naive approach, which is trivial. A discussion
can always start from that though.
public class Solution {
   public boolean wordBreak(String s, Set<String> dict) {
          return wordBreakHelper(s, dict, 0);
   }

     public boolean wordBreakHelper(String s, Set<String> dict, int start){
        if(start == s.length())
           return true;

           for(String a: dict){
              int len = a.length();
              int end = start+len;

               //end index should be <= string length
               if(end > s.length())
                  continue;

               if(s.substring(start, start+len).equals(a))
                  if(wordBreakHelper(s, dict, start+len))
                     return true;
           }

           return false;
     }
}


    Time is O(nˆ2) and exceeds the time limit.




                                                                                     431 | 531

                                             Page 417 of 496
-----------------------Page 128 End-----------------------

177 Word Break


177.2 Dynamic Programming

The key to solve this problem by using dynamic programming approach:

    • Define an array t[] such that t[i]==true =>0-(i-1) can be segmented using dictio-
      nary
    • Initial state t[0] == true

public class Solution {
   public boolean wordBreak(String s, Set<String> dict) {
      boolean[] t = new boolean[s.length()+1];
      t[0] = true; //set first to be true, why?
      //Because we need initial state

         for(int i=0; i<s.length(); i++){
            //should continue from match position
            if(!t[i])
               continue;

             for(String a: dict){
                int len = a.length();
                int end = i + len;
                if(end > s.length())
                   continue;

                 if(t[end]) continue;

                 if(s.substring(i, end).equals(a)){
                    t[end] = true;
                 }
             }
         }

         return t[s.length()];
     }
}


    Time: O(string length * dict size)
    One tricky part of this solution is the case:
INPUT: "programcreek", ["programcree","program","creek"].


    We should get all possible matches, not stop at "programcree".


177.3 Regular Expression

The problem is equivalent to matching the regular expression (leet|code)*, which
                                                    ˆ and executing it in O(n).
means that it can be solved by building a DFA in O(2m)



432 | 531                               Program Creek


                                   Page 418 of 496
-----------------------Page 129 End-----------------------

                                                                   177 Word Break


(Thanks to hdante.) Leetcode online judge does not allow using the Pattern class
though.
public static void main(String[] args) {
  HashSet<String> dict = new HashSet<String>();
  dict.add("go");
  dict.add("goal");
  dict.add("goals");
  dict.add("special");

    StringBuilder sb = new StringBuilder();

    for(String s: dict){
      sb.append(s + "|");
    }

    String pattern = sb.toString().substring(0, sb.length()-1);
    pattern = "("+pattern+")*";
    Pattern p = Pattern.compile(pattern);
    Matcher m = p.matcher("goalspecial");

    if(m.matches()){
      System.out.println("match");
    }
}




177.4 The More Interesting Problem

The dynamic solution can tell us whether the string can be broken to words, but can
not tell us what words the string is broken to. So how to get those words?
  Check out Word Break II.




                                     Program Creek                       433 | 531

                                       Page 419 of 496
-----------------------Page 130 End-----------------------

178 Word Break II

Given a string s and a dictionary of words dict, add spaces in s to construct a sentence
where each word is a valid dictionary word. Return all such possible sentences. For
example, given s = "catsanddog", dict = ["cat", "cats", "and", "sand", "dog"], the solution
is ["cats and dog", "cat sand dog"].


178.1 Java Solution - Dynamic Programming

This problem is very similar to Word Break. Instead of using a boolean array to track
the matched positions, we need to track the actual matched words. Then we can use
depth first search to get all the possible paths, i.e., the list of strings.
  The following diagram shows the structure of the tracking array.




public static List<String> wordBreak(String s, Set<String> dict) {
   //create an array of ArrayList<String>
   List<String> dp[] = new ArrayList[s.length()+1];
   dp[0] = new ArrayList<String>();

   for(int i=0; i<s.length(); i++){




                                                                                 435 | 531

                                         Page 420 of 496
-----------------------Page 131 End-----------------------

178 Word Break II


        if( dp[i] == null )
           continue;

        for(String word:dict){
           int len = word.length();
           int end = i+len;
           if(end > s.length())
              continue;

            if(s.substring(i,end).equals(word)){
               if(dp[end] == null){
                  dp[end] = new ArrayList<String>();
               }
               dp[end].add(word);
            }
        }
    }

    List<String> result = new LinkedList<String>();
    if(dp[s.length()] == null)
       return result;

    ArrayList<String> temp = new ArrayList<String>();
    dfs(dp, s.length(), result, temp);

    return result;
}

public static void dfs(List<String> dp[],int end,List<String> result,
    ArrayList<String> tmp){
   if(end <= 0){
      String path = tmp.get(tmp.size()-1);
      for(int i=tmp.size()-2; i>=0; i--){
         path += " " + tmp.get(i) ;
      }

        result.add(path);
        return;
    }

    for(String str : dp[end]){
       tmp.add(str);
       dfs(dp, end-str.length(), result, tmp);
       tmp.remove(tmp.size()-1);
    }
}


  This problem is also useful for solving real problems. Assuming you want to analyze
the domain names of the top 10k websites. We can use this solution to break the main
part of the domain into words and then get a sense of what kinds of websites are



436 | 531                           Program Creek


                                Page 421 of 496
-----------------------Page 132 End-----------------------

179 Maximum Subarray

Find the contiguous subarray within an array (containing at least one number) which
has the largest sum.
  For example, given the array [−2,1,−3,4,−1,2,1,−5,4], the contiguous subarray [4,−1,2,1]
has the largest sum = 6.


179.1 Wrong Solution

This is a wrong solution, check out the discussion below to see why it is wrong. I put
it here just for fun.
public class Solution {
  public int maxSubArray(int[] A) {
    int sum = 0;
    int maxSum = Integer.MIN_VALUE;

        for (int i = 0; i < A.length; i++) {
          sum += A[i];
          maxSum = Math.max(maxSum, sum);

            if (sum < 0)
              sum = 0;
        }

        return maxSum;
    }
}




179.2 Dynamic Programming Solution

The changing condition for dynamic programming is "We should ignore the sum of
the previous n-1 elements if nth element is greater than the sum."
public class Solution {
  public int maxSubArray(int[] A) {
    int max = A[0];
    int[] sum = new int[A.length];
    sum[0] = A[0];

        for (int i = 1; i < A.length; i++) {




                                                                            439 | 531

                                       Page 422 of 496
-----------------------Page 133 End-----------------------

179 Maximum Subarray


            sum[i] = Math.max(A[i], sum[i - 1] + A[i]);
            max = Math.max(max, sum[i]);
        }

        return max;
    }
}




179.3 Simple Solution

Mehdi provided the following solution in his comment.
public int maxSubArray(int[] A) {
     int newsum=A[0];
     int max=A[0];
     for(int i=1;i<A.length;i++){
        newsum=Math.max(newsum+A[i],A[i]);
        max= Math.max(max, newsum);
     }
     return max;
   }


    This problem is asked by Palantir.




440 | 531                             Program Creek


                                  Page 423 of 496
-----------------------Page 134 End-----------------------

180 Maximum Product Subarray

Find the contiguous subarray within an array (containing at least one number) which
has the largest product.
  For example, given the array [2,3,-2,4], the contiguous subarray [2,3] has the largest
product = 6.


180.1 Java Solution 1 - Brute-force

public int maxProduct(int[] A) {
   int max = Integer.MIN_VALUE;

     for(int i=0; i<A.length; i++){
        for(int l=0; l<A.length; l++){
           if(i+l < A.length){
              int product = calProduct(A, i, l);
              max = Math.max(product, max);
           }

        }

     }
     return max;
}

public int calProduct(int[] A, int i, int j){
   int result = 1;
   for(int m=i; m<=j; m++){
      result = result * A[m];
   }
   return result;
}


    The time of the solution is O(nˆ3).


180.2 Java Solution 2 - Dynamic Programming

This is similar to maximum subarray. Instead of sum, the sign of number affect the
product value.
  When iterating the array, each element has two possibilities: positive number or
negative number. We need to track a minimum value, so that when a negative number



                                                                              441 | 531

                                          Page 424 of 496
-----------------------Page 135 End-----------------------

180 Maximum Product Subarray


is given, it can also find the maximum value. We define two local variables, one tracks
the maximum and the other tracks the minimum.
public int maxProduct(int[] A) {
   if(A==null || A.length==0)
      return 0;

     int maxLocal = A[0];
     int minLocal = A[0];
     int global = A[0];

     for(int i=1; i<A.length; i++){
        int temp = maxLocal;
        maxLocal = Math.max(Math.max(A[i]*maxLocal, A[i]), A[i]*minLocal);
        minLocal = Math.min(Math.min(A[i]*temp, A[i]), A[i]*minLocal);
        global = Math.max(global, maxLocal);
     }
     return global;
}


    Time is O(n).




442 | 531                           Program Creek


                                Page 425 of 496
-----------------------Page 136 End-----------------------

181 Palindrome Partitioning

181.1 Problem

         Given a string s, partition s such that every substring of the partition is a palindrome.
    Return all possible palindrome partitioning of s.
    For example, given s = "aab", Return
[
        ["aa","b"],
        ["a","a","b"]
    ]




181.2 Depth-first Search

public ArrayList<ArrayList<String>> partition(String s) {
  ArrayList<ArrayList<String>> result = new ArrayList<ArrayList<String>>();

    if (s == null || s.length() == 0) {
      return result;
    }

    ArrayList<String> partition = new ArrayList<String>();//track each possible
        partition
    addPalindrome(s, 0, partition, result);

    return result;
}

private void addPalindrome(String s, int start, ArrayList<String> partition,
    ArrayList<ArrayList<String>> result) {
  //stop condition
  if (start == s.length()) {
    ArrayList<String> temp = new ArrayList<String>(partition);
    result.add(temp);
    return;
  }

    for (int i = start + 1; i <= s.length(); i++) {
      String str = s.substring(start, i);
      if (isPalindrome(str)) {




                                                                                         443 | 531

                                               Page 426 of 496
-----------------------Page 137 End-----------------------

181 Palindrome Partitioning


            partition.add(str);
            addPalindrome(s, i, partition, result);
            partition.remove(partition.size() - 1);
        }
    }
}

private boolean isPalindrome(String str) {
  int left = 0;
  int right = str.length() - 1;

    while (left < right) {
      if (str.charAt(left) != str.charAt(right)) {
        return false;
      }

        left++;
        right--;
    }

    return true;
}




181.3 Dynamic Programming

The dynamic programming approach is very similar to the problem of longest palin-
drome substring.
public static List<String> palindromePartitioning(String s) {

    List<String> result = new ArrayList<String>();

    if (s == null)
      return result;

    if (s.length() <= 1) {
      result.add(s);
      return result;
    }

    int length = s.length();

    int[][] table = new int[length][length];

    // l is length, i    is index of left boundary, j is index of right boundary
    for (int l = 1; l    <= length; l++) {
      for (int i = 0;    i <= length - l; i++) {
        int j = i + l    - 1;




444 | 531                             Program Creek


                                  Page 427 of 496
-----------------------Page 138 End-----------------------

                                                          181 Palindrome Partitioning


            if (s.charAt(i) == s.charAt(j)) {
              if (l == 1 || l == 2) {
                table[i][j] = 1;
              } else {
                table[i][j] = table[i + 1][j - 1];
              }
              if (table[i][j] == 1) {
                result.add(s.substring(i, j + 1));
              }
            } else {
              table[i][j] = 0;
            }
        }
    }

    return result;
}




                                     Program Creek                         445 | 531

                                        Page 428 of 496
-----------------------Page 139 End-----------------------

182 Palindrome Partitioning II

Given a string s, partition s such that every substring of the partition is a palindrome.
Return the minimum cuts needed for a palindrome partitioning of s. For example,
given s = "aab", return 1 since the palindrome partitioning ["aa","b"] could be produced
using 1 cut.


182.1 Analysis

This problem is similar to Palindrome Partitioning. It can be efficiently solved by using
dynamic programming. Unlike "Palindrome Partitioning", we need to maintain two
cache arrays, one tracks the partition position and one tracks the number of minimum
cut.


182.2 Java Solution

public int minCut(String s) {
   int n = s.length();

    boolean dp[][] = new boolean[n][n];
    int cut[] = new int[n];

    for (int j = 0; j < n; j++) {
      cut[j] = j; //set maximum # of cut
      for (int i = 0; i <= j; i++) {
        if (s.charAt(i) == s.charAt(j) && (j - i <= 1 || dp[i+1][j-1])) {
           dp[i][j] = true;

                // if need to cut, add 1 to the previous cut[i-1]
                if (i > 0){
                  cut[j] = Math.min(cut[j], cut[i-1] + 1);
                }else{
                // if [0...j] is palindrome, no need to cut
                  cut[j] = 0;
                }
            }
        }
    }

    return cut[n-1];
}




                                                                               447 | 531

                                          Page 429 of 496
-----------------------Page 140 End-----------------------

183 House Robber

You are a professional robber planning to rob houses along a street. Each house has
a certain amount of money stashed, the only constraint stopping you from robbing
each of them is that adjacent houses have security system connected and it will au-
tomatically contact the police if two adjacent houses were broken into on the same
night.
  Given a list of non-negative integers representing the amount of money of each
house, determine the maximum amount of money you can rob tonight without alert-
ing the police.



183.1 Java Solution 1 - Dynamic Programming

The key is to find the relation dp[i] = Math.max(dp[i-1], dp[i-2]+num[i-1]).
public int rob(int[] num) {
   if(num==null || num.length==0)
      return 0;

    int n = num.length;

    int[] dp = new int[n+1];
    dp[0]=0;
    dp[1]=num[0];

    for (int i=2; i<n+1; i++){
      dp[i] = Math.max(dp[i-1], dp[i-2]+num[i-1]);
    }

    return dp[n];
}




183.2 Java Solution 2

We can use two variables, even and odd, to track the maximum value so far as iterating
the array. You can use the following example to walk through the code.
50 1 1 50




                                                                               449 | 531

                                       Page 430 of 496
-----------------------Page 141 End-----------------------

183 House Robber




public int rob(int[] num) {
  if(num==null || num.length == 0)
    return 0;

    int even = 0;
    int odd = 0;

    for (int i = 0; i < num.length; i++) {
      if (i % 2 == 0) {
        even += num[i];
        even = even > odd ? even : odd;
      } else {
        odd += num[i];
        odd = even > odd ? even : odd;
      }
    }

    return even > odd ? even : odd;
}




450 | 531                         Program Creek


                              Page 431 of 496
-----------------------Page 142 End-----------------------

184 House Robber II

After robbing those houses on that street, the thief has found himself a new place for
his thievery so that he will not get too much attention. This time, all houses at this
place are arranged in a circle. That means the first house is the neighbor of the last
one. Meanwhile, the security system for these houses remain the same as for those in
the previous street.
  Given a list of non-negative integers representing the amount of money of each
house, determine the maximum amount of money you can rob tonight without alert-
ing the police.


184.1 Analysis

This is an extension of House Robber. There are two cases here 1) 1st element is
included and last is not included 2) 1st is not included and last is included. Therefore,
we can use the similar dynamic programming approach to scan the array twice and
get the larger value.


184.2 Java Solution

public int rob(int[] nums) {
   if(nums==null||nums.length==0)
      return 0;

   int n = nums.length;

   if(n==1){
      return nums[0];
   }
   if(n==2){
      return Math.max(nums[1], nums[0]);
   }

   //include 1st element, and not last element
   int[] dp = new int[n+1];
   dp[0]=0;
   dp[1]=nums[0];

   for(int i=2; i<n; i++){
      dp[i] = Math.max(dp[i-1], dp[i-2]+nums[i-1]);




                                                                               451 | 531

                                        Page 432 of 496
-----------------------Page 143 End-----------------------

184 House Robber II


    }

    //not include frist element, and include last element
    int[] dr = new int[n+1];
    dr[0]=0;
    dr[1]=nums[1];

    for(int i=2; i<n; i++){
      dr[i] = Math.max(dr[i-1], dr[i-2]+nums[i]);
    }

    return Math.max(dp[n-1], dr[n-1]);
}




452 | 531                         Program Creek


                              Page 433 of 496
-----------------------Page 144 End-----------------------

185 House Robber III

The houses form a binary tree. If the root is robbed, its left and right can not be
robbed.


185.1 Analysis

Traverse down the tree recursively. We can use an array to keep 2 values: the maximum
money when a root is selected and the maximum value when a root if NOT selected.


185.2 Java Solution

public int rob(TreeNode root) {
   if(root == null)
      return 0;

    int[] result = helper(root);
    return Math.max(result[0], result[1]);
}

public int[] helper(TreeNode root){
   if(root == null){
      int[] result = {0, 0};
      return result;
   }

    int[] result = new int[2];
    int[] left = helper(root.left);
    int[] right = helper (root.right);

    // result[0] is when root is selected, result[1] is when not.
    result[0] = root.val + left[1] + right[1];
    result[1] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);

    return result;
}




                                                                           453 | 531

                                      Page 434 of 496
-----------------------Page 145 End-----------------------

186 Jump Game

Given an array of non-negative integers, you are initially positioned at the first index
of the array. Each element in the array represents your maximum jump length at that
position. Determine if you are able to reach the last index. For example: A = [2,3,1,1,4],
return true. A = [3,2,1,0,4], return false.


186.1 Analysis

We can track the maximum index that can be reached. The key to solve this problem
is to find: 1) when the current position can not reach next position (return false) , and
2) when the maximum index can reach the end (return true).
   The largest index that can be reached is: i + A[i].




186.2 Java Solution

public boolean canJump(int[] A) {
   if(A.length <= 1)
      return true;

   int max = A[0]; //max stands for the largest index that can be reached.

   for(int i=0; i<A.length; i++){
      //if not enough to go to next
      if(max <= i && A[i] == 0)
         return false;

      //update max




                                                                                455 | 531

                                        Page 435 of 496
-----------------------Page 146 End-----------------------

186 Jump Game


        if(i + A[i] > max){
           max = i + A[i];
        }

        //max is enough to reach the end
        if(max >= A.length-1)
           return true;
    }

    return false;
}




456 | 531                          Program Creek


                               Page 436 of 496
-----------------------Page 147 End-----------------------

187 Jump Game II

Given an array of non-negative integers, you are initially positioned at the first index
of the array. Each element in the array represents your maximum jump length at that
position.
  Your goal is to reach the last index in the minimum number of jumps.
  For example, given array A = [2,3,1,1,4], the minimum number of jumps to reach the
last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.)


187.1 Analysis

This is an extension of Jump Game.
  The solution is similar, but we also track the maximum steps of last jump.


187.2 Java Solution

public int jump(int[] nums) {
  if (nums == null || nums.length == 0)
    return 0;

    int lastReach = 0;
    int reach = 0;
    int step = 0;

    for (int i = 0; i <= reach && i < nums.length; i++) {
      //when last jump can not read current i, increase the step by 1
      if (i > lastReach) {
        step++;
        lastReach = reach;
      }
      //update the maximal jump
      reach = Math.max(reach, nums[i] + i);
    }

    if (reach < nums.length - 1)
      return 0;

    return step;
}




                                                                               457 | 531

                                        Page 437 of 496
-----------------------Page 148 End-----------------------

188 Best Time to Buy and Sell Stock

Say you have an array for which the ith element is the price of a given stock on day i.
  If you were only permitted to complete at most one transaction (ie, buy one and sell
one share of the stock), design an algorithm to find the maximum profit.


188.1 Naive Approach

The naive approach exceeds time limit.
public int maxProfit(int[] prices) {
   if(prices == null || prices.length < 2){
      return 0;
   }

    int profit = Integer.MIN_VALUE;
    for(int i=0; i<prices.length-1; i++){
       for(int j=0; j< prices.length; j++){
          if(profit < prices[j] - prices[i]){
             profit = prices[j] - prices[i];
          }
       }
    }
    return profit;
}




188.2 Efficient Approach

Instead of keeping track of largest element in the array, we track the maximum profit
so far.
public int maxProfit(int[] prices) {
   int profit = 0;
   int minElement = Integer.MAX_VALUE;
   for(int i=0; i<prices.length; i++){
     profit = Math.max(profit, prices[i]-minElement);
     minElement = Math.min(minElement, prices[i]);
   }
   return profit;
}




                                                                             459 | 531

                                       Page 438 of 496
-----------------------Page 149 End-----------------------

189 Best Time to Buy and Sell Stock II

Say you have an array for which the ith element is the price of a given stock on day i.
  Design an algorithm to find the maximum profit. You may complete as many trans-
actions as you like (ie, buy one and sell one share of the stock multiple times). How-
ever, you may not engage in multiple transactions at the same time (ie, you must sell
the stock before you buy again).


189.1 Analysis

This problem can be viewed as finding all ascending sequences. For example, given 5,
1, 2, 3, 4, buy at 1 & sell at 4 is the same as buy at 1 &sell at 2 & buy at 2& sell at 3 &
buy at 3 & sell at 4.
   We can scan the array once, and find all pairs of elements that are in ascending
order.


189.2 Java Solution

public int maxProfit(int[] prices) {
   int profit = 0;
   for(int i=1; i<prices.length; i++){
      int diff = prices[i]-prices[i-1];
      if(diff > 0){
         profit += diff;
      }
   }
   return profit;
}




                                                                                 461 | 531

                                         Page 439 of 496
-----------------------Page 150 End-----------------------

190 Best Time to Buy and Sell Stock III

Say you have an array for which the ith element is the price of a given stock on day i.
   Design an algorithm to find the maximum profit. You may complete at most two
transactions.
   Note: A transaction is a buy & a sell. You may not engage in multiple transactions
at the same time (ie, you must sell the stock before you buy again).


190.1 Analysis

Comparing to I and II, III limits the number of transactions to 2. This can be solve
by "devide and conquer". We use left[i] to track the maximum profit for transactions
before i, and use right[i] to track the maximum profit for transactions after i. You can
use the following example to understand the Java solution:
Prices: 1 4 5 7 6 3 2 9
left = [0, 3, 4, 6, 6, 6, 6, 8]
right= [8, 7, 7, 7, 7, 7, 7, 0]


  The maximum profit = 13


190.2 Java Solution

public int maxProfit(int[] prices) {
  if (prices == null || prices.length < 2) {
    return 0;
  }

  //highest profit in 0 ... i
  int[] left = new int[prices.length];
  int[] right = new int[prices.length];

  // DP from left to right
  left[0] = 0;
  int min = prices[0];
  for (int i = 1; i < prices.length; i++) {
    min = Math.min(min, prices[i]);
    left[i] = Math.max(left[i - 1], prices[i] - min);
  }

  // DP from right to left




                                                                              463 | 531

                                        Page 440 of 496
-----------------------Page 151 End-----------------------

190 Best Time to Buy and Sell Stock III


    right[prices.length - 1] = 0;
    int max = prices[prices.length - 1];
    for (int i = prices.length - 2; i >= 0; i--) {
      max = Math.max(max, prices[i]);
      right[i] = Math.max(right[i + 1], max - prices[i]);
    }

    int profit = 0;
    for (int i = 0; i < prices.length; i++) {
      profit = Math.max(profit, left[i] + right[i]);
    }

    return profit;
}




464 | 531                            Program Creek


                                Page 441 of 496
-----------------------Page 152 End-----------------------

191 Best Time to Buy and Sell Stock IV

191.1 Problem

Say you have an array for which the ith element is the price of a given stock on
day i.Design an algorithm to find the maximum profit. You may complete at most k
transactions.
   Note: You may not engage in multiple transactions at the same time (ie, you must
sell the stock before you buy again).


191.2 Analysis

This is a generalized version of Best Time to Buy and Sell Stock III. If we can solve this
problem, we can also use k=2 to solve III.
  The problem can be solve by using dynamic programming. The relation is:
local[i][j] = max(global[i-1][j-1] + max(diff,0), local[i-1][j]+diff)
global[i][j] = max(local[i][j], global[i-1][j])


   We track two arrays - local and global. The local array tracks maximum profit of j
transactions & the last transaction is on ith day. The global array tracks the maximum
profit of j transactions until ith day.


191.3 Java Solution - 2D Dynamic Programming

public int maxProfit(int k, int[] prices) {
  int len = prices.length;

  if (len < 2 || k <= 0)
    return 0;

  // ignore this line
  if (k == 1000000000)
    return 1648961;

  int[][] local = new int[len][k + 1];
  int[][] global = new int[len][k + 1];

  for (int i = 1; i < len; i++) {
    int diff = prices[i] - prices[i - 1];




                                                                                465 | 531

                                        Page 442 of 496
-----------------------Page 153 End-----------------------

191 Best Time to Buy and Sell Stock IV


        for (int j = 1; j <= k; j++) {
          local[i][j] = Math.max(
               global[i - 1][j - 1] + Math.max(diff, 0),
               local[i - 1][j] + diff);
          global[i][j] = Math.max(global[i - 1][j], local[i][j]);
        }
    }

    return global[prices.length - 1][k];
}




191.4 Java Solution - 1D Dynamic Programming

The solution above can be simplified to be the following:
public int maxProfit(int k, int[] prices) {
  if (prices.length < 2 || k <= 0)
    return 0;

    //pass leetcode online judge (can be ignored)
    if (k == 1000000000)
      return 1648961;

    int[] local = new int[k + 1];
    int[] global = new int[k + 1];

    for (int i = 0; i < prices.length - 1; i++) {
      int diff = prices[i + 1] - prices[i];
      for (int j = k; j >= 1; j--) {
        local[j] = Math.max(global[j - 1] + Math.max(diff, 0), local[j] + diff);
        global[j] = Math.max(local[j], global[j]);
      }
    }

    return global[k];
}




466 | 531                            Program Creek


                                Page 443 of 496
-----------------------Page 154 End-----------------------

192 Dungeon Game

Example:
-2 (K) -3 3
-5 -10 1
10 30 -5 (P)




192.1 Java Solution

This problem can be solved by using dynamic programming. We maintain a 2-D table.
h[i][j] is the minimum health value before he enters (i,j). h[0][0] is the value of the
answer. The left part is filling in numbers to the table.
public int calculateMinimumHP(int[][] dungeon) {
  int m = dungeon.length;
  int n = dungeon[0].length;

  //init dp table
  int[][] h = new int[m][n];

  h[m - 1][n - 1] = Math.max(1 - dungeon[m - 1][n - 1], 1);

  //init last row
  for (int i = m - 2; i >= 0; i--) {
    h[i][n - 1] = Math.max(h[i + 1][n - 1] - dungeon[i][n - 1], 1);
  }

  //init last column
  for (int j = n - 2; j >= 0; j--) {
    h[m - 1][j] = Math.max(h[m - 1][j + 1] - dungeon[m - 1][j], 1);
  }

  //calculate dp table
  for (int i = m - 2; i >= 0; i--) {
    for (int j = n - 2; j >= 0; j--) {
      int down = Math.max(h[i + 1][j] - dungeon[i][j], 1);
      int right = Math.max(h[i][j + 1] - dungeon[i][j], 1);
      h[i][j] = Math.min(right, down);
    }
  }

  return h[0][0];




                                                                             467 | 531

                                       Page 444 of 496
-----------------------Page 155 End-----------------------

193 Decode Ways

A message containing letters from A-Z is being encoded to numbers using the follow-
ing mapping:
  ’A’ ->1 ’B’ ->2 ... ’Z’ ->26
  Given an encoded message containing digits, determine the total number of ways
to decode it.


193.1 Analysis

193.2 Java Solution

public int numDecodings(String s) {
   if(s==null||s.length()==0||s.equals("0"))
      return 0;



    int[] t = new int[s.length()+1];
    t[0] = 1;

    //if(s.charAt(0)!=’0’)
    if(isValid(s.substring(0,1)))
       t[1]=1;
    else
       t[1]=0;

    for(int i=2; i<=s.length(); i++){
       if(isValid(s.substring(i-1,i))){
          t[i]+=t[i-1];
       }

        if(isValid(s.substring(i-2,i))){
           t[i]+=t[i-2];
        }
    }

    return t[s.length()];
}

public boolean isValid(String s){
   if(s.charAt(0)==’0’)
      return false;




                                                                         469 | 531

                                       Page 445 of 496
-----------------------Page 156 End-----------------------

193 Decode Ways


    int value = Integer.parseInt(s);
    return value>=1&&value<=26;
}




470 | 531                         Program Creek


                              Page 446 of 496
-----------------------Page 157 End-----------------------

194 Longest Common Subsequence

The longest common subsequence (LCS) problem is the problem of finding the longest
subsequence common to all sequences in a set of sequences (often just two sequences).


194.1 Analysis




194.2 Java Solution

public static int getLongestCommonSubsequence(String a, String b){
  int m = a.length();
  int n = b.length();
  int[][] dp = new int[m+1][n+1];

  for(int i=0; i<=m; i++){
    for(int j=0; j<=n; j++){
      if(i==0 || j==0){
         dp[i][j]=0;
      }else if(a.charAt(i-1)==b.charAt(j-1)){
         dp[i][j] = 1 + dp[i-1][j-1];
      }else{
         dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
      }
    }




                                                                           471 | 531

                                      Page 447 of 496
-----------------------Page 158 End-----------------------

194 Longest Common Subsequence


    }

    return dp[m][n];
}




472 | 531                        Program Creek


                           Page 448 of 496
-----------------------Page 159 End-----------------------

195 Longest Common Substring

In computer science, the longest common substring problem is to find the longest
string that is a substring of two or more strings.


195.1 Analysis

Given two strings a and b, let dp[i][j] be the length of the common substring ending
at a[i] and b[j].




  The dp table looks like the following given a="abc" and b="abcd".




195.2 Java Solution




                                                                          473 | 531

                                      Page 449 of 496
-----------------------Page 160 End-----------------------

195 Longest Common Substring



public static int getLongestCommonSubstring(String a, String b){
  int m = a.length();
  int n = b.length();

    int max = 0;

    int[][] dp = new int[m][n];

    for(int i=0; i<m; i++){
      for(int j=0; j<n; j++){
        if(a.charAt(i) == b.charAt(j)){
           if(i==0 || j==0){
             dp[i][j]=1;
           }else{
             dp[i][j] = dp[i-1][j-1]+1;
           }

                if(max < dp[i][j])
                  max = dp[i][j];
            }

        }
    }

    return max;
}


  This is a similar problem like longest common subsequence. The difference of the
solution is that for this problem when a[i]!=b[j], dp[i][j] are all zeros by default. How-
ever, in the longest common subsequence problem, dp[i][j] values are carried from the
previous values, i.e., dp[i-1][j] and dp[i][j-1].




474 | 531                                Program Creek


                                     Page 450 of 496
-----------------------Page 161 End-----------------------

196 Longest Increasing Subsequence

Given an unsorted array of integers, find the length of longest increasing subsequence.
   For example, given [10, 9, 2, 5, 3, 7, 101, 18], the longest increasing subsequence is
[2, 3, 7, 101]. Therefore the length is 4.


196.1 Java Solution 1 - Dynamic Programming

Let max[i] represent the length of the longest increasing subsequence so far. If any
element before i is smaller than nums[i], then max[i] = max(max[i], max[j]+1).
  Here is an example:




public int lengthOfLIS(int[] nums) {
   if(nums==null || nums.length==0)
      return 0;

   int[] max = new int[nums.length];

   for(int i=0; i<nums.length; i++){
      max[i]=1;




                                                                               475 | 531

                                        Page 451 of 496
-----------------------Page 162 End-----------------------

196 Longest Increasing Subsequence


        for(int j=0; j<i;j++){
           if(nums[i]>nums[j]){
              max[i]=Math.max(max[i], max[j]+1);
           }
        }
    }

    int result = 0;
    for(int i=0; i<max.length; i++){
       if(max[i]>result)
          result = max[i];
    }
    return result;
}




196.2 Java Solution 2 - O(nlog(n))

We can put the increasing sequence in a list.
for each num in nums
    if(list.size()==0)
        add num to list
    else if(num > last element in list)
        add num to list
    else
        replace the element in the list which is the smallest but bigger than
            num




public int lengthOfLIS(int[] nums) {
   if(nums==null || nums.length==0)




476 | 531                           Program Creek


                                Page 452 of 496
-----------------------Page 163 End-----------------------

                                                196 Longest Increasing Subsequence


        return 0;

    ArrayList<Integer> list = new ArrayList<Integer>();

    for(int num: nums){
       if(list.size()==0){
          list.add(num);
       }else if(num>list.get(list.size()-1)){
          list.add(num);
       }else{
          int i=0;
          int j=list.size()-1;

            while(i<j){
               int mid = (i+j)/2;
               if(list.get(mid) < num){
                  i=mid+1;
               }else{
                  j=mid;
               }
            }

            list.set(j, num);
        }
    }

    return list.size();
}




                                   Program Creek                         477 | 531

                                      Page 453 of 496
-----------------------Page 164 End-----------------------

197 Coin Change

You are given coins of different denominations and a total amount of money amount.
Write a function to compute the fewest number of coins that you need to make up that
amount. If that amount of money cannot be made up by any combination of the coins,
return -1.


197.1 Java Solution 1 - Dynamic Programming

Let dp[v] to be the minimum number of coins required to get the amount v.
dp[i+a_coin] = min(dp[i+a_coin], dp[i]+1) if dp[i] is reachable.
dp[i+a_coin] = dp[i+a_coin] is dp[i] is not reachable.
We initially set dp[i] to be MAX_VALUE.


    Here is the Java code:
public int coinChange(int[] coins, int amount) {
   if(amount==0) return 0;

     int[] dp = new int [amount+1];
     dp[0]=0; // do not need any coin to get 0 amount
     for(int i=1;i<=amount; i++)
        dp[i]= Integer.MAX_VALUE;

     for(int i=0; i<=amount; i++){
        for(int coin: coins){
           if(i+coin <=amount){
              if(dp[i]==Integer.MAX_VALUE){
                    dp[i+coin] = dp[i+coin];
                 }else{
                    dp[i+coin] = Math.min(dp[i+coin], dp[i]+1);
                 }
             }
         }
     }

     if(dp[amount] >= Integer.MAX_VALUE)
        return -1;

     return dp[amount];
}


    This clean solution takes time O(nˆ2).



                                                                          479 | 531

                                             Page 454 of 496
-----------------------Page 165 End-----------------------

197 Coin Change


197.2 Java Solution 2 - Breath First Search (BFS)

Most dynamic programming problems can be solved by using BFS.
  We can view this problem as going to a target position with steps that are allows in
the array coins. We maintain two queues: one of the amount so far and the other for
the minimal steps. The time is too much because of the contains method take n and
total time is O(nˆ3).
public int coinChange(int[] coins, int amount) {
  if (amount == 0)
    return 0;

    LinkedList<Integer> amountQueue = new LinkedList<Integer>();
    LinkedList<Integer> stepQueue = new LinkedList<Integer>();

    // to get 0, 0 step is required
    amountQueue.offer(0);
    stepQueue.offer(0);

    while (amountQueue.size() > 0) {
      int temp = amountQueue.poll();
      int step = stepQueue.poll();

        if (temp == amount)
          return step;

        for (int coin : coins) {
          if (temp > amount) {
            continue;
          } else {
            if (!amountQueue.contains(temp + coin)) {
               amountQueue.offer(temp + coin);
               stepQueue.offer(step + 1);
            }
          }
        }
    }

    return -1;
}




480 | 531                           Program Creek


                                Page 455 of 496
-----------------------Page 166 End-----------------------

198 Single Number

The problem:
     Given an array of integers, every element appears twice except for one. Find that single
    one.


198.1 Java Solution 1

The key to solve this problem is bit manipulation. XOR will return 1 only on two
different bits. So if two numbers are the same, XOR will return 0. Finally only one
number left.
public int singleNumber(int[] A) {
  int x = 0;
  for (int a : A) {
    x = x ^ a;
  }
  return x;
}




198.2 Java Solution 2

public int singleNumber(int[] A) {
  HashSet<Integer> set = new HashSet<Integer>();
  for (int n : A) {
    if (!set.add(n))
       set.remove(n);
  }
  Iterator<Integer> it = set.iterator();
  return it.next();
}


  The question now is do you know any other ways to do this?




                                                                                  481 | 531

                                          Page 456 of 496
-----------------------Page 167 End-----------------------

199 Single Number II

199.1 Problem

Given an array of integers, every element appears three times except for one. Find that
single one.


199.2 Java Solution

This problem is similar to Single Number.
public int singleNumber(int[] A) {
   int ones = 0, twos = 0, threes = 0;
   for (int i = 0; i < A.length; i++) {
      twos |= ones & A[i];
      ones ^= A[i];
      threes = ones & twos;
      ones &= ~threes;
      twos &= ~threes;
   }
   return ones;
}




                                                                             483 | 531

                                       Page 457 of 496
-----------------------Page 168 End-----------------------

200 Twitter Codility Problem Max Binary
    Gap

Problem: Get maximum binary Gap.
  For example, 9’s binary form is 1001, the gap is 2.


200.1 Java Solution 1

An integer x & 1 will get the last digit of the integer.
public static int getGap(int N) {
  int max = 0;
  int count = -1;
  int r = 0;

    while (N > 0) {
      // get right most bit & shift right
      r = N & 1;
      N = N >> 1;

        if (0 == r && count >= 0) {
          count++;
        }

        if (1 == r) {
          max = count > max ? count : max;
          count = 0;
        }
    }

    return max;
}


    Time is O(n).


200.2 Java Solution 2

public static int getGap(int N) {
  int pre = -1;
  int len = 0;




                                                           485 | 531

                                         Page 458 of 496
-----------------------Page 169 End-----------------------

200 Twitter Codility Problem Max Binary Gap


    while (N > 0) {
      int k = N & -N;

        int curr = (int) Math.log(k);

        N = N & (N - 1);

        if (pre != -1 && Math.abs(curr - pre) > len) {
          len = Math.abs(curr - pre) + 1;
        }
        pre = curr;
    }

    return len;
}


    Time is O(log(n)).




486 | 531                           Program Creek


                                Page 459 of 496
-----------------------Page 170 End-----------------------

201 Number of 1 Bits

201.1 Problem

Write a function that takes an unsigned integer and returns the number of ’1’ bits it
has (also known as the Hamming weight).
  For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011,
so the function should return 3.


201.2 Java Solution

public int hammingWeight(int n) {
   int count = 0;
   for(int i=1; i<33; i++){
      if(getBit(n, i) == true){
         count++;
      }
   }
   return count;
}

public boolean getBit(int n, int i){
   return (n & (1 << i)) != 0;
}




                                                                           487 | 531

                                      Page 460 of 496
-----------------------Page 171 End-----------------------

202 Reverse Bits

202.1 Problem

Reverse bits of a given 32 bits unsigned integer.
  For example, given input 43261596 (represented in binary as 00000010100101000001111010011100),
return 964176192 (represented in binary as 00111001011110000010100101000000).
  Follow up: If this function is called many times, how would you optimize it?
  Related problem: Reverse Integer


202.2 Java Solution

public int reverseBits(int n) {
  for (int i = 0; i < 16; i++) {
    n = swapBits(n, i, 32 - i - 1);
  }

    return n;
}

public int swapBits(int n, int i, int j) {
  int a = (n >> i) & 1;
  int b = (n >> j) & 1;

    if ((a ^ b) != 0) {
      return n ^= (1 << i) | (1 << j);
    }

    return n;
}




                                                                         489 | 531

                                      Page 461 of 496
-----------------------Page 172 End-----------------------

203 Repeated DNA Sequences

203.1 Problem

All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for
example: "ACGAATTCCG". When studying DNA, it is sometimes useful to identify
repeated sequences within the DNA.
  Write a function to find all the 10-letter-long sequences (substrings) that occur more
than once in a DNA molecule.
  For example, given s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT", re-
turn: ["AAAAACCCCC", "CCCCCAAAAA"].


203.2 Java Solution

The key to solve this problem is that each of the 4 nucleotides can be stored in 2 bits.
So the 10-letter-long sequence can be converted to 20-bits-long integer. The following
is a Java solution. You may use an example to manually execute the program and see
how it works.
public List<String> findRepeatedDnaSequences(String s) {
  List<String> result = new ArrayList<String>();

  int len = s.length();
  if (len < 10) {
    return result;
  }

  Map<Character, Integer> map = new HashMap<Character, Integer>();
  map.put(’A’, 0);
  map.put(’C’, 1);
  map.put(’G’, 2);
  map.put(’T’, 3);

  Set<Integer> temp = new HashSet<Integer>();
  Set<Integer> added = new HashSet<Integer>();

  int hash = 0;
  for (int i = 0; i < len; i++) {
    if (i < 9) {
      //each ACGT fit 2 bits, so left shift 2
      hash = (hash << 2) + map.get(s.charAt(i));
    } else {




                                                                              491 | 531

                                        Page 462 of 496
-----------------------Page 173 End-----------------------

203 Repeated DNA Sequences


            hash = (hash << 2) + map.get(s.charAt(i));
            //make length of hash to be 20
            hash = hash & (1 << 20) - 1;

            if (temp.contains(hash) && !added.contains(hash)) {
              result.add(s.substring(i - 9, i + 1));
              added.add(hash); //track added
            } else {
              temp.add(hash);
            }
        }

    }

    return result;
}




492 | 531                             Program Creek


                                  Page 463 of 496
-----------------------Page 174 End-----------------------

204 Bitwise AND of Numbers Range

204.1 Given a range [m, n] where 0 <= m <= n <=
        2147483647, return the bitwise AND of all numbers
        in this range, inclusive. For example, given the
        range [5, 7], you should return 4. Java Solution

The key to solve this problem is bitwise AND consecutive numbers. You can use the
following example to walk through the code.
8 4 2 1
---------------
5 | 0 1 0 1
6 | 0 1 1 0
7 | 0 1 1 1


public int rangeBitwiseAnd(int m, int n) {
    while (n > m) {
        n = n & n - 1;
    }
    return m & n;
}




                                                                        493 | 531

                                    Page 464 of 496
-----------------------Page 175 End-----------------------

205 Power of Two

Given an integer, write a function to determine if it is a power of two.


205.1 Analysis

If a number is power of 2, it’s binary form should be 10...0. So if we right shift a bit of
the number and then left shift a bit, the value should be the same when the number
>= 10(i.e.,2).


205.2 Java Solution

public boolean isPowerOfTwo(int n) {
   if(n<=0)
      return false;

    while(n>2){
       int t = n>>1;
       int c = t<<1;

        if(n-c != 0)
           return false;

        n = n>>1;
    }

    return true;
}




                                                                                 495 | 531

                                         Page 465 of 496
-----------------------Page 176 End-----------------------

206 Counting Bits

Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤
num calculate the number of 1’s in their binary representation and return them as an
array.
  Example:
  For num = 5 you should return [0,1,1,2,1,2].


206.1 Naive Solution

We can simply count bits for each number like the following:
public int[] countBits(int num) {
   int[] result = new int[num+1];

    for(int i=0; i<=num; i++){
       result[i] = countEach(i);
    }

    return result;
}

public int countEach(int num){
   int result = 0;

    while(num!=0){
       if(num%2==1){
          result++;
       }
       num = num/2;
    }

    return result;
}




206.2 Improved Solution

For number 2(10), 4(100), 8(1000), 16(10000), ..., the number of 1’s is 1. Any other
number can be converted to be 2m  ˆ + x. For example, 9=8+1, 10=8+2. The number of
1’s for any other number is 1 + # of 1’s in x.



                                                                          497 | 531

                                      Page 466 of 496
-----------------------Page 177 End-----------------------

206 Counting Bits




public int[] countBits(int num) {
   int[] result = new int[num+1];

    int p = 1; //p tracks the index for number x
    int pow = 1;
    for(int i=1; i<=num; i++){
       if(i==pow){
          result[i] = 1;
          pow <<= 1;
          p = 1;
       }else{
          result[i] = result[p]+1;
          p++;
       }

    }

    return result;
}




498 | 531                         Program Creek


                              Page 467 of 496
-----------------------Page 178 End-----------------------

207 Maximum Product of Word Lengths

Given a string array words, find the maximum value of length(word[i]) * length(word[j])
where the two words do not share common letters. You may assume that each word
will contain only lower case letters. If no such two words exist, return 0.


207.1 Java Solution

public int maxProduct(String[] words) {
   if(words==null || words.length==0)
      return 0;

    int[] arr = new int[words.length];
    for(int i=0; i<words.length; i++){
       for(int j=0; j<words[i].length(); j++){
          char c = words[i].charAt(j);
          arr[i] |= (1<< (c-’a’));
       }
    }

    int result = 0;

    for(int i=0; i<words.length; i++){
       for(int j=i+1; j<words.length; j++){
          if((arr[i] & arr[j]) == 0){
             result = Math.max(result, words[i].length()*words[j].length());
          }
       }
    }

    return result;
}




                                                                            499 | 531

                                       Page 468 of 496
-----------------------Page 179 End-----------------------

208 Permutations

Given a collection of numbers, return all possible permutations.
For example,
[1,2,3] have the following permutations:
[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1].




208.1 Java Solution 1

We can get all permutations by the following steps:
[1]
[2,   1]
[1,   2]
[3,   2,   1]
[2,   3,   1]
[2,   1,   3]
[3,   1,   2]
[1,   3,   2]
[1,   2,   3]


   Loop through the array, in each iteration, a new number is added to different loca-
tions of results of previous iteration. Start from an empty List.
public ArrayList<ArrayList<Integer>> permute(int[] num) {
  ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();

  //start from an empty list
  result.add(new ArrayList<Integer>());

  for (int i = 0; i < num.length; i++) {
    //list of list in current iteration of the array num
    ArrayList<ArrayList<Integer>> current = new
        ArrayList<ArrayList<Integer>>();

      for (ArrayList<Integer> l : result) {
        // # of locations to insert is largest index + 1
        for (int j = 0; j < l.size()+1; j++) {
          // + add num[i] to different locations
          l.add(j, num[i]);

            ArrayList<Integer> temp = new ArrayList<Integer>(l);




                                                                            501 | 531

                                       Page 469 of 496
-----------------------Page 180 End-----------------------

208 Permutations


                current.add(temp);

                //System.out.println(temp);

                // - remove num[i] add
                l.remove(j);
            }
        }

        result = new ArrayList<ArrayList<Integer>>(current);
    }

    return result;
}




208.2 Java Solution 2

We can also recursively solve this problem. Swap each element with each element
after it.
public ArrayList<ArrayList<Integer>> permute(int[] num) {
  ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();
  permute(num, 0, result);
  return result;
}

void permute(int[] num, int start, ArrayList<ArrayList<Integer>> result) {

    if (start >= num.length) {
      ArrayList<Integer> item = convertArrayToList(num);
      result.add(item);
    }

    for (int j = start; j <= num.length - 1; j++) {
      swap(num, start, j);
      permute(num, start + 1, result);
      swap(num, start, j);
    }
}

private ArrayList<Integer> convertArrayToList(int[] num) {
  ArrayList<Integer> item = new ArrayList<Integer>();
  for (int h = 0; h < num.length; h++) {
    item.add(num[h]);
  }
  return item;
}




502 | 531                                Program Creek


                                     Page 470 of 496
-----------------------Page 181 End-----------------------

                                                     208 Permutations


private void swap(int[] a, int i, int j) {
  int temp = a[i];
  a[i] = a[j];
  a[j] = temp;
}




                                Program Creek               503 | 531

                                   Page 471 of 496
-----------------------Page 182 End-----------------------

209 Permutations II

Given a collection of numbers that might contain duplicates, return all possible unique
permutations.
For example, [1,1,2] have the following unique permutations:
[1,1,2], [1,2,1], and [2,1,1].




209.1 Basic Idea

For each number in the array, swap it with every element after it. To avoid duplicate,
we need to check the existing sequence first.


209.2 Java Solution 1

public ArrayList<ArrayList<Integer>> permuteUnique(int[] num) {
  ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();
  permuteUnique(num, 0, result);
  return result;
}

private void permuteUnique(int[] num, int start,
    ArrayList<ArrayList<Integer>> result) {

    if (start >= num.length ) {
      ArrayList<Integer> item = convertArrayToList(num);
      result.add(item);
    }

    for (int j = start; j <= num.length-1; j++) {
      if (containsDuplicate(num, start, j)) {
        swap(num, start, j);
        permuteUnique(num, start + 1, result);
        swap(num, start, j);
      }
    }
}

private ArrayList<Integer> convertArrayToList(int[] num) {
  ArrayList<Integer> item = new ArrayList<Integer>();
  for (int h = 0; h < num.length; h++) {




                                                                             505 | 531

                                       Page 472 of 496
-----------------------Page 183 End-----------------------

209 Permutations II


      item.add(num[h]);
    }
    return item;
}

private boolean containsDuplicate(int[] arr, int start, int end) {
  for (int i = start; i <= end-1; i++) {
    if (arr[i] == arr[end]) {
       return false;
    }
  }
  return true;
}

private void swap(int[] a, int i, int j) {
  int temp = a[i];
  a[i] = a[j];
  a[j] = temp;
}




209.3 Java Solution 2

Use set to maintain uniqueness:
public static ArrayList<ArrayList<Integer>> permuteUnique(int[] num) {
  ArrayList<ArrayList<Integer>> returnList = new
      ArrayList<ArrayList<Integer>>();
  returnList.add(new ArrayList<Integer>());

    for (int i = 0; i < num.length; i++) {
      Set<ArrayList<Integer>> currentSet = new HashSet<ArrayList<Integer>>();
      for (List<Integer> l : returnList) {
        for (int j = 0; j < l.size() + 1; j++) {
           l.add(j, num[i]);
           ArrayList<Integer> T = new ArrayList<Integer>(l);
           l.remove(j);
           currentSet.add(T);
        }
      }
      returnList = new ArrayList<ArrayList<Integer>>(currentSet);
    }

    return returnList;
}


    Thanks to Milan for such a simple solution!




506 | 531                           Program Creek


                                Page 473 of 496
-----------------------Page 184 End-----------------------

210 Permutation Sequence

The set [1,2,3,. . . ,n] contains a total of n! unique permutations.
  By listing and labeling all of the permutations in order, We get the following se-
quence (ie, for n = 3):
"123"
"132"
"213"
"231"
"312"
"321"


  Given n and k, return the kth permutation sequence. (Note: Given n will be between
1 and 9 inclusive.)


210.1 Java Solution 1

public class Solution {
  public String getPermutation(int n, int k) {

    // initialize all numbers
    ArrayList<Integer> numberList = new ArrayList<Integer>();
    for (int i = 1; i <= n; i++) {
      numberList.add(i);
    }

    // change k to be index
    k--;

    // set factorial of n
    int mod = 1;
    for (int i = 1; i <= n; i++) {
      mod = mod * i;
    }

    String result = "";

    // find sequence
    for (int i = 0; i < n; i++) {
      mod = mod / (n - i);
      // find the right number(curIndex) of
      int curIndex = k / mod;




                                                                          507 | 531

                                      Page 474 of 496
-----------------------Page 185 End-----------------------

210 Permutation Sequence


            // update k
            k = k % mod;

            // get number according to curIndex
            result += numberList.get(curIndex);
            // remove from list
            numberList.remove(curIndex);
        }

        return result.toString();
    }
}




210.2 Java Solution 2

public class Solution {
  public String getPermutation(int n, int k) {
    boolean[] output = new boolean[n];
    StringBuilder buf = new StringBuilder("");

        int[] res = new int[n];
        res[0] = 1;

        for (int i = 1; i < n; i++)
          res[i] = res[i - 1] * i;

        for (int i = n - 1; i >= 0; i--) {
          int s = 1;

            while (k > res[i]) {
              s++;
              k = k - res[i];
            }

            for (int j = 0; j < n; j++) {
              if (j + 1 <= s && output[j]) {
                s++;
              }
            }

            output[s - 1] = true;
            buf.append(Integer.toString(s));
        }

        return buf.toString();
    }
}




508 | 531                              Program Creek


                                   Page 475 of 496
-----------------------Page 186 End-----------------------

211 Generate Parentheses

Given n pairs of parentheses, write a function to generate all combinations of well-
formed parentheses.
  For example, given n = 3, a solution set is:
"((()))", "(()())", "(())()", "()(())", "()()()"




211.1 Java Solution 1 - DFS

This solution is simple and clear.
public List<String> generateParenthesis(int n) {
   ArrayList<String> result = new ArrayList<String>();
   dfs(result, "", n, n);
   return result;
}
/*
left and right represents the remaining number of ( and ) that need to be
    added.
When left > right, there are more ")" placed than "(". Such cases are wrong
    and the method stops.
*/
public void dfs(ArrayList<String> result, String s, int left, int right){
   if(left > right)
      return;

    if(left==0&&right==0){
       result.add(s);
       return;
    }

    if(left>0){
       dfs(result, s+"(", left-1, right);
    }

    if(right>0){
       dfs(result, s+")", left, right-1);
    }
}




                                                                          509 | 531

                                      Page 476 of 496
-----------------------Page 187 End-----------------------

211 Generate Parentheses


211.2 Java Solution 2

This solution looks more complicated. ,You can use n=2 to walk though the code.
public List<String> generateParenthesis(int n) {
  ArrayList<String> result = new ArrayList<String>();
  ArrayList<Integer> diff = new ArrayList<Integer>();

    result.add("");
    diff.add(0);

    for (int i = 0; i < 2 * n; i++) {
      ArrayList<String> temp1 = new ArrayList<String>();
      ArrayList<Integer> temp2 = new ArrayList<Integer>();

        for (int j = 0; j < result.size(); j++) {
          String s = result.get(j);
          int k = diff.get(j);

            if (i < 2 * n - 1) {
              temp1.add(s + "(");
              temp2.add(k + 1);
            }

            if (k > 0 && i < 2 * n - 1 || k == 1 && i == 2 * n - 1) {
              temp1.add(s + ")");
              temp2.add(k - 1);
            }
        }

        result = new ArrayList<String>(temp1);
        diff = new ArrayList<Integer>(temp2);
    }

    return result;
}




510 | 531                               Program Creek


                                    Page 477 of 496
-----------------------Page 188 End-----------------------

212 Combination Sum

Given a set of candidate numbers (C) and a target number (T), find all unique combi-
nations in C where the candidate numbers sums to T. The same repeated number may
be chosen from C unlimited number of times.
  Note: All numbers (including target) will be positive integers. Elements in a combi-
nation (a1, a2, ... , ak) must be in non-descending order. (ie, a1 <= a2 <= ... <= ak). The
solution set must not contain duplicate combinations. For example, given candidate
set 2,3,6,7 and target 7, A solution set is:
[7]
[2, 2, 3]




212.1 Thoughts

The first impression of this problem should be depth-first search(DFS). To solve DFS
problem, recursion is a normal implementation.
  Note that the candidates array is not sorted, we need to sort it first.


212.2 Java Solution

public ArrayList<ArrayList<Integer>> combinationSum(int[] candidates, int
    target) {
   ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();

    if(candidates == null || candidates.length == 0) return result;

    ArrayList<Integer> current = new ArrayList<Integer>();
    Arrays.sort(candidates);

    combinationSum(candidates, target, 0, current, result);

    return result;
}

public void combinationSum(int[] candidates, int target, int j,
    ArrayList<Integer> curr, ArrayList<ArrayList<Integer>> result){
  if(target == 0){
     ArrayList<Integer> temp = new ArrayList<Integer>(curr);
     result.add(temp);




                                                                                 511 | 531

                                         Page 478 of 496
-----------------------Page 189 End-----------------------

212 Combination Sum


        return;
    }

    for(int i=j; i<candidates.length; i++){
       if(target < candidates[i])
           return;

        curr.add(candidates[i]);
        combinationSum(candidates, target - candidates[i], i, curr, result);
        curr.remove(curr.size()-1);
    }
}




512 | 531                          Program Creek


                               Page 479 of 496
-----------------------Page 190 End-----------------------

213 Combination Sum II

Given a collection of candidate numbers (C) and a target number (T), find all unique
combinations in C where the candidate numbers sums to T. Each number in C may
only be used ONCE in the combination.
  Note: 1) All numbers (including target) will be positive integers. 2) Elements in a
combination (a1, a2, . . . , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ . . . ≤
ak). 3) The solution set must not contain duplicate combinations.


213.1 Java Solution

This problem is an extension of Combination Sum. The difference is one number in
the array can only be used ONCE.
public List<ArrayList<Integer>> combinationSum2(int[] num, int target) {
   ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();
   if(num == null || num.length == 0)
      return result;

    Arrays.sort(num);

    ArrayList<Integer> temp = new ArrayList<Integer>();
    getCombination(num, 0, target, temp, result);

    HashSet<ArrayList<Integer>> set = new HashSet<ArrayList<Integer>>(result);

    //remove duplicate lists
    result.clear();
    result.addAll(set);

    return result;
}

public void getCombination(int[] num, int start, int target,
    ArrayList<Integer> temp, ArrayList<ArrayList<Integer>> result){
   if(target == 0){
      ArrayList<Integer> t = new ArrayList<Integer>(temp);
      result.add(t);
      return;
   }

    for(int i=start; i<num.length; i++){
       if(target < num[i])




                                                                              513 | 531

                                        Page 480 of 496
-----------------------Page 191 End-----------------------

213 Combination Sum II


            continue;

        temp.add(num[i]);
        getCombination(num, i+1, target-num[i], temp, result);
        temp.remove(temp.size()-1);
    }
}




514 | 531                          Program Creek


                               Page 481 of 496
-----------------------Page 192 End-----------------------

214 Combination Sum III

Find all possible combinations of k numbers that add up to a number n, given that
only numbers from 1 to 9 can be used and each combination should be a unique set
of numbers.
  Ensure that numbers within the set are sorted in ascending order.
  Example 1: Input: k = 3, n = 7 Output: [[1,2,4]] Example 2: Input: k = 3, n = 9
Output: [[1,2,6], [1,3,5], [2,3,4]]


214.1 Analysis

Related problems: Combination Sum, Combination Sum II.


214.2 Java Solution

public List<List<Integer>> combinationSum3(int k, int n) {
   List<List<Integer>> result = new ArrayList<List<Integer>>();
   List<Integer> list = new ArrayList<Integer>();
   dfs(result, 1, n, list, k);
   return result;
}

public void dfs(List<List<Integer>> result, int start, int sum, List<Integer>
    list, int k){
   if(sum==0 && list.size()==k){
      List<Integer> temp = new ArrayList<Integer>();
      temp.addAll(list);
      result.add(temp);
   }

     for(int i=start; i<=9; i++){
        if(sum-i<0) break;
        if(list.size()>k) break;

         list.add(i);
         dfs(result, i+1, sum-i, list, k);
         list.remove(list.size()-1);
     }
}


    Note the following relation in Java:



                                                                        515 | 531

                                           Page 482 of 496
-----------------------Page 193 End-----------------------

214 Combination Sum III


  Integer is a subclass of Number and ArrayList is a subclass of List. But ArrayList is
not a subclass of ArrayList.




516 | 531                           Program Creek


                                Page 483 of 496
-----------------------Page 194 End-----------------------

215 Combinations

215.1 Problem

Given two integers n and k, return all possible combinations of k numbers out of 1 ...
n.
   For example, if n = 4 and k = 2, a solution is:
[
    [2,4],
    [3,4],
    [2,3],
    [1,2],
    [1,3],
    [1,4],
]




215.2 Java Solution 1 (Recursion)

This is my naive solution. It passed the online judge. I first initialize a list with only
one element, and then recursively add available elements to it.
public ArrayList<ArrayList<Integer>> combine(int n, int k) {
  ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();

    //illegal case
    if (k > n) {
      return null;
    //if k==n
    } else if (k == n) {
      ArrayList<Integer> temp = new ArrayList<Integer>();
      for (int i = 1; i <= n; i++) {
        temp.add(i);
      }
      result.add(temp);
      return result;
    //if k==1
    } else if (k == 1) {

      for (int i = 1; i <= n; i++) {
        ArrayList<Integer> temp = new ArrayList<Integer>();
        temp.add(i);




                                                                                517 | 531

                                        Page 484 of 496
-----------------------Page 195 End-----------------------

215 Combinations


            result.add(temp);
        }

        return result;
    }

    //for normal cases, initialize a list with one element
    for (int i = 1; i <= n - k + 1; i++) {
      ArrayList<Integer> temp = new ArrayList<Integer>();
      temp.add(i);
      result.add(temp);
    }

    //recursively add more elements
    combine(n, k, result);

    return result;
}

public void combine(int n, int k, ArrayList<ArrayList<Integer>> result) {
  ArrayList<ArrayList<Integer>> prevResult = new
      ArrayList<ArrayList<Integer>>();
  prevResult.addAll(result);

    if(result.get(0).size() == k) return;

    result.clear();
    for (ArrayList<Integer> one : prevResult) {

        for (int i = 1; i <= n; i++) {
          if (i > one.get(one.size() - 1)) {
            ArrayList<Integer> temp = new ArrayList<Integer>();
            temp.addAll(one);
            temp.add(i);
            result.add(temp);
          }
        }
    }

    combine(n, k, result);
}




215.3 Java Solution 2 - DFS

public ArrayList<ArrayList<Integer>> combine(int n, int k) {
  ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();




518 | 531                           Program Creek


                                Page 485 of 496
-----------------------Page 196 End-----------------------

                                                                215 Combinations


    if (n <= 0 || n < k)
      return result;

    ArrayList<Integer> item = new ArrayList<Integer>();
    dfs(n, k, 1, item, result); // because it need to begin from 1

    return result;
}

private void dfs(int n, int k, int start, ArrayList<Integer> item,
    ArrayList<ArrayList<Integer>> res) {
  if (item.size() == k) {
    res.add(new ArrayList<Integer>(item));
    return;
  }

    for (int i = start; i <= n; i++) {
      item.add(i);
      dfs(n, k, i + 1, item, res);
      item.remove(item.size() - 1);
    }
}




                                  Program Creek                        519 | 531

                                     Page 486 of 496
-----------------------Page 197 End-----------------------

216 Letter Combinations of a Phone
    Number

Given a digit string, return all possible letter combinations that the number could
represent. (Check out your cellphone to see the mappings) Input:Digit string "23",
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].


216.1 Analysis

This problem can be solves by a typical DFS algorithm. DFS problems are very similar
and can be solved by using a simple recursion. Check out the index page to see other
DFS problems.


216.2 Java Solution

public List<String> letterCombinations(String digits) {
   HashMap<Integer, String> map = new HashMap<Integer, String>();
   map.put(2, "abc");
   map.put(3, "def");
   map.put(4, "ghi");
   map.put(5, "jkl");
   map.put(6, "mno");
   map.put(7, "pqrs");
   map.put(8, "tuv");
   map.put(9, "wxyz");
   map.put(0, "");

    ArrayList<String> result = new ArrayList<String>();

    if(digits == null || digits.length() == 0)
       return result;

    ArrayList<Character> temp = new ArrayList<Character>();
    getString(digits, temp, result, map);

    return result;
}

public void getString(String digits, ArrayList<Character> temp,
    ArrayList<String> result, HashMap<Integer, String> map){




                                                                          521 | 531

                                      Page 487 of 496
-----------------------Page 198 End-----------------------

216 Letter Combinations of a Phone Number


    if(digits.length() == 0){
       char[] arr = new char[temp.size()];
       for(int i=0; i<temp.size(); i++){
          arr[i] = temp.get(i);
       }
       result.add(String.valueOf(arr));
       return;
    }

    Integer curr = Integer.valueOf(digits.substring(0,1));
    String letters = map.get(curr);
    for(int i=0; i<letters.length(); i++){
       temp.add(letters.charAt(i));
       getString(digits.substring(1), temp, result, map);
       temp.remove(temp.size()-1);
    }
}




522 | 531                         Program Creek


                              Page 488 of 496
-----------------------Page 199 End-----------------------

217 Restore IP Addresses

Given a string containing only digits, restore it by returning all possible valid IP ad-
dress combinations.
  For example: given "25525511135",return ["255.255.11.135", "255.255.111.35"].


217.1 Java Solution

This is a typical search problem and it can be solved by using DFS.
public List<String> restoreIpAddresses(String s) {
   ArrayList<ArrayList<String>> result = new ArrayList<ArrayList<String>>();
   ArrayList<String> t = new ArrayList<String>();
   dfs(result, s, 0, t);

    ArrayList<String> finalResult = new ArrayList<String>();

    for(ArrayList<String> l: result){
       StringBuilder sb = new StringBuilder();
       for(String str: l){
          sb.append(str+".");
       }
       sb.setLength(sb.length() - 1);
       finalResult.add(sb.toString());
    }

    return finalResult;
}

public void dfs(ArrayList<ArrayList<String>> result, String s, int start,
    ArrayList<String> t){
   //if already get 4 numbers, but s is not consumed, return
   if(t.size()>=4 && start!=s.length())
      return;

    //make sure t’s size + remaining string’s length >=4
    if((t.size()+s.length()-start+1)<4)
       return;

    //t’s size is 4 and no remaining part that is not consumed.
    if(t.size()==4 && start==s.length()){
       ArrayList<String> temp = new ArrayList<String>(t);
       result.add(temp);




                                                                              523 | 531

                                        Page 489 of 496
-----------------------Page 200 End-----------------------

217 Restore IP Addresses


        return;
    }

    for(int i=1; i<=3; i++){
       //make sure the index is within the boundary
       if(start+i>s.length())
          break;

        String sub = s.substring(start, start+i);
        //handle case like 001. i.e., if length > 1 and first char is 0, ignore
            the case.
        if(i>1 && s.charAt(start)==’0’){
           break;
        }

        //make sure each number <= 255
        if(Integer.valueOf(sub)>255)
           break;

        t.add(sub);
        dfs(result, s, start+i, t);
        t.remove(t.size()-1);
    }
}




524 | 531                          Program Creek


                               Page 490 of 496
-----------------------Page 201 End-----------------------

218 Reverse Integer

LeetCode - Reverse Integer:
     Reverse digits of an integer. Example1: x = 123, return 321 Example2: x = -123, return
    -321



218.1 Naive Method

We can convert the integer to a string/char array, reverse the order, and convert the
string/char array back to an integer. However, this will require extra space for the
string. It doesn’t seem to be the right way, if you come with such a solution.



218.2 Efficient Approach

Actually, this can be done by using the following code.
public int reverse(int x) {
  //flag marks if x is negative
  boolean flag = false;
  if (x < 0) {
    x = 0 - x;
    flag = true;
  }

    int res = 0;
    int p = x;

    while   (p > 0) {
      int   mod = p % 10;
      p =   p / 10;
      res   = res * 10 + mod;
    }

    if (flag) {
      res = 0 - res;
    }

    return res;
}




                                                                                 525 | 531

                                         Page 491 of 496
-----------------------Page 202 End-----------------------

218 Reverse Integer


218.3 Succinct Solution

This solution is from Sherry, it is succinct and it is pretty.
public int reverse(int x) {
   int rev = 0;
   while(x != 0){
      rev = rev*10 + x%10;
      x = x/10;
   }

     return rev;
}




218.4 Handle Out of Range Problem

As we form a new integer, it is possible that the number is out of range. We can use
the following code to assign the newly formed integer. When it is out of range, throw
an exception.
try{
  result = ...;
}catch(InputMismatchException exception){
  System.out.println("This is not an integer");
}


    Please leave your comment if there is any better solutions.




526 | 531                             Program Creek


                                  Page 492 of 496
-----------------------Page 203 End-----------------------

219 Palindrome Number

Determine whether an integer is a palindrome. Do this without extra space.


219.1 Thoughts

Problems related with numbers are frequently solved by / and
  Note: no extra space here means do not convert the integer to string, since string
will be a copy of the integer and take extra space. The space take by div, left, and right
can be ignored.


219.2 Java Solution

public class Solution {
   public boolean isPalindrome(int x) {
      //negative numbers are not palindrome
    if (x < 0)
       return false;

        // initialize how many zeros
        int div = 1;
        while (x / div >= 10) {
          div *= 10;
        }

        while (x != 0) {
          int left = x / div;
          int right = x % 10;

            if (left != right)
              return false;

            x = (x % div) / 10;
            div /= 100;
        }

        return true;
    }
}




                                                                                527 | 531

                                        Page 493 of 496
-----------------------Page 204 End-----------------------

220 Pow(x, n)

Problem:
     Implement pow(x, n).
  This is a great example to illustrate how to solve a problem during a technical
interview. The first and second solution exceeds time limit; the third and fourth are
accepted.


220.1 Naive Method

First of all, assuming n is not negative, to calculate x to the power of n, we can simply
multiply x n times, i.e., x * x * ... * x. The time complexity is O(n). The implementation
is as simple as:
public class Solution {
   public double pow(double x, int n) {
      if(x == 0) return 0;
      if(n == 0) return 1;

        double result=1;
        for(int i=1; i<=n; i++){
           result = result * x;
        }

        return result;
    }
}


    Now we should think about how to do better than O(n).


220.2 Recursive Method

Naturally, we next may think how to do it in O(logn). We have a relation that xnˆ =
xˆ(n/2) * xˆ(n/2) * xˆ(n
public static double pow(double x, int n) {
   if(n == 0)
      return 1;

    if(n == 1)
       return x;




                                                                                529 | 531

                                        Page 494 of 496
-----------------------Page 205 End-----------------------

220 Pow(x, n)


    int half = n/2;
    int remainder = n%2;



    if(n % 2 ==1 && x < 0 && n < 0)
       return - 1/(pow(-x, half) * pow(-x, half) * pow(-x, remainder));
    else if (n < 0)
       return 1/(pow(x, -half) * pow(x, -half) * pow(x, -remainder));
    else
       return (pow(x, half) * pow(x, half) * pow(x, remainder));
}




220.3 In this solution, we can handle cases that x <0 and n
          <0. This solution actually takes more time than the
          first solution. Why? 3. Accepted Solution

The accepted solution is also recursive, but does division first. Time complexity is
O(nlog(n)). The key part of solving this problem is the while loop.
public double pow(double x, int n) {
  if (n == 0)
    return 1;
  if (n == 1)
    return x;

    int pn = n > 0 ? n : -n;// positive n
    int pn2 = pn;

    double px = x > 0 ? x : -x;// positive x
    double result = px;

    int k = 1;
    //the key part of solving this problem
    while (pn / 2 > 0) {
      result = result * result;
      pn = pn / 2;
      k = k * 2;
    }

    result = result * pow(px, pn2 - k);

    // handle negative result
    if (x < 0 && n % 2 == 1)
      result = -result;

    // handle negative power
    if (n < 0)




530 | 531                           Program Creek


                                Page 495 of 496
-----------------------Page 206 End-----------------------

                                                        220 Pow(x, n)


      result = 1 / result;

    return result;
}




220.4 Best Solution

The most understandable solution I have found so far.
public double power(double x, int n) {
  if (n == 0)
    return 1;

    double v = power(x, n / 2);

    if (n % 2 == 0) {
      return v * v;
    } else {
      return v * v * x;
    }
}

public double pow(double x, int n) {
  if (n < 0) {
    return 1 / power(x, -n);
  } else {
    return power(x, n);
  }
}




                                  Program Creek            531 | 531

                                      Page 496 of 496
-----------------------Page 207 End-----------------------

## Java Interview Questions InterviewBit.txt

Java Interview Questions




To view the live version of the
page, click here.

© Copyright by Interviewbit
-----------------------Page 1 End-----------------------

Contents

Java Basic Interview Questions
1.   Why is Java a platform independent language?
2.   Why is Java not a pure object oriented language?
3.   Pointers are used in C/ C++. Why does Java not make use of pointers?
4.   What do you understand by an instance variable and a local variable?
5.   What do you mean by data encapsulation?
6.   Tell us something about JIT compiler.
7.   Can you tell the diﬀerence between equals() method and equality operator (==) in
     Java?
8.   How is an infinite loop declared in Java?
9.   Briefly explain the concept of constructor overloading
10.   Comment on method overloading and overriding by citing relevant examples.
11.   A single try block and multiple catch blocks can co-exist in a Java Program.
      Explain.
12.   Explain the use of final keyword in variable, method and class.
13.   Do final, finally and finalize keywords have the same function?
14.   When can you use super keyword?
15.   Can the static methods be overloaded?
16.   Can the static methods be overridden?
17.   What is the main objective of garbage collection?
18.   What part of memory - Stack or Heap - is cleaned in garbage collection process?

Java Intermediate Interview Questions


Page 1                                                           © Copyright by Interviewbit
-----------------------Page 2 End-----------------------

                                                                    Java Interview Questions




Java Intermediate Interview Questions                                      (.....Continued)

19.   Apart from the security aspect, what are the reasons behind making strings
      immutable in Java?
20.   How would you diﬀerentiate between a String, StringBuﬀer, and a
      StringBuilder?
21.   Using relevant properties highlight the diﬀerences between interfaces and
      abstract classes.
22.   In Java, static as well as private method overriding is possible. Comment on the
      statement.
23.   What makes a HashSet diﬀerent from a TreeSet?
24.   Why is the character array preferred over string for storing confidential
      information?
25.   What are the diﬀerences between JVM, JRE and JDK in Java?
26.   What are the diﬀerences between HashMap and HashTable in Java?
27.   What is the importance of reflection in Java?
28.   What are the diﬀerent ways of threads usage?
29.   What are the diﬀerences between constructor and method of a class in Java?
30.   Java works as “pass by value” or “pass by reference” phenomenon?
31.   Which among String or String Buﬀer should be preferred when there are lot of
      updates required to be done in the data?
32.   How to not allow serialization of attributes of a class in Java?
33.   What happens if the static modifier is not included in the main method
      signature in Java?
34.   What happens if there are multiple main methods inside one class in Java?
35.   What do you understand by Object Cloning and how do you achieve it in Java?
36.   How does an exception propagate in the code?
37.   Is it mandatory for a catch block to be followed a er a try block?
38.   Will the finally block get executed when the return statement is written at the
      end of try block and catch block as shown below?
-----------------------Page 3 End-----------------------

Page 2                                                             © Copyright by Interviewbit

                                                                    Java Interview Questions




Java Intermediate Interview Questions                                      (.....Continued)
39.   Can you call a constructor of a class inside the another constructor?
40.   Contiguous memory locations are usually used for storing actual values in an
      array but not in ArrayList. Explain.

Java Advanced Interview Questions
41.   Although inheritance is a popular OOPs concept, it is less advantageous than
      composition. Explain.
42.   How is the creation of a String using new() diﬀerent from that of a literal?
43.   Is exceeding the memory limit possible in a program despite having a garbage
      collector?
44.   Why is synchronization necessary? Explain with the help of a relevant example.
45.   In the given code below, what is the significance of ... ?
46.   Can you explain the Java thread lifecycle?
47.   What could be the tradeoﬀ between the usage of an unordered array versus the
      usage of an ordered array?
48.   Is it possible to import the same class or package twice in Java and what
      happens to it during runtime?
49.   In case a package has sub packages, will it suﬀice to import only the main
      package? e.g. Does importing of com.myMainPackage.* also import
      com.myMainPackage.mySubPackage.*?
50.   Will the finally block be executed if the code System.exit(0) is written at the end
      of try block?
51.   What do you understand by marker interfaces in Java?
52.   Explain the term “Double Brace Initialisation” in Java?
53.   Why is it said that the length() method of String class doesn't return accurate
      results?
54.   What is the output of the below code and why?
55.   What are the possible ways of making object eligible for garbage collection (GC)
      in Java?
-----------------------Page 4 End-----------------------

Java Interview Programs
Page 3                                                           © Copyright by Interviewbit
                                                                  Java Interview Questions




Java Interview Programs                                                  (.....Continued)

56.   Check if a given string is palindrome using recursion.
57.   Write a Java program to check if the two strings are anagrams.
58.   Write a Java Program to find the factorial of a given number.
59.   Given an array of non-duplicating numbers from 1 to n where one number is
      missing, write an eﬀicient java program to find that missing number.
60.   Write a Java Program to check if any number is a magic number or not. A
      number is said to be a magic number if a er doing sum of digits in each step and
      inturn doing sum of digits of that sum, the ultimate result (when there is only
      one digit le ) is 1.

Conclusion
61.   Conclusion




Page 4                                                           © Copyright by Interviewbit
-----------------------Page 5 End-----------------------

Let's get Started
Do you have what it takes to ace a Java Interview? We are here to help you in
consolidating your knowledge and concepts in Java. The following article will cover
all the popular Java interview questions for freshers as well as experienced
candidates in depth.
Go through all the questions to enhance your chances of performing well in the
interviews. The questions will revolve around the basic and core fundamentals of
Java.
So, let’s dive deep into the plethora of useful interview questions on Java.

Java Basic Interview Questions
1.   Why is Java a platform independent language?
Java language was developed in such a way that it does not depend on any hardware
or so ware due to the fact that the compiler compiles the code and then converts it
to platform-independent byte code which can be run on multiple systems.
     The only condition to run that byte code is for the machine to have a runtime
     environment (JRE) installed in it.

2.   Why is Java not a pure object oriented language?
Java supports primitive data types - byte, boolean, char, short, int, float, long, and
double and hence it is not a pure object-oriented language.

3.   Pointers are used in C/ C++. Why does Java not make use of
     pointers?




Page 5                                                            © Copyright by Interviewbit
-----------------------Page 6 End-----------------------

                                                                     Java Interview Questions



Pointers are quite complicated and unsafe to use by beginner programmers. Java
focuses on code simplicity, and the usage of pointers can make it challenging. Pointer
utilization can also cause potential errors. Moreover, security is also compromised if
pointers are used because the users can directly access memory with the help of
pointers.
Thus, a certain level of abstraction is furnished by not including pointers in Java.
Moreover, the usage of pointers can make the procedure of garbage collection quite
slow and erroneous. Java makes use of references as these cannot be manipulated,
unlike pointers.

4.   What do you understand by an instance variable and a local
     variable?
Instance variables are those variables that are accessible by all the methods in the
class. They are declared outside the methods and inside the class. These variables
describe the properties of an object and remain bound to it at any cost.
All the objects of the class will have their copy of the variables for utilization. If any
modification is done on these variables, then only that instance will be impacted by
it, and all other class instances continue to remain unaﬀected.
Example:

  class Athlete {
  public String athleteName;
  public double athleteSpeed;
  public int athleteAge;
  }


Local variables are those variables present within a block, function, or constructor
and can be accessed only inside them. The utilization of the variable is restricted to
the block scope. Whenever a local variable is declared inside a method, the other
class methods don’t have any knowledge about the local variable.
Example:




Page 6                                                              © Copyright by Interviewbit
-----------------------Page 7 End-----------------------

                                                                   Java Interview Questions




  public void athlete() {
  String athleteName;
  double athleteSpeed;
  int athleteAge;
  }




5.   What do you mean by data encapsulation?
     Data Encapsulation is an Object-Oriented Programming concept of hiding the
     data attributes and their behaviors in a single unit.
     It helps developers to follow modularity while developing so ware by ensuring
     that each object is independent of other objects by having its own methods,
     attributes, and functionalities.
     It is used for the security of the private properties of an object and hence serves
     the purpose of data hiding.




Page 7                                                            © Copyright by Interviewbit
-----------------------Page 8 End-----------------------

                                                                 Java Interview Questions




6.   Tell us something about JIT compiler.
     JIT stands for Just-In-Time and it is used for improving the performance during
     run time. It does the task of compiling parts of byte code having similar
     functionality at the same time thereby reducing the amount of compilation time
     for the code to run.
     The compiler is nothing but a translator of source code to machine-executable
     code. But what is special about the JIT compiler? Let us see how it works:
          First, the Java source code (.java) conversion to byte code (.class) occurs
          with the help of the javac compiler.
          Then, the .class files are loaded at run time by JVM and with the help of an
          interpreter, these are converted to machine understandable code.
          JIT compiler is a part of JVM. When the JIT compiler is enabled, the JVM
          analyzes the method calls in the .class files and compiles them to get more
          eﬀicient and native code. It also ensures that the prioritized method calls
          are optimized.
          Once the above step is done, the JVM executes the optimized code directly
          instead of interpreting the code again. This increases the performance and
          speed of the execution.




Page 8                                                         © Copyright by Interviewbit
-----------------------Page 9 End-----------------------

                                                           Java Interview Questions




7.   Can you tell the diﬀerence between equals() method and
     equality operator (==) in Java?

         equals()                    ==

         This is a method defined
                                     It is a binary operator in Java.
         in the Object class. 

         This method is used for     This operator is used for
         checking the equality of    comparing addresses (or
         contents between two        references), i.e checks if both
         objects as per the          the objects are pointing to the
         specified business logic.   same memory location.

Note:




Page 9                                                    © Copyright by Interviewbit
-----------------------Page 10 End-----------------------

                                                                  Java Interview Questions




     In the cases where the equals method is not overridden in a class, then the class
     uses the default implementation of the equals method that is closest to the
     parent class.
     Object class is considered as the parent class of all the java classes. The
     implementation of the equals method in the Object class uses the == operator to
     compare two objects. This default implementation can be overridden as per the
     business logic.

8.   How is an infinite loop declared in Java?
Infinite loops are those loops that run infinitely without any breaking conditions.
Some examples of consciously declaring infinite loop is:
     Using For Loop:

  for (;;)
  {
     // Business logic
     // Any break logic
  }


     Using while loop:

  while(true){
     // Business logic
     // Any break logic
  }


     Using do-while loop:

  do{
     // Business logic
     // Any break logic
  }while(true);



9.   Briefly explain the concept of constructor overloading




Page 10                                                          © Copyright by Interviewbit
-----------------------Page 11 End-----------------------

                                                                 Java Interview Questions



Constructor overloading is the process of creating multiple constructors in the class
consisting of the same name with a diﬀerence in the constructor parameters.
Depending upon the number of parameters and their corresponding types,
distinguishing of the diﬀerent types of constructors is done by the compiler.

  class Hospital {
  int variable1, variable2;
  double variable3;
  public Hospital(int doctors, int nurses) {
   variable1 = doctors;
   variable2 = nurses;
  }
  public Hospital(int doctors) {
   variable1 = doctors;
  }
  public Hospital(double salaries) {
   variable3 = salaries
  }
  }




Three constructors are defined here but they diﬀer on the basis of parameter type
and their numbers.




Page 11                                                         © Copyright by Interviewbit
-----------------------Page 12 End-----------------------

                                                                Java Interview Questions




10.   Comment on method overloading and overriding by citing
      relevant examples.
In Java, method overloading is made possible by introducing diﬀerent methods in
the same class consisting of the same name. Still, all the functions diﬀer in the
number or type of parameters. It takes place inside a class and enhances program
readability.
The only diﬀerence in the return type of the method does not promote method
overloading. The following example will furnish you with a clear picture of it.

  class OverloadingHelp {
     public int findarea (int l, int b) {
             int var1;
             var1 = l * b;
             return var1;
     }
     public int findarea (int l, int b, int h) {
             int var2;
             var2 = l * b * h;
             return var2;
     }
  }




Page 12                                                        © Copyright by Interviewbit
-----------------------Page 13 End-----------------------

                                                                 Java Interview Questions



Both the functions have the same name but diﬀer in the number of arguments. The
first method calculates the area of the rectangle, whereas the second method
calculates the area of a cuboid.
Method overriding is the concept in which two methods having the same method
signature are present in two diﬀerent classes in which an inheritance relationship is
present. A particular method implementation (already present in the base class) is
possible for the derived class by using method overriding.
Let’s give a look at this example:

  class HumanBeing {
         public int walk (int distance, int time) {
                 int speed = distance / time;
                 return speed;
         }
  }
  class Athlete extends HumanBeing {
         public int walk(int distance, int time) {
                 int speed = distance / time;
                 speed = speed * 2;
                 return speed;
         }
  }




Page 13                                                         © Copyright by Interviewbit
-----------------------Page 14 End-----------------------

                                                                   Java Interview Questions



Both class methods have the name walk and the same parameters, distance, and
time. If the derived class method is called, then the base class method walk gets
overridden by that of the derived class.

11.   A single try block and multiple catch blocks can co-exist in a
      Java Program. Explain.
Yes, multiple catch blocks can exist but specific approaches should come prior to the
general approach because only the first catch block satisfying the catch condition is
executed. The given code illustrates the same:

  public class MultipleCatch {
  public static void main(String args[]) {
   try {
    int n = 1000, x = 0;
    int arr[] = new int[n];
    for (int i = 0; i <= n; i++) {
     arr[i] = i / x;
    }
   }
   catch (ArrayIndexOutOfBoundsException exception) {
    System.out.println("1st block = ArrayIndexOutOfBoundsException");
   }
   catch (ArithmeticException exception) {
    System.out.println("2nd block = ArithmeticException");
   }
   catch (Exception exception) {
    System.out.println("3rd block = Exception");
   }
  }
  }


Here, the second catch block will be executed because of division by 0 (i / x). In case x
was greater than 0 then the first catch block will execute because for loop runs till i =
n and array index are till n-1.

12.   Explain the use of final keyword in variable, method and
      class.
In Java, the final keyword is used as defining something as constant /final and
represents the non-access modifier.




Page 14                                                           © Copyright by Interviewbit
-----------------------Page 15 End-----------------------

                                                                   Java Interview Questions



     final variable:
          When a variable is declared as final in Java, the value can’t be modified
          once it has been assigned.
          If any value has not been assigned to that variable, then it can be assigned
          only by the constructor of the class.
     final method:
          A method declared as final cannot be overridden by its children's classes.
          A constructor cannot be marked as final because whenever a class is
          inherited, the constructors are not inherited. Hence, marking it final
          doesn't make sense. Java throws compilation error saying - modifier final
          not allowed here

     final class:
          No classes can be inherited from the class declared as final. But that final
          class can extend other classes for its usage.

13.   Do final, finally and finalize keywords have the same
      function?
All three keywords have their own utility while programming.
Final: If any restriction is required for classes, variables, or methods, the final
keyword comes in handy. Inheritance of a final class and overriding of a final method
is restricted by the use of the final keyword. The variable value becomes fixed a er
incorporating the final keyword. Example:

  final int a=100;
  a = 0; // error


The second statement will throw an error.
Finally: It is the block present in a program where all the codes written inside it get
executed irrespective of handling of exceptions. Example:




Page 15                                                           © Copyright by Interviewbit
-----------------------Page 16 End-----------------------

                                                                   Java Interview Questions




  try {
  int variable = 5;
  }
  catch (Exception exception) {
  System.out.println("Exception occurred");
  }
  finally {
  System.out.println("Execution of finally block");
  }


Finalize: Prior to the garbage collection of an object, the finalize method is called so
that the clean-up activity is implemented. Example:

  public static void main(String[] args) {
  String example = new String("InterviewBit");
  example = null;
  System.gc(); // Garbage collector called
  }
  public void finalize() {
  // Finalize called
  }



14.   When can you use super keyword?
     The super keyword is used to access hidden fields and overridden methods or
     attributes of the parent class.
     Following are the cases when this keyword can be used:
          Accessing data members of parent class when the member names of the
          class and its child subclasses are same.
          To call the default and parameterized constructor of the parent class inside
          the child class.
          Accessing the parent class methods when the child classes have overridden
          them.
     The following example demonstrates all 3 cases when a super keyword is used.




Page 16                                                           © Copyright by Interviewbit
-----------------------Page 17 End-----------------------

                                                                       Java Interview Questions




  public class Parent{
         private int num = 1;

          Parent(){
              System.out.println("Parent class default constructor.");
          }

          Parent(String x){
              System.out.println("Parent class parameterised constructor.");
          }

          public void foo(){
              System.out.println("Parent class foo!");
          }
     }

     public class Child extends Parent{
         private int num = 2;

          Child(){
              System.out.println("Child class default Constructor");

              super();    // to call default parent constructor
              super("Call Parent");    // to call parameterised constructor.
          }

          void printNum(){
              System.out.println(num);
              System.out.println(super.num); //prints the value of num of parent class
          }

          @Override
          public void foo(){
              System.out.println("Parent class foo!");
              super.foo();    //Calls foo method of Parent class inside the Overriden foo
          }
     }



15.   Can the static methods be overloaded?
Yes! There can be two or more static methods in a class with the same name but
diﬀering input parameters.

16.   Can the static methods be overridden?




Page 17                                                           © Copyright by Interviewbit
-----------------------Page 18 End-----------------------

                                                                Java Interview Questions




     No! Declaration of static methods having the same signature can be done in the
     subclass but run time polymorphism can not take place in such cases.
     Overriding or dynamic polymorphism occurs during the runtime, but the static
     methods are loaded and looked up at the compile time statically. Hence, these
     methods cant be overridden.

17.   What is the main objective of garbage collection?
The main objective of this process is to free up the memory space occupied by the
unnecessary and unreachable objects during the Java program execution by deleting
those unreachable objects.
     This ensures that the memory resource is used eﬀiciently, but it provides no
     guarantee that there would be suﬀicient memory for the program execution.

18.   What part of memory - Stack or Heap - is cleaned in garbage
      collection process?
Heap.

Java Intermediate Interview Questions
19.   Apart from the security aspect, what are the reasons behind
      making strings immutable in Java?
A String is made immutable due to the following reasons:
     String Pool: Designers of Java were aware of the fact that String data type is
     going to be majorly used by the programmers and developers. Thus, they
     wanted optimization from the beginning. They came up with the notion of using
     the String pool (a storage area in Java heap) to store the String literals. They
     intended to decrease the temporary String object with the help of sharing. An
     immutable class is needed to facilitate sharing. The sharing of the mutable
     structures between two unknown parties is not possible. Thus, immutable Java
     String helps in executing the concept of String Pool.




Page 18                                                        © Copyright by Interviewbit
-----------------------Page 19 End-----------------------

                                                                     Java Interview Questions




     Multithreading: The safety of threads regarding the String objects is an
     important aspect in Java. No external synchronization is required if the String
     objects are immutable. Thus, a cleaner code can be written for sharing the
     String objects across diﬀerent threads. The complex process of concurrency is
     facilitated by this method.
     Collections: In the case of Hashtables and HashMaps, keys are String objects. If
     the String objects are not immutable, then it can get modified during the period
     when it resides in the HashMaps. Consequently, the retrieval of the desired data
     is not possible. Such changing states pose a lot of risks. Therefore, it is quite safe
     to make the string immutable.

20.   How would you diﬀerentiate between a String, StringBuﬀer,
      and a StringBuilder?




Page 19                                                            © Copyright by Interviewbit
-----------------------Page 20 End-----------------------

                                                                  Java Interview Questions



     Storage area: In string, the String pool serves as the storage area. For
     StringBuilder and StringBuﬀer, heap memory is the storage area.
     Mutability: A String is immutable, whereas both the StringBuilder and
     StringBuﬀer are mutable.
     Eﬀiciency: It is quite slow to work with a String. However, StringBuilder is the
     fastest in performing operations. The speed of a StringBuﬀer is more than a
     String and less than a StringBuilder. (For example appending a character is
     fastest in StringBuilder and very slow in String because a new memory is
     required for the new String with appended character.)
     Thread-safe: In the case of a threaded environment, StringBuilder and
     StringBuﬀer are used whereas a String is not used. However, StringBuilder is
     suitable for an environment with a single thread, and a StringBuﬀer is suitable
     for multiple threads.
     Syntax:

  // String
  String first = "InterviewBit";
  String second = new String("InterviewBit");
  // StringBuffer
  StringBuffer third = new StringBuffer("InterviewBit");
  // StringBuilder
  StringBuilder fourth = new StringBuilder("InterviewBit");



21.   Using relevant properties highlight the diﬀerences between
      interfaces and abstract classes.




Page 20                                                          © Copyright by Interviewbit
-----------------------Page 21 End-----------------------

                                                                  Java Interview Questions



     Availability of methods: Only abstract methods are available in interfaces,
     whereas non-abstract methods can be present along with abstract methods in
     abstract classes.
     Variable types: Static and final variables can only be declared in the case of
     interfaces, whereas abstract classes can also have non-static and non-final
     variables.
     Inheritance: Multiple inheritances are facilitated by interfaces, whereas abstract
     classes do not promote multiple inheritances.
     Data member accessibility: By default, the class data members of interfaces
     are of the public- type. Conversely, the class members for an abstract class can
     be protected or private also.
     Implementation: With the help of an abstract class, the implementation of an
     interface is easily possible. However, the converse is not true;
Abstract class example:

  public abstract class Athlete {
  public abstract void walk();
  }


Interface example:

  public interface Walkable {
  void walk();
  }



22.   In Java, static as well as private method overriding is
      possible. Comment on the statement.
The statement in the context is completely False. The static methods have no
relevance with the objects, and these methods are of the class level. In the case of a
child class, a static method with a method signature exactly like that of the parent
class can exist without even throwing any compilation error.




Page 21                                                          © Copyright by Interviewbit
-----------------------Page 22 End-----------------------

                                                                    Java Interview Questions



The phenomenon mentioned here is popularly known as method hiding, and
overriding is certainly not possible. Private method overriding is unimaginable
because the visibility of the private method is restricted to the parent class only. As a
result, only hiding can be facilitated and not overriding.

23.   What makes a HashSet diﬀerent from a TreeSet?
Although both HashSet and TreeSet are not synchronized and ensure that duplicates
are not present, there are certain properties that distinguish a HashSet from a
TreeSet.
     Implementation: For a HashSet, the hash table is utilized for storing the
     elements in an unordered manner. However, TreeSet makes use of the red-black
     tree to store the elements in a sorted manner.
     Complexity/ Performance: For adding, retrieving, and deleting elements, the
     time amortized complexity is O(1) for a HashSet. The time complexity for
     performing the same operations is a bit higher for TreeSet and is equal to O(log
     n). Overall, the performance of HashSet is faster in comparison to TreeSet.
     Methods: hashCode() and equals() are the methods utilized by HashSet for
     making comparisons between the objects. Conversely, compareTo() and
     compare() methods are utilized by TreeSet to facilitate object comparisons.
     Objects type: Heterogeneous and null objects can be stored with the help of
     HashSet. In the case of a TreeSet, runtime exception occurs while inserting
     heterogeneous objects or null objects.

24.   Why is the character array preferred over string for storing
      confidential information?
In Java, a string is basically immutable i.e. it cannot be modified. A er its declaration,
it continues to stay in the string pool as long as it is not removed in the form of
garbage. In other words, a string resides in the heap section of the memory for an
unregulated and unspecified time interval a er string value processing is executed.




Page 22                                                            © Copyright by Interviewbit
-----------------------Page 23 End-----------------------

                                                                 Java Interview Questions



As a result, vital information can be stolen for pursuing harmful activities by hackers
if a memory dump is illegally accessed by them. Such risks can be eliminated by using
mutable objects or structures like character arrays for storing any variable. A er the
work of the character array variable is done, the variable can be configured to blank
at the same instant. Consequently, it helps in saving heap memory and also gives no
chance to the hackers to extract vital data.

25.   What are the diﬀerences between JVM, JRE and JDK in Java?




Page 23                                                         © Copyright by Interviewbit
-----------------------Page 24 End-----------------------

                                                    Java Interview Questions




          Criteria       JDK             JRE                     JVM

          Abbreviation   Java            Java
                                                                 Java Virtual
                         Development     Runtime
                                                                 Machine
                         Kit             Environment

          Definition                                             JVM is a
                                                                 platform-
                                                                 dependent,
                                                                 abstract
                                                                 machine
                         JDK is a                                comprising of 3
                         complete        JRE is a                specifications -
                         so ware         so ware                 document
                         development     package                 describing the
                         kit for         providing               JVM
                         developing      Java class              implementatio
                         Java            libraries,              requirements,
                         applications.   JVM and all             computer
                         It comprises    the required            program
                         JRE,            components              meeting the JV
                         JavaDoc,        to run the              requirements
                         compiler,       Java                    and instance
                         debuggers,      applications.           object for
                         etc.                                    executing the
                                                                 Java byte code
                                                                 and provide the
                                                                 runtime
                                                                 environment fo
                                                                 execution.

          Main                           JRE is mainly
                         JDK is mainly                           JVM provides
          Purpose                        used for
                         used for code                           specifications fo
                                         environment
                         development                             all the
                                         creation to
                         and                                     implementatio
                                         execute the
                         execution.                              to JRE.
                                           d
Page 24                                            © Copyright by Interviewbit
-----------------------Page 25 End-----------------------

                                                                   Java Interview Questions




26.   What are the diﬀerences between HashMap and HashTable
      in Java?

          HashMap                                 HashTable

          HashMap is not synchronized             HashTable is synchronized
          thereby making it better for            and hence it is suitable for
          non-threaded applications.              threaded applications.

          Allows only one null key but
                                                  This does not allow null in
          any number of null in the
                                                  both keys or values.
          values.

          Supports order of insertion by
                                                  Order of insertion is not
          making use of its subclass
                                                  guaranteed in HashTable.
          LinkedHashMap.


27.   What is the importance of reflection in Java?
     The term reflection is used for describing the inspection capability of a code
     on other code either of itself or of its system and modify it during runtime.
     Consider an example where we have an object of unknown type and we have a
     method ‘fooBar()’ which we need to call on the object. The static typing system
     of Java doesn't allow this method invocation unless the type of the object is
     known beforehand. This can be achieved using reflection which allows the code
     to scan the object and identify if it has any method called “fooBar()” and only
     then call the method if needed.

  Method methodOfFoo = fooObject.getClass().getMethod("fooBar", null);
  methodOfFoo.invoke(fooObject, null);




Page 25                                                          © Copyright by Interviewbit
-----------------------Page 26 End-----------------------

                                                                     Java Interview Questions




     Using reflection has its own cons:
          Speed — Method invocations due to reflection are about three times slower
          than the direct method calls.
          Type safety — When a method is invoked via its reference wrongly using
          reflection, invocation fails at runtime as it is not detected at compile/load
          time.
          Traceability — Whenever a reflective method fails, it is very diﬀicult to find
          the root cause of this failure due to a huge stack trace. One has to deep dive
          into the invoke() and proxy() method logs to identify the root cause.
     Hence, it is advisable to follow solutions that don't involve reflection and use
     this method as a last resort.

28.   What are the diﬀerent ways of threads usage?
     We can define and implement a thread in java using two ways:
         Extending the Thread class

  class InterviewBitThreadExample extends Thread{
     public void run(){
         System.out.println("Thread runs...");
     }
     public static void main(String args[]){
         InterviewBitThreadExample ib = new InterviewBitThreadExample();
         ib.start();
     }
  }


     Implementing the Runnable interface

  class InterviewBitThreadExample implements Runnable{
     public void run(){
         System.out.println("Thread runs...");
     }
     public static void main(String args[]){
         Thread ib = new Thread(new InterviewBitThreadExample());
         ib.start();
     }
  }




Page 26                                                             © Copyright by Interviewbit
-----------------------Page 27 End-----------------------

                                                               Java Interview Questions



     Implementing a thread using the method of Runnable interface is more
     preferred and advantageous as Java does not have support for multiple
     inheritances of classes.
       start() method is used for creating a separate call stack for the thread
     execution. Once the call stack is created, JVM calls the run() method for
     executing the thread in that call stack.

29.   What are the diﬀerences between constructor and method
      of a class in Java?




Page 27                                                       © Copyright by Interviewbit
-----------------------Page 28 End-----------------------

                                                             Java Interview Questions




          Constructor                                 Method

                                                      Method is used for
          Constructor is used for initializing the
                                                      exposing the
          object state.
                                                      object's behavior.

                                                      Method should
                                                      have a return
                                                      type. Even if it
          Constructor has no return type.
                                                      does not return
                                                      anything, return
                                                      type is void.

                                                      Method has to be
          Constructor gets invoked implicitly.        invoked on the
                                                      object explicitly.

                                                      If a method is not
          If the constructor is not defined, then a
                                                      defined, then the
          default constructor is provided by the
                                                      compiler does not
          java compiler.
                                                      provide it.

                                                      The name of the
          The constructor name should be equal        method can have
          to the class name.                          any name or have
                                                      a class name too.

          A constructor cannot be marked as final
                                                      A method can be
          because whenever a class is inherited,
                                                      defined as final
          the constructors are not inherited.
                                                      but it cannot be
          Hence, marking it final doesn't make
                                                      overridden in its
          sense. Java throws compilation error
                                                      subclasses.
          saying - modifier final not allowed here




Page 28                                                    © Copyright by Interviewbit
-----------------------Page 29 End-----------------------

                                                                 Java Interview Questions




30.   Java works as “pass by value” or “pass by reference”
      phenomenon?
Java always works as a “pass by value”. There is nothing called a “pass by reference”
in Java. However, when the object is passed in any method, the address of the value
is passed due to the nature of object handling in Java. When an object is passed, a
copy of the reference is created by Java and that is passed to the method. The
objects point to the same memory location. 2 cases might happen inside the
method:
     Case 1: When the object is pointed to another location: In this case, the changes
     made to that object do not get reflected the original object before it was passed
     to the method as the reference points to another location.
For example:




Page 29                                                         © Copyright by Interviewbit
-----------------------Page 30 End-----------------------

                                                                   Java Interview Questions




  class InterviewBitTest{
     int num;
     InterviewBitTest(int x){
         num = x;
     }
     InterviewBitTest(){
         num = 0;
     }
  }
  class Driver {
     public static void main(String[] args)
     {
         //create a reference
         InterviewBitTest ibTestObj = new InterviewBitTest(20);
         //Pass the reference to updateObject Method
         updateObject(ibTestObj);
         //After the updateObject is executed, check for the value of num in the object.
         System.out.println(ibTestObj.num);
     }
     public static void updateObject(InterviewBitTest ibObj)
     {
         // Point the object to new reference
         ibObj = new InterviewBitTest();
         // Update the value
         ibObj.num = 50;
     }
  }
  Output:
  20


     Case 2: When object references are not modified: In this case, since we have the
     copy of reference the main object pointing to the same memory location, any
     changes in the content of the object get reflected in the original object.
For example:




Page 30                                                          © Copyright by Interviewbit
-----------------------Page 31 End-----------------------

                                                                   Java Interview Questions




  class InterviewBitTest{
     int num;
     InterviewBitTest(int x){
         num = x;
     }
     InterviewBitTest(){
         num = 0;
     }
  }
  class Driver{
     public static void main(String[] args)
     {
         //create a reference
         InterviewBitTest ibTestObj = new InterviewBitTest(20);
         //Pass the reference to updateObject Method
         updateObject(ibTestObj);
         //After the updateObject is executed, check for the value of num in the object.
         System.out.println(ibTestObj.num);
     }
     public static void updateObject(InterviewBitTest ibObj)
     {
         // no changes are made to point the ibObj to new location
         // Update the value of num
         ibObj.num = 50;
     }
  }
  Output:
  50



31.   Which among String or String Buﬀer should be preferred
      when there are lot of updates required to be done in the
      data?
StringBuﬀer is mutable and dynamic in nature whereas String is immutable. Every
updation / modification of String creates a new String thereby overloading the string
pool with unnecessary objects. Hence, in the cases of a lot of updates, it is always
preferred to use StringBuﬀer as it will reduce the overhead of the creation of multiple
String objects in the string pool.

32.   How to not allow serialization of attributes of a class in
      Java?




Page 31                                                          © Copyright by Interviewbit
-----------------------Page 32 End-----------------------

                                                                     Java Interview Questions



      In order to achieve this, the attribute can be declared along with the usage of
        transient keyword as shown below:


  public class InterviewBitExample {

      private transient String someInfo;
      private String name;
      private int id;
      // :
      // Getters setters
      // :
  }


      In the above example, all the fields except   someInfo    can be serialized.

33.   What happens if the static modifier is not included in the
      main method signature in Java?
There wouldn't be any compilation error. But then the program is run, since the JVM
cant map the main method signature, the code throws “NoSuchMethodError” error
at the runtime.

34.   What happens if there are multiple main methods inside one
      class in Java?
The program can't compile as the compiler says that the method has been already
defined inside the class.

35.   What do you understand by Object Cloning and how do you
      achieve it in Java?
      It is the process of creating an exact copy of any object. In order to support this,
      a java class has to implement the Cloneable interface of java.lang package and
      override the clone() method provided by the Object class the syntax of which is:

  protected Object clone() throws CloneNotSupportedException{
   return (Object)super.clone();
  }




Page 32                                                             © Copyright by Interviewbit
-----------------------Page 33 End-----------------------

                                                                    Java Interview Questions




     In case the Cloneable interface is not implemented and just the method is
     overridden, it results in CloneNotSupportedException in Java.

36.   How does an exception propagate in the code?
When an exception occurs, first it searches to locate the matching catch block. In
case, the matching catch block is located, then that block would be executed. Else,
the exception propagates through the method call stack and goes into the caller
method where the process of matching the catch block is performed. This
propagation happens until the matching catch block is found. If the match is not
found, then the program gets terminated in the main method.




37.   Is it mandatory for a catch block to be followed a er a try
      block?
No, it is not necessary for a catch block to be present a er a try block. - A try block
should be followed either by a catch block or by a finally block. If the exceptions
likelihood is more, then they should be declared using the throws clause of the
method.




Page 33                                                            © Copyright by Interviewbit
-----------------------Page 34 End-----------------------

                                                                  Java Interview Questions




38.   Will the finally block get executed when the return
      statement is written at the end of try block and catch block
      as shown below?

  public int someMethod(int i){
     try{
         //some statement
         return 1;
     }catch(Exception e){
         //some statement
         return 999;
     }finally{
         //finally block statements
     }
  }


finally block will be executed irrespective of the exception or not. The only case
where finally block is not executed is when it encounters ‘System.exit()’ method
anywhere in try/catch block.

39.   Can you call a constructor of a class inside the another
      constructor?
Yes, the concept can be termed as constructor chaining and can be achieved using
  this() .




Page 34                                                          © Copyright by Interviewbit
-----------------------Page 35 End-----------------------

                                                                      Java Interview Questions




40.   Contiguous memory locations are usually used for storing
      actual values in an array but not in ArrayList. Explain.
In the case of ArrayList, data storing in the form of primitive data types (like int, float,
etc.) is not possible. The data members/objects present in the ArrayList have
references to the objects which are located at various sites in the memory. Thus,
storing of actual objects or non-primitive data types (like Integer, Double, etc.) takes
place in various memory locations.




Page 35                                                             © Copyright by Interviewbit
-----------------------Page 36 End-----------------------

                                                                Java Interview Questions




However, the same does not apply to the arrays. Object or primitive type values can
be stored in arrays in contiguous memory locations, hence every element does not
require any reference to the next element.




Java Advanced Interview Questions



Page 36                                                        © Copyright by Interviewbit
-----------------------Page 37 End-----------------------

                                                                   Java Interview Questions




41.   Although inheritance is a popular OOPs concept, it is less
      advantageous than composition. Explain.
Inheritance lags behind composition in the following scenarios:
     Multiple-inheritance is not possible in Java. Classes can only extend from one
     superclass. In cases where multiple functionalities are required, for example - to
     read and write information into the file, the pattern of composition is preferred.
     The writer, as well as reader functionalities, can be made use of by considering
     them as the private members.
     Composition assists in attaining high flexibility and prevents breaking of
     encapsulation.
     Unit testing is possible with composition and not inheritance. When a developer
     wants to test a class composing a diﬀerent class, then Mock Object can be
     created for signifying the composed class to facilitate testing. This technique is
     not possible with the help of inheritance as the derived class cannot be tested
     without the help of the superclass in inheritance.
     The loosely coupled nature of composition is preferable over the tightly coupled
     nature of inheritance.
Let’s take an example:

  package comparison;
  public class Top {
  public int start() {
    return 0;
  }
  }
  class Bottom extends Top {
   public int stop() {
    return 0;
   }
  }


In the above example, inheritance is followed. Now, some modifications are done to
the Top class like this:




Page 37                                                           © Copyright by Interviewbit
-----------------------Page 38 End-----------------------

                                                                  Java Interview Questions




  public class Top {
   public int start() {
    return 0;
   }
   public void stop() {
   }
  }


If the new implementation of the Top class is followed, a compile-time error is bound
to occur in the Bottom class. Incompatible return type is there for the Top.stop()
function. Changes have to be made to either the Top or the Bottom class to ensure
compatibility. However, the composition technique can be utilized to solve the given
problem:

  class Bottom {
   Top par = new Top();
   public int stop() {
    par.start();
    par.stop();
    return 0;
   }
  }



42.   How is the creation of a String using new() diﬀerent from
      that of a literal?
When a String is formed as a literal with the assistance of an assignment operator, it
makes its way into the String constant pool so that String Interning can take place.
This same object in the heap will be referenced by a diﬀerent String if the content is
the same for both of them.

  public bool checking() {
  String first = "InterviewBit";
  String second = "InterviewBit";
  if (first == second)
   return true;
  else
   return false;
  }




Page 38                                                          © Copyright by Interviewbit
-----------------------Page 39 End-----------------------

                                                                 Java Interview Questions



The checking() function will return true as the same content is referenced by both the
variables.




Conversely, when a String formation takes place with the help of a new() operator,
interning does not take place. The object gets created in the heap memory even if
the same content object is present.

  public bool checking() {
  String first = new String("InterviewBit");
  String second = new String("InterviewBit");
  if (first == second)
   return true;
  else
   return false;
  }


The checking() function will return false as the same content is not referenced by
both the variables.




Page 39                                                         © Copyright by Interviewbit
-----------------------Page 40 End-----------------------

                                                                  Java Interview Questions




43.   Is exceeding the memory limit possible in a program despite
      having a garbage collector?
Yes, it is possible for the program to go out of memory in spite of the presence of a
garbage collector. Garbage collection assists in recognizing and eliminating those
objects which are not required in the program anymore, in order to free up the
resources used by them.
In a program, if an object is unreachable, then the execution of garbage collection
takes place with respect to that object. If the amount of memory required for
creating a new object is not suﬀicient, then memory is released for those objects
which are no longer in the scope with the help of a garbage collector. The memory
limit is exceeded for the program when the memory released is not enough for
creating new objects.
Moreover, exhaustion of the heap memory takes place if objects are created in such a
manner that they remain in the scope and consume memory. The developer should
make sure to dereference the object a er its work is accomplished. Although the
garbage collector endeavors its level best to reclaim memory as much as possible,
memory limits can still be exceeded.




Page 40                                                          © Copyright by Interviewbit
-----------------------Page 41 End-----------------------

                                                                  Java Interview Questions



Let’s take a look at the following example:

  List<String> example = new LinkedList<String>();
  while(true){
  example.add(new String("Memory Limit Exceeded"));
  }



44.   Why is synchronization necessary? Explain with the help of a
      relevant example.
Concurrent execution of diﬀerent processes is made possible by synchronization.
When a particular resource is shared between many threads, situations may arise in
which multiple threads require the same shared resource.
Synchronization assists in resolving the issue and the resource is shared by a single
thread at a time. Let’s take an example to understand it more clearly. For example,
you have a URL and you have to find out the number of requests made to it. Two
simultaneous requests can make the count erratic.
No synchronization:

  package anonymous;
  public class Counting {
         private int increase_counter;
         public int increase() {
                 increase_counter = increase_counter + 1;
                 return increase_counter;
         }
  }




Page 41                                                          © Copyright by Interviewbit
-----------------------Page 42 End-----------------------

                                                                 Java Interview Questions




If a thread Thread1 views the count as 10, it will be increased by 1 to 11.
Simultaneously, if another thread Thread2 views the count as 10, it will be increased
by 1 to 11. Thus, inconsistency in count values takes place because the expected final
value is 12 but the actual final value we get will be 11.
Now, the function increase() is made synchronized so that simultaneous accessing
cannot take place.
With synchronization:

  package anonymous;
  public class Counting {
         private int increase_counter;
         public synchronized int increase() {
                 increase_counter = increase_counter + 1;
                 return increase_counter;
         }
  }




Page 42                                                         © Copyright by Interviewbit
-----------------------Page 43 End-----------------------

                                                                   Java Interview Questions




If a thread Thread1 views the count as 10, it will be increased by 1 to 11, then the
thread Thread2 will view the count as 11, it will be increased by 1 to 12. Thus,
consistency in count values takes place.

45.   In the given code below, what is the significance of ... ?

  public void fooBarMethod(String... variables){
     // method code
  }


     Ability to provide ... is a feature called varargs (variable arguments) which
     was introduced as part of Java 5.
     The function having ... in the above example indicates that it can receive
     multiple arguments of the datatype String.
     For example, the fooBarMethod can be called in multiple ways and we can still
     have one method to process the data as shown below:




Page 43                                                           © Copyright by Interviewbit
-----------------------Page 44 End-----------------------

                                                                   Java Interview Questions




  fooBarMethod("foo", "bar");
  fooBarMethod("foo", "bar", "boo");
  fooBarMethod(new String[]{"foo", "var", "boo"});
  public void myMethod(String... variables){
     for(String variable : variables){
         // business logic
     }
  }



46.   Can you explain the Java thread lifecycle?
Java thread life cycle is as follows:
     New – When the instance of the thread is created and the start() method has not
     been invoked, the thread is considered to be alive and hence in the NEW state.
     Runnable – Once the start() method is invoked, before the run() method is
     called by JVM, the thread is said to be in RUNNABLE (ready to run) state. This
     state can also be entered from the Waiting or Sleeping state of the thread.
     Running – When the run() method has been invoked and the thread starts its
     execution, the thread is said to be in a RUNNING state.
     Non-Runnable (Blocked/Waiting) – When the thread is not able to run despite
     the fact of its aliveness, the thread is said to be in a NON-RUNNABLE state.
     Ideally, a er some time of its aliveness, the thread should go to a runnable state.
          A thread is said to be in a Blocked state if it wants to enter synchronized
          code but it is unable to as another thread is operating in that synchronized
          block on the same object. The first thread has to wait until the other thread
          exits the synchronized block.
          A thread is said to be in a Waiting state if it is waiting for the signal to
          execute from another thread, i.e it waits for work until the signal is
          received.
     Terminated – Once the run() method execution is completed, the thread is said
     to enter the TERMINATED step and is considered to not be alive.
The following flowchart clearly explains the lifecycle of the thread in Java.




Page 44                                                           © Copyright by Interviewbit
-----------------------Page 45 End-----------------------

                                                                 Java Interview Questions




47.   What could be the tradeoﬀ between the usage of an
      unordered array versus the usage of an ordered array?
     The main advantage of having an ordered array is the reduced search time
     complexity of O(log n) whereas the time complexity in an unordered array is
        O(n) .
     The main drawback of the ordered array is its increased insertion time which is
     O(n) due to the fact that its element has to reordered to maintain the order of
     array during every insertion whereas the time complexity in the unordered array
     is only O(1).
     Considering the above 2 key points and depending on what kind of scenario a
     developer requires, the appropriate data structure can be used for
     implementation.

48.   Is it possible to import the same class or package twice in
      Java and what happens to it during runtime?
It is possible to import a class or package more than once, however, it is redundant
because the JVM internally loads the package or class only once.




Page 45                                                         © Copyright by Interviewbit
-----------------------Page 46 End-----------------------

                                                                  Java Interview Questions




49.   In case a package has sub packages, will it suﬀice to import
      only the main package? e.g. Does importing of
      com.myMainPackage.* also import
      com.myMainPackage.mySubPackage.*?
This is a big NO. We need to understand that the importing of the sub-packages of a
package needs to be done explicitly. Importing the parent package only results in the
import of the classes within it and not the contents of its child/sub-packages.

50.   Will the finally block be executed if the code System.exit(0)
      is written at the end of try block?
NO. The control of the program post System.exit(0) is immediately gone and the
program gets terminated which is why the finally block never gets executed.

51.   What do you understand by marker interfaces in Java?
Marker interfaces, also known as tagging interfaces are those interfaces that have no
methods and constants defined in them. They are there for helping the compiler and
JVM to get run time-related information regarding the objects.

52.   Explain the term “Double Brace Initialisation” in Java?
This is a convenient means of initializing any collections in Java. Consider the below
example.




Page 46                                                          © Copyright by Interviewbit
-----------------------Page 47 End-----------------------

                                                                  Java Interview Questions




  import java.util.HashSet;
  import java.util.Set;

  public class IBDoubleBraceDemo{
     public static void main(String[] args){
         Set<String> stringSets = new HashSet<String>()
         {
             {
                 add("set1");
                 add("set2");
                 add("set3");
             }
         };

          doSomething(stringSets);
      }

      private static void doSomething(Set<String> stringSets){
          System.out.println(stringSets);
      }
  }


In the above example, we see that the stringSets were initialized by using double
braces.
      The first brace does the task of creating an anonymous inner class that has the
      capability of accessing the parent class’s behavior. In our example, we are
      creating the subclass of HashSet so that it can use the add() method of HashSet.
      The second braces do the task of initializing the instances.
Care should be taken while initializing through this method as the method involves
the creation of anonymous inner classes which can cause problems during the
garbage collection or serialization processes and may also result in memory leaks.

53.   Why is it said that the length() method of String class
      doesn't return accurate results?




Page 47                                                          © Copyright by Interviewbit
-----------------------Page 48 End-----------------------

                                                                  Java Interview Questions



     The length method returns the number of Unicode units of the String. Let's
     understand what Unicode units are and what is the confusion below.
     We know that Java uses UTF-16 for String representation. With this Unicode, we
     need to understand the below two Unicode related terms:
          Code Point: This represents an integer denoting a character in the code
          space.
          Code Unit: This is a bit sequence used for encoding the code points. In order
          to do this, one or more units might be required for representing a code
          point.
     Under the UTF-16 scheme, the code points were divided logically into 17 planes
     and the first plane was called the Basic Multilingual Plane (BMP). The BMP has
     classic characters - U+0000 to U+FFFF. The rest of the characters- U+10000 to
     U+10FFFF were termed as the supplementary characters as they were contained
     in the remaining planes.
          The code points from the first plane are encoded using one 16-bit code unit
          The code points from the remaining planes are encoded using two code
          units.
Now if a string contained supplementary characters, the length function would count
that as 2 units and the result of the length() function would not be as per what is
expected.
In other words, if there is 1 supplementary character of 2 units, the length of that
SINGLE character is considered to be TWO - Notice the inaccuracy here? As per the
java documentation, it is expected, but as per the real logic, it is inaccurate.

54.   What is the output of the below code and why?

  public class InterviewBit{
     public static void main(String[] args)
     {
         System.out.println('b' + 'i' + 't');
     }
  }




Page 48                                                         © Copyright by Interviewbit
-----------------------Page 49 End-----------------------

                                                                   Java Interview Questions



“bit” would have been the result printed if the letters were used in double-quotes (or
the string literals). But the question has the character literals (single quotes) being
used which is why concatenation wouldn't occur. The corresponding ASCII values of
each character would be added and the result of that sum would be printed.
The ASCII values of ‘b’, ‘i’, ‘t’ are:
     ‘b’ = 98
     ‘i’ = 105
     ‘t’ = 116
  98 + 105 + 116 = 319

Hence 319 would be printed.

55.   What are the possible ways of making object eligible for
      garbage collection (GC) in Java?
First Approach: Set the object references to null once the object creation purpose is
served.

  public class IBGarbageCollect {
    public static void main (String [] args){
         String s1 = "Some String";
             // s1 referencing String object - not yet eligible for GC
         s1 = null; // now s1 is eligible for GC
     }
   }


Second Approach: Point the reference variable to another object. Doing this, the
object which the reference variable was referencing before becomes eligible for GC.

  public class IBGarbageCollect {
   public static void main(String [] args){
       String s1 = "To Garbage Collect";
       String s2 = "Another Object";
       System.out.println(s1); // s1 is not yet eligible for GC
       s1 = s2; // Point s1 to other object pointed by s2
       /* Here, the string object having the content "To Garbage Collect" is not referre
   }
  }




Page 49                                                          © Copyright by Interviewbit
-----------------------Page 50 End-----------------------

                                                                   Java Interview Questions



Third Approach: Island of Isolation Approach: When 2 reference variables pointing to
instances of the same class, and these variables refer to only each other and the
objects pointed by these 2 variables don't have any other references, then it is said to
have formed an “Island of Isolation” and these 2 objects are eligible for GC.

  public class IBGarbageCollect {
     IBGarbageCollect ib;
     public static void main(String [] str){
         IBGarbageCollect ibgc1 = new IBGarbageCollect();
         IBGarbageCollect ibgc2 = new IBGarbageCollect();
         ibgc1.ib = ibgc2; //ibgc1 points to ibgc2
         ibgc2.ib = ibgc1; //ibgc2 points to ibgc1
         ibgc1 = null;
         ibgc2 = null;
         /*
         * We see that ibgc1 and ibgc2 objects refer
         * to only each other and have no valid
         * references- these 2 objects for island of isolcation - eligible for GC
         */
     }
  }




Java Interview Programs
56.   Check if a given string is palindrome using recursion.




Page 50                                                          © Copyright by Interviewbit
-----------------------Page 51 End-----------------------

                                                                    Java Interview Questions




  /*
  * Java program to check if a given inputted string is palindrome or not using recursion
  */
  import java.util.*;
  public class InterviewBit {
     public static void main(String args[]) {
         Scanner s = new Scanner(System.in);
         String word = s.nextLine();
         System.out.println("Is "+word+" palindrome? - "+isWordPalindrome(word));
     }


      public static boolean isWordPalindrome(String word){
          String reverseWord = getReverseWord(word);
          //if word equals its reverse, then it is a palindrome
          if(word.equals(reverseWord)){
              return true;
          }
          return false;
      }

      public static String getReverseWord(String word){
          if(word == null || word.isEmpty()){
              return word;
          }

          return word.charAt(word.length()- 1) + getReverseWord(word.substring(0, word.len
      }
  }



57.   Write a Java program to check if the two strings are
      anagrams.
The main idea is to validate the length of strings and then if found equal, convert the
string to char array and then sort the arrays and check if both are equal.




Page 51                                                           © Copyright by Interviewbit
-----------------------Page 52 End-----------------------

                                                                   Java Interview Questions




  import java.util.Arrays;
  import java.util.Scanner;
  public class InterviewBit {
   public static void main(String[] args) {
     Scanner s = new Scanner(System.in);
     //Input from two strings
     System.out.print("First String: ");
     String string1 = s.nextLine();
     System.out.print("Second String: ");
     String string2 = s.nextLine();
     // check for the length
     if(string1.length() == string2.length()) {
       // convert strings to char array
       char[] characterArray1 = string1.toCharArray();
       char[] characterArray2 = string2.toCharArray();
       // sort the arrays
       Arrays.sort(characterArray1);
       Arrays.sort(characterArray2);
       // check for equality, if found equal then anagram, else not an anagram
       boolean isAnagram = Arrays.equals(characterArray1, characterArray2);
       System.out.println("Anagram: "+ isAnagram);
   }
  }



58.   Write a Java Program to find the factorial of a given number.

  public class FindFactorial {
     public static void main(String[] args) {
         int num = 10;
         long factorialResult = 1l;
         for(int i = 1; i <= num; ++i)
         {
             factorialResult *= i;
         }
         System.out.println("Factorial: "+factorialResult);
     }
  }



59.   Given an array of non-duplicating numbers from 1 to n
      where one number is missing, write an eﬀicient java
      program to find that missing number.




Page 52                                                          © Copyright by Interviewbit
-----------------------Page 53 End-----------------------

                                                                      Java Interview Questions



Idea is to find the sum of n natural numbers using the formula and then finding the
sum of numbers in the given array. Subtracting these two sums results in the number
that is the actual missing number. This results in O(n) time complexity and O(1) space
complexity.

  public class IBMissingNumberProblem {

      public static void main(String[] args) {

          int[] array={4,3,8,7,5,2,6};
          int missingNumber = findMissingNum(array);
          System.out.println("Missing Number is "+ missingNumber);
      }

      public static int findMissingNum(int[] array) {
          int n=array.length+1;
          int sumOfFirstNNums=n*(n+1)/2;
          int actualSumOfArr=0;
          for (int i = 0; i < array.length; i++) {
              actualSumOfArr+=array[i];
          }
          return sumOfFirstNNums-actualSumOfArr;
      }
  }



60.   Write a Java Program to check if any number is a magic
      number or not. A number is said to be a magic number if
      a er doing sum of digits in each step and inturn doing sum
      of digits of that sum, the ultimate result (when there is only
      one digit le ) is 1.
Example, consider the number:
      Step 1: 163 => 1+6+3 = 10
      Step 2: 10 => 1+0 = 1 => Hence 163 is a magic number




Page 53                                                              © Copyright by Interviewbit
-----------------------Page 54 End-----------------------

                                                                 Java Interview Questions




  public class IBMagicNumber{

      public static void main(String[] args) {
          int num = 163;
          int sumOfDigits = 0;
          while (num > 0 || sumOfDigits > 9)
          {
              if (num == 0)
              {
                  num = sumOfDigits;
                  sumOfDigits = 0;
              }
              sumOfDigits += num % 10;
              num /= 10;
          }

          // If sum is 1, original number is magic number
          if(sumOfDigits == 1) {
              System.out.println("Magic number");
          }else {
              System.out.println("Not magic number");
          }
      }
  }




Conclusion
61.   Conclusion
Java is one of the simple high-level languages that provides powerful tools and
impressive standards required for application development. It was also one of the
first languages to provide amazing threading support for tackling concurrency-based
problems. The easy-to-use syntax and the built-in features of Java combined with the
stability it provides to applications are the main reasons for this language to have
ever-growing usage in the so ware community.
Join our community and share your java interview experiences.
Recommended tutorials:
Java Tutorial
Puzzles




Page 54                                                         © Copyright by Interviewbit
-----------------------Page 55 End-----------------------

                                   Java Interview Questions



Coding Interview Questions
Java 8 Interview Questions
How to Become a Java Developer?
Java Frameworks:
Spring
Hibernate
JAVA SE Download




Page 55                           © Copyright by Interviewbit
-----------------------Page 56 End-----------------------

Links to More Interview
Questions


 C Interview Questions         Php Interview Questions       C Sharp Interview Questions

 Web Api Interview             Hibernate Interview           Node Js Interview Questions
 Questions                     Questions

 Cpp Interview Questions       Oops Interview Questions      Devops Interview Questions

 Machine Learning Interview    Docker Interview Questions    Mysql Interview Questions
 Questions

 Css Interview Questions       Laravel Interview Questions   Asp Net Interview Questions

 Django Interview Questions    Dot Net Interview Questions   Kubernetes Interview
                                                             Questions

 Operating System Interview    React Native Interview        Aws Interview Questions
 Questions                     Questions

 Git Interview Questions       Java 8 Interview Questions    Mongodb Interview
                                                             Questions

 Dbms Interview Questions      Spring Boot Interview         Power Bi Interview Questions
                               Questions

 Pl Sql Interview Questions    Tableau Interview             Linux Interview Questions
                               Questions

 Ansible Interview Questions   Java Interview Questions      Jenkins Interview Questions




Page 56                                                            © Copyright by Interviewbit
-----------------------Page 57 End-----------------------

## Java Interview Questions Notes.txt

Java Interview Questions                                                                                                     1 / 30




Chapter 1

Object Oriented Programming (OOP)

Java is a computer programming language that is concurrent, class-based and object-oriented. The advantages of object oriented
software development are shown below:

• Modular development of code, which leads to easy maintenance and modification.
• Reusability of code.
• Improved reliability and flexibility of code.
• Increased understanding of code.

Object-oriented programming contains many significant features, such as encapsulation, inheritance, polymorphism and ab-
straction. We analyze each feature separately in the following sections.


1.1     Encapsulation

Encapsulation provides objects with the ability to hide their internal characteristics and behavior. Each object provides a number
of methods, which can be accessed by other objects and change its internal data. In Java, there are three access modifiers: public,
private and protected. Each modifier imposes different access rights to other classes, either in the same or in external packages.
Some of the advantages of using encapsulation are listed below:

• The internal state of every objected is protected by hiding its attributes.
• It increases usability and maintenance of code, because the behavior of an object can be independently changed or extended.
• It improves modularity by preventing objects to interact with each other, in an undesired way.

You can refer to our tutorial here for more details and examples on encapsulation.


1.2     Polymorphism

Polymorphism is the ability of programming languages to present the same interface for differing underlying data types. A
polymorphic type is a type whose operations can also be applied to values of some other type.


1.3     Inheritance

Inheritance provides an object with the ability to acquire the fields and methods of another class, called base class. Inheritance
provides re-usability of code and can be used to add additional features to an existing class, without modifying it.
-----------------------Page 1 End-----------------------

Java Interview Questions                                                                                                       2 / 30




1.4     Abstraction

Abstraction is the process of separating ideas from specific instances and thus, develop classes in terms of their own functionality,
instead of their implementation details. Java supports the creation and existence of abstract classes that expose interfaces, without
including the actual implementation of all methods. The abstraction technique aims to separate the implementation details of a
class from its behavior.


1.5     Differences between Abstraction and Encapsulation

Abstraction and encapsulation are complementary concepts. On the one hand, abstraction focuses on the behavior of an object.
On the other hand, encapsulation focuses on the implementation of an object’s behavior. Encapsulation is usually achieved by
hiding information about the internal state of an object and thus, can be seen as a strategy used in order to provide abstraction.
-----------------------Page 2 End-----------------------

Java Interview Questions                                                                                                       3 / 30




Chapter 2


General Questions about Java


2.1     What is JVM ? Why is Java called the Platform Independent Programming Lan-
        guage?

A Java virtual machine (JVM) is a process virtual machine that can execute Java bytecode. Each Java source file is compiled
into a bytecode file, which is executed by the JVM. Java was designed to allow application programs to be built that could be
run on any platform, without having to be rewritten or recompiled by the programmer for each separate platform. A Java virtual
machine makes this possible, because it is aware of the specific instruction lengths and other particularities of the underlying
hardware platform.


2.2     What is the Difference between JDK and JRE ?

The Java Runtime Environment (JRE) is basically the Java Virtual Machine (JVM) where your Java programs are being executed.
It also includes browser plugins for applet execution. The Java Development Kit (JDK) is the full featured Software Development
Kit for Java, including the JRE, the compilers and tools (like JavaDoc, and Java Debugger), in order for a user to develop, compile
and execute Java applications.


2.3     What does the “static” keyword mean ? Can you override private or static
        method in Java ?

The static keyword denotes that a member variable or method can be accessed, without requiring an instantiation of the class to
which it belongs. A user cannot override static methods in Java, because method overriding is based upon dynamic binding at
runtime and static methods are statically binded at compile time. A static method is not associated with any instance of a class
so the concept is not applicable.


2.4     Can you access non static variable in static context ?

A static variable in Java belongs to its class and its value remains the same for all its instances. A static variable is initialized
when the class is loaded by the JVM. If your code tries to access a non-static variable, without any instance, the compiler will
complain, because those variables are not created yet and they are not associated with any instance.
-----------------------Page 3 End-----------------------

Java Interview Questions                                                                                                    4 / 30




2.5       What are the Data Types supported by Java ? What is Autoboxing and Unbox-
          ing ?

The eight primitive data types supported by the Java programming language are:

• byte
• short
• int
• long
• float
• double
• boolean
• char

Autoboxing is the automatic conversion made by the Java compiler between the primitive types and their corresponding object
wrapper classes. For example, the compiler converts an int to an Integer, a double to a Double, and so on. If the conversion goes
the other way, this operation is called unboxing.


2.6       What is Function Overriding and Overloading in Java ?

Method overloading in Java occurs when two or more methods in the same class have the exact same name, but different
parameters. On the other hand, method overriding is defined as the case when a child class redefines the same method as a parent
class. Overridden methods must have the same name, argument list, and return type. The overriding method may not limit the
access of the method it overrides.


2.7       What is a Constructor, Constructor Overloading in Java and Copy-Constructor

A constructor gets invoked when a new object is created. Every class has a constructor. In case the programmer does not provide
a constructor for a class, the Java compiler (Javac) creates a default constructor for that class. The constructor overloading is
similar to method overloading in Java. Different constructors can be created for a single class. Each constructor must have its
own unique parameter list. Finally, Java does support copy constructors like C++, but the difference lies in the fact that Java
doesn’t create a default copy constructor if you don’t write your own.


2.8       Does Java support multiple inheritance ?

No, Java does not support multiple inheritance. Each class is able to extend only on one class, but is able to implement more than
one interfaces.


2.9       What is the difference between an Interface and an Abstract class ?

Java provides and supports the creation both of abstract classes and interfaces. Both implementations share some common
characteristics, but they differ in the following features:

• All methods in an interface are implicitly abstract. On the other hand, an abstract class may contain both abstract and non-
  abstract methods.
-----------------------Page 4 End-----------------------

Java Interview Questions                                                                                                      5 / 30



• A class may implement a number of Interfaces, but can extend only one abstract class.
• In order for a class to implement an interface, it must implement all its declared methods. However, a class may not implement
  all declared methods of an abstract class. Though, in this case, the sub-class must also be declared as abstract.

• Abstract classes can implement interfaces without even providing the implementation of interface methods.
• Variables declared in a Java interface is by default final. An abstract class may contain non-final variables.
• Members of a Java interface are public by default. A member of an abstract class can either be private, protected or public.
• An interface is absolutely abstract and cannot be instantiated. An abstract class also cannot be instantiated, but can be invoked
  if it contains a main method.

Also check out the Abstract class and Interface differences for JDK 8.


2.10     What are pass by reference and pass by value ?

When an object is passed by value, this means that a copy of the object is passed. Thus, even if changes are made to that object,
it doesn’t affect the original value. When an object is passed by reference, this means that the actual object is not passed, rather
a reference of the object is passed. Thus, any changes made by the external method, are also reflected in all places.
-----------------------Page 5 End-----------------------

Java Interview Questions                                                                                                    6 / 30




Chapter 3


Java Threads


3.1     What is the difference between processes and threads ?

A process is an execution of a program, while a Thread is a single execution sequence within a process. A process can contain
multiple threads. A Thread is sometimes called a lightweight process.


3.2     Explain different ways of creating a thread. Which one would you prefer and
        why ?

There are three ways that can be used in order for a Thread to be created:

• A class may extend the Thread class.
• A class may implement the Runnable interface.
• An application can use the Executor framework, in order to create a thread pool.

The Runnable interface is preferred, as it does not require an object to inherit the Thread class. In case your application design
requires multiple inheritance, only interfaces can help you. Also, the thread pool is very efficient and can be implemented and
used very easily.


3.3     Explain the available thread states in a high-level.

During its execution, a thread can reside in one of the following states:

• Runnable: A thread becomes ready to run, but does not necessarily start running immediately.
• Running: The processor is actively executing the thread code.

• Waiting: A thread is in a blocked state waiting for some external processing to finish.
• Sleeping: The thread is forced to sleep.
• Blocked on I/O: Waiting for an I/O operation to complete.
• Blocked on Synchronization: Waiting to acquire a lock.

• Dead: The thread has finished its execution.
-----------------------Page 6 End-----------------------

Java Interview Questions                                                                                                   7 / 30




3.4    What is the difference between a synchronized method and a synchronized
       block ?

In Java programming, each object has a lock. A thread can acquire the lock for an object by using the synchronized keyword.
The synchronized keyword can be applied in a method level (coarse grained lock) or block level of code (fine grained lock).


3.5    How does thread synchronization occurs inside a monitor ? What levels of
       synchronization can you apply ?

The JVM uses locks in conjunction with monitors. A monitor is basically a guardian that watches over a sequence of synchronized
code and ensuring that only one thread at a time executes a synchronized piece of code. Each monitor is associated with an object
reference. The thread is not allowed to execute the code until it obtains the lock.


3.6    What’s a deadlock ?

A condition that occurs when two processes are waiting for each other to complete, before proceeding. The result is that both
processes wait endlessly.


3.7    How do you ensure that N threads can access N resources without deadlock ?

A very simple way to avoid deadlock while using N threads is to impose an ordering on the locks and force each thread to follow
that ordering. Thus, if all threads lock and unlock the mutexes in the same order, no deadlocks can arise.
-----------------------Page 7 End-----------------------

Java Interview Questions                                                                                                       8 / 30




Chapter 4

Java Collections


4.1     What are the basic interfaces of Java Collections Framework ?

Java Collections Framework provides a well designed set of interfaces and classes that support operations on a collections of
objects. The most basic interfaces that reside in the Java Collections Framework are:

• Collection, which represents a group of objects known as its elements.
• Set, which is a collection that cannot contain duplicate elements.
• List, which is an ordered collection and can contain duplicate elements.
• Map, which is an object that maps keys to values and cannot contain duplicate keys.


4.2     Why Collection doesn’t extend Cloneable and Serializable interfaces ?

The Collection interface specifies groups of objects known as elements. Each concrete implementation of a Collection can choose
its own way of how to maintain and order its elements. Some collections allow duplicate keys, while some other collections don’t.
The semantics and the implications of either cloning or serialization come into play when dealing with actual implementations.
Thus, the concrete implementations of collections should decide how they can be cloned or serialized.


4.3     What is an Iterator ?

The Iterator interface provides a number of methods that are able to iterate over any Collection. Each Java Collection contains
the iterator method that returns an Iterator instance. Iterators are capable of removing elements from the underlying collection
during the iteration.


4.4     What differences exist between Iterator and ListIterator ?

The differences of these elements are listed below:

• An Iterator can be used to traverse the Set and List collections, while the ListIterator can be used to iterate only over Lists.
• The Iterator can traverse a collection only in forward direction, while the ListIterator can traverse a List in both directions.
• The ListIterator implements the Iterator interface and contains extra functionality, such as adding an element, replacing an
  element, getting the index position for previous and next elements, etc.
-----------------------Page 8 End-----------------------

Java Interview Questions                                                                                                        9 / 30




4.5     What is difference between fail-fast and fail-safe ?

The Iterator’s fail-safe property works with the clone of the underlying collection and thus, it is not affected by any modification
in the collection. All the collection classes in java.util package are fail-fast, while the collection classes in java.util.concurrent
are fail-safe. Fail-fast iterators throw a ConcurrentModificationException, while fail-safe iterator never throws such
an exception.


4.6     How HashMap works in Java ?

A HashMap in Java stores key-value pairs. The HashMap requires a hash function and uses hashCode and equals methods,
in order to put and retrieve elements to and from the collection respectively. When the put method is invoked, the HashMap
calculates the hash value of the key and stores the pair in the appropriate index inside the collection. If the key exists, its value
is updated with the new value. Some important characteristics of a HashMap are its capacity, its load factor and the threshold
resizing.


4.7     What is the importance of hashCode() and equals() methods ?

In Java, a HashMap uses the hashCode and equals methods to determine the index of the key-value pair and to detect duplicates.
More specifically, the hashCode method is used in order to determine where the specified key will be stored. Since different keys
may produce the same hash value, the equals method is used, in order to determine whether the specified key actually exists in
the collection or not. Therefore, the implementation of both methods is crucial to the accuracy and efficiency of the HashMap.


4.8     What differences exist between HashMap and Hashtable ?

Both the HashMap and Hashtable classes implement the Map interface and thus, have very similar characteristics. However, they
differ in the following features:

• A HashMap allows the existence of null keys and values, while a Hashtable doesn’t allow neither null keys, nor null values.
• A Hashtable is synchronized, while a HashMap is not. Thus, HashMap is preferred in single-threaded environments, while a
  Hashtable is suitable for multi-threaded environments.

• A HashMap provides its set of keys and a Java application can iterate over them. Thus, a HashMap is fail-fast. On the other
  hand, a Hashtable provides an Enumeration of its keys.
• The Hashtable class is considered to be a legacy class.


4.9     What is difference between Array and ArrayList ? When will you use Array over
        ArrayList ?

The Array and ArrayList classes differ on the following features:

• Arrays can contain primitive or objects, while an ArrayList can contain only objects.

• Arrays have fixed size, while an ArrayList is dynamic.
• An ArrayList provides more methods and features, such as addAll, removeAll, iterator, etc.
• For a list of primitive data types, the collections use autoboxing to reduce the coding effort. However, this approach makes
  them slower when working on fixed size primitive data types.
-----------------------Page 9 End-----------------------

Java Interview Questions                                                                                                       10 / 30




4.10      What is difference between ArrayList and LinkedList ?

Both the ArrayList and LinkedList classes implement the List interface, but they differ on the following features:

• An ArrayList is an index based data structure backed by an Array. It provides random access to its elements with a performance
  equal to O(1). On the other hand, a LinkedList stores its data as list of elements and every element is linked to its previous and
  next element. In this case, the search operation for an element has execution time equal to O(n).
• The Insertion, addition and removal operations of an element are faster in a LinkedList compared to an ArrayList, because
  there is no need of resizing an array or updating the index when an element is added in some arbitrary position inside the
  collection.
• A LinkedList consumes more memory than an ArrayList, because every node in a LinkedList stores two references, one for its
  previous element and one for its next element.

Check also our article ArrayList vs. LinkedList.


4.11      What is Comparable and Comparator interface ? List their differences.

Java provides the Comparable interface, which contains only one method, called compareTo. This method compares two objects,
in order to impose an order between them. Specifically, it returns a negative integer, zero, or a positive integer to indicate that the
input object is less than, equal or greater than the existing object. Java provides the Comparator interface, which contains two
methods, called compare and equals. The first method compares its two input arguments and imposes an order between them.
It returns a negative integer, zero, or a positive integer to indicate that the first argument is less than, equal to, or greater than
the second. The second method requires an object as a parameter and aims to decide whether the input object is equal to the
comparator. The method returns true, only if the specified object is also a comparator and it imposes the same ordering as the
comparator.


4.12      What is Java Priority Queue ?

The PriorityQueue is an unbounded queue, based on a priority heap and its elements are ordered in their natural order. At the time
of its creation, we can provide a Comparator that is responsible for ordering the elements of the PriorityQueue. A PriorityQueue
doesn’t allow null values, those objects that doesn’t provide natural ordering, or those objects that don’t have any comparator
associated with them. Finally, the Java PriorityQueue is not thread-safe and it requires O(log(n)) time for its enqueing and
dequeing operations.


4.13      What do you know about the big-O notation and can you give some examples
          with respect to different data structures ?

The Big-O notation simply describes how well an algorithm scales or performs in the worst case scenario as the number of ele-
ments in a data structure increases. The Big-O notation can also be used to describe other behavior such as memory consumption.
Since the collection classes are actually data structures, we usually use the Big-O notation to chose the best implementation to
use, based on time, memory and performance. Big-O notation can give a good indication about performance for large amounts
of data.


4.14      What is the tradeoff between using an unordered array versus an ordered
          array ?

The major advantage of an ordered array is that the search times have time complexity of O(log n), compared to that of an
unordered array, which is O (n). The disadvantage of an ordered array is that the insertion operation has a time complexity of
O(n), because the elements with higher values must be moved to make room for the new element. Instead, the insertion operation
for an unordered array takes constant time of O(1).
-----------------------Page 10 End-----------------------

Java Interview Questions                                                                                                     11 / 30




4.15     What are some of the best practices relating to the Java Collection framework
         ?

• Choosing the right type of the collection to use, based on the application’s needs, is very crucial for its performance. For
  example if the size of the elements is fixed and know a priori, we shall use an Array, instead of an ArrayList.
• Some collection classes allow us to specify their initial capacity. Thus, if we have an estimation on the number of elements
  that will be stored, we can use it to avoid rehashing or resizing.
• Always use Generics for type-safety, readability, and robustness. Also, by using Generics you avoid the ClassCastException
  during runtime.
• Use immutable classes provided by the Java Development Kit (JDK) as a key in a Map, in order to avoid the implementation
  of the hashCode and equals methods for our custom class.
• Program in terms of interface not implementation.

• Return zero-length collections or arrays as opposed to returning a null in case the underlying collection is actually empty.


4.16     What’s the difference between Enumeration and Iterator interfaces ?

Enumeration is twice as fast as compared to an Iterator and uses very less memory. However, the Iterator is much safer compared
to Enumeration, because other threads are not able to modify the collection object that is currently traversed by the iterator. Also,
Iteratorsallow the caller to remove elements from the underlying collection, something which is not possible with Enumerations.


4.17     What is the difference between HashSet and TreeSet ?

The HashSet is Implemented using a hash table and thus, its elements are not ordered. The add, remove, and contains methods of
a HashSet have constant time complexity O(1). On the other hand, a TreeSet is implemented using a tree structure. The elements
in a TreeSet are sorted, and thus, the add, remove, and contains methods have time complexity of O(logn).
-----------------------Page 11 End-----------------------

Java Interview Questions                                                                                                    12 / 30




Chapter 5


Garbage Collectors


5.1     What is the purpose of garbage collection in Java, and when is it used ?

The purpose of garbage collection is to identify and discard those objects that are no longer needed by the application, in order
for the resources to be reclaimed and reused.


5.2     What does System.gc() and Runtime.gc() methods do ?

These methods can be used as a hint to the JVM, in order to start a garbage collection. However, this it is up to the Java Virtual
Machine (JVM) to start the garbage collection immediately or later in time.


5.3     When is the finalize() called ? What is the purpose of finalization ?

The finalize method is called by the garbage collector, just before releasing the object’s memory. It is normally advised to release
resources held by the object inside the finalize method.


5.4     If an object reference is set to null, will the Garbage Collector immediately free
        the memory held by that object ?

No, the object will be available for garbage collection in the next cycle of the garbage collector.


5.5     What is structure of Java Heap ? What is Perm Gen space in Heap ?

The JVM has a heap that is the runtime data area from which memory for all class instances and arrays is allocated. It is created
at the JVM start-up. Heap memory for objects is reclaimed by an automatic memory management system which is known as a
garbage collector. Heap memory consists of live and dead objects. Live objects are accessible by the application and will not
be a subject of garbage collection. Dead objects are those which will never be accessible by the application, but have not been
collected by the garbage collector yet. Such objects occupy the heap memory space until they are eventually collected by the
garbage collector.
-----------------------Page 12 End-----------------------

Java Interview Questions                                                                                                     13 / 30




5.6     What is the difference between Serial and Throughput Garbage collector ?

The throughput garbage collector uses a parallel version of the young generation collector and is meant to be used with applica-
tions that have medium to large data sets. On the other hand, the serial collector is usually adequate for most small applications
(those requiring heaps of up to approximately 100MB on modern processors).


5.7     When does an Object becomes eligible for Garbage collection in Java ?

A Java object is subject to garbage collection when it becomes unreachable to the program in which it is currently used.


5.8     Does Garbage collection occur in permanent generation space in JVM ?

Garbage Collection does occur in PermGen space and if PermGen space is full or cross a threshold, it can trigger a full garbage
collection. If you look carefully at the output of the garbage collector, you will find that PermGen space is also garbage collected.
This is the reason why correct sizing of PermGen space is important to avoid frequent full garbage collections. Also check our
article Java 8: PermGen to Metaspace.
-----------------------Page 13 End-----------------------

Java Interview Questions                                                                                                    14 / 30




Chapter 6


Exception Handling


6.1    What are the two types of Exceptions in Java ? Which are the differences
       between them ?

Java has two types of exceptions: checked exceptions and unchecked exceptions. Unchecked exceptions do not need to be
declared in a method or a constructor’s throws clause, if they can be thrown by the execution of the method or the constructor,
and propagate outside the method or constructor boundary. On the other hand, checked exceptions must be declared in a method
or a constructor’s throws clause. See here for tips on Java exception handling.


6.2    What is the difference between Exception and Error in java ?

Exception and Error classes are both subclasses of the Throwable class. The Exception class is used for exceptional conditions
that a user’s program should catch. The Error class defines exceptions that are not excepted to be caught by the user program.


6.3    What is the difference between throw and throws ?

The throw keyword is used to explicitly raise a exception within the program. On the contrary, the throws clause is used to
indicate those exceptions that are not handled by a method. Each method must explicitly specify which exceptions does not
handle, so the callers of that method can guard against possible exceptions. Finally, multiple exceptions are separated by a
comma.


6.4    What is the importance of finally block in exception handling ?

A finally block will always be executed, whether or not an exception is actually thrown. Even in the case where the catch
statement is missing and an exception is thrown, the finally block will still be executed. Last thing to mention is that the finally
block is used to release resources like I/O buffers, database connections, etc.


6.5    What will happen to the Exception object after exception handling ?

The Exception object will be garbage collected in the next garbage collection.
-----------------------Page 14 End-----------------------

Java Interview Questions                                                                                                  15 / 30




6.6    How does finally block differ from finalize() method ?

A finally block will be executed whether or not an exception is thrown and is used to release those resources held by the
application. Finalize is a protected method of the Object class, which is called by the Java Virtual Machine (JVM) just before an
object is garbage collected.
-----------------------Page 15 End-----------------------

Java Interview Questions                                                                                                            16 / 30




Chapter 7

Java Applets


7.1     What is an Applet ?

A java applet is program that can be included in a HTML page and be executed in a java enabled client browser. Applets are used
for creating dynamic and interactive web applications.


7.2     Explain the life cycle of an Applet.

An applet may undergo the following states:

• Init: An applet is initialized each time is loaded.
• Start: Begin the execution of an applet.
• Stop: Stop the execution of an applet.
• Destroy: Perform a final cleanup, before unloading the applet.


7.3     What happens when an applet is loaded ?

First of all, an instance of the applet’s controlling class is created. Then, the applet initializes itself and finally, it starts running.


7.4     What is the difference between an Applet and a Java Application ?

Applets are executed within a java enabled browser, but a Java application is a standalone Java program that can be executed
outside of a browser. However, they both require the existence of a Java Virtual Machine (JVM). Furthermore, a Java application
requires a main method with a specific signature, in order to start its execution. Java applets don’t need such a method to start
their execution. Finally, Java applets typically use a restrictive security policy, while Java applications usually use more relaxed
security policies.


7.5     What are the restrictions imposed on Java applets ?

Mostly due to security reasons, the following restrictions are imposed on Java applets:

• An applet cannot load libraries or define native methods.
-----------------------Page 16 End-----------------------

Java Interview Questions                                                                                                      17 / 30



• An applet cannot ordinarily read or write files on the execution host.
• An applet cannot read certain system properties.
• An applet cannot make network connections except to the host that it came from.

• An applet cannot start any program on the host that’s executing it.


7.6     What are untrusted applets ?

Untrusted applets are those Java applets that cannot access or execute local system files. By default, all downloaded applets are
considered as untrusted.


7.7     What is the difference between applets loaded over the internet and applets
        loaded via the file system ?

Regarding the case where an applet is loaded over the internet, the applet is loaded by the applet classloader and is subject to the
restrictions enforced by the applet security manager. Regarding the case where an applet is loaded from the client’s local disk,
the applet is loaded by the file system loader. Applets loaded via the file system are allowed to read files, write files and to load
libraries on the client. Also, applets loaded via the file system are allowed to execute processes and finally, applets loaded via the
file system are not passed through the byte code verifier.


7.8     What is the applet class loader, and what does it provide ?

When an applet is loaded over the internet, the applet is loaded by the applet classloader. The class loader enforces the Java name
space hierarchy. Also, the class loader guarantees that a unique namespace exists for classes that come from the local file system,
and that a unique namespace exists for each network source. When a browser loads an applet over the net, that applet’s classes
are placed in a private namespace associated with the applet’s origin. Then, those classes loaded by the class loader are passed
through the verifier.The verifier checks that the class file conforms to the Java language specification . Among other things, the
verifier ensures that there are no stack overflows or underflows and that the parameters to all bytecode instructions are correct.


7.9     What is the applet security manager, and what does it provide ?

The applet security manager is a mechanism to impose restrictions on Java applets. A browser may only have one security
manager. The security manager is established at startup, and it cannot thereafter be replaced, overloaded, overridden, or extended.
-----------------------Page 17 End-----------------------

Java Interview Questions                                                                                                  18 / 30




Chapter 8

Swing


8.1    What is the difference between a Choice and a List ?

A Choice is displayed in a compact form that must be pulled down, in order for a user to be able to see the list of all available
choices. Only one item may be selected from a Choice. A List may be displayed in such a way that several List items are visible.
A List supports the selection of one or more List items.


8.2    What is a layout manager ?

A layout manager is the used to organize the components in a container.


8.3    What is the difference between a Scrollbar and a JScrollPane ?

A Scrollbar is a Component, but not a Container. A ScrollPane is a Container. A ScrollPane handles its own events and performs
its own scrolling.


8.4    Which Swing methods are thread-safe ?

There are only three thread-safe methods: repaint, revalidate, and invalidate.


8.5    Name three Component subclasses that support painting.

The Canvas, Frame, Panel, and Applet classes support painting.


8.6    What is clipping ?

Clipping is defined as the process of confining paint operations to a limited area or shape.


8.7    What is the difference between a MenuItem and a CheckboxMenuItem ?

The CheckboxMenuItem class extends the MenuItem class and supports a menu item that may be either checked or unchecked.
-----------------------Page 18 End-----------------------

Java Interview Questions                                                                                                19 / 30




8.8    How are the elements of a BorderLayout organized ?

The elements of a BorderLayout are organized at the borders (North, South, East, and West) and the center of a container.


8.9    How are the elements of a GridBagLayout organized ?

The elements of a GridBagLayout are organized according to a grid. The elements are of different sizes and may occupy more
than one row or column of the grid. Thus, the rows and columns may have different sizes.


8.10     What is the difference between a Window and a Frame ?

The Frame class extends the Window class and defines a main application window that can have a menu bar.


8.11     What is the relationship between clipping and repainting ?

When a window is repainted by the AWT painting thread, it sets the clipping regions to the area of the window that requires
repainting.


8.12     What is the relationship between an event-listener interface and an event-
         adapter class ?

An event-listener interface defines the methods that must be implemented by an event handler for a particular event. An event
adapter provides a default implementation of an event-listener interface.


8.13     How can a GUI component handle its own events ?

A GUI component can handle its own events, by implementing the corresponding event-listener interface and adding itself as its
own event listener.


8.14     What advantage do Java’s layout managers provide over traditional window-
         ing systems ?

Java uses layout managers to lay out components in a consistent manner, across all windowing platforms. Since layout man-
agers aren’t tied to absolute sizing and positioning, they are able to accomodate platform-specific differences among windowing
systems.


8.15     What is the design pattern that Java uses for all Swing components ?

The design pattern used by Java for all Swing components is the Model View Controller (MVC) pattern.
-----------------------Page 19 End-----------------------

Java Interview Questions                                                                                               20 / 30




Chapter 9


JDBC


9.1    What is JDBC ?

JDBC is an abstraction layer that allows users to choose between databases. JDBC enables developers to write database applica-
tions in Java, without having to concern themselves with the underlying details of a particular database.


9.2    Explain the role of Driver in JDBC.

The JDBC Driver provides vendor-specific implementations of the abstract classes provided by the JDBC API. Each driver
must provide implementations for the following classes of the java.sql package:Connection, Statement, PreparedStatement,
CallableStatement, ResultSet and Driver.


9.3    What is the purpose Class.forName method ?

This method is used to method is used to load the driver that will establish a connection to the database.


9.4    What is the advantage of PreparedStatement over Statement ?

PreparedStatements are precompiled and thus, their performance is much better. Also, PreparedStatement objects can be reused
with different input values to their queries.


9.5    What is the use of CallableStatement ? Name the method, which is used to
       prepare a CallableStatement.

A CallableStatement is used to execute stored procedures. Stored procedures are stored and offered by a database. Stored
procedures may take input values from the user and may return a result. The usage of stored procedures is highly encouraged,
because it offers security and modularity.The method that prepares a CallableStatement is the following: CallableStament.
prepareCall();
-----------------------Page 20 End-----------------------

Java Interview Questions                                                                                                    21 / 30




9.6    What does Connection pooling mean ?

The interaction with a database can be costly, regarding the opening and closing of database connections. Especially, when the
number of database clients increases, this cost is very high and a large number of resources is consumed.A pool of database
connections is obtained at start up by the application server and is maintained in a pool. A request for a connection is served by a
connection residing in the pool. In the end of the connection, the request is returned to the pool and can be used to satisfy future
requests.
-----------------------Page 21 End-----------------------

Java Interview Questions                                                                                                   22 / 30




Chapter 10


Remote Method Invocation (RMI)


10.1     What is RMI ?

The Java Remote Method Invocation (Java RMI) is a Java API that performs the object-oriented equivalent of remote procedure
calls (RPC), with support for direct transfer of serialized Java classes and distributed garbage collection. Remote Method Invoca-
tion (RMI) can also be seen as the process of activating a method on a remotely running object. RMI offers location transparency
because a user feels that a method is executed on a locally running object. Check some RMI Tips here.


10.2     What is the basic principle of RMI architecture ?

The RMI architecture is based on a very important principle which states that the definition of the behavior and the implemen-
tation of that behavior, are separate concepts. RMI allows the code that defines the behavior and the code that implements the
behavior to remain separate and to run on separate JVMs.


10.3     What are the layers of RMI Architecture ?

The RMI architecture consists of the following layers:

• Stub and Skeleton layer: This layer lies just beneath the view of the developer. This layer is responsible for intercepting
  method calls made by the client to the interface and redirect these calls to a remote RMI Service.

• Remote Reference Layer: The second layer of the RMI architecture deals with the interpretation of references made from
  the client to the server’s remote objects. This layer interprets and manages references made from clients to the remote service
  objects. The connection is a one-to-one (unicast) link.
• Transport layer: This layer is responsible for connecting the two JVM participating in the service. This layer is based on
  TCP/IP connections between machines in a network. It provides basic connectivity, as well as some firewall penetration
  strategies.


10.4     What is the role of Remote Interface in RMI ?

The Remote interface serves to identify interfaces whose methods may be invoked from a non-local virtual machine. Any object
that is a remote object must directly or indirectly implement this interface. A class that implements a remote interface should
declare the remote interfaces being implemented, define the constructor for each remote object and provide an implementation
for each remote method in all remote interfaces.
-----------------------Page 22 End-----------------------

Java Interview Questions                                                                                                    23 / 30




10.5      What is the role of the java.rmi.Naming Class ?

The java.rmi.Naming class provides methods for storing and obtaining references to remote objects in the remote object registry.
Each method of the Naming class takes as one of its arguments a name that is a String in URL format.


10.6      What is meant by binding in RMI ?

Binding is the process of associating or registering a name for a remote object, which can be used at a later time, in order to look
up that remote object. A remote object can be associated with a name using the bind or rebind methods of the Naming class.


10.7      What is the difference between using bind() and rebind() methods of Naming
          Class ?

The bind method bind is responsible for binding the specified name to a remote object, while the rebind method is responsible
for rebinding the specified name to a new remote object. In case a binding exists for that name, the binding is replaced.


10.8      What are the steps involved to make work a RMI program ?

The following steps must be involved in order for a RMI program to work properly:

• Compilation of all source files.
• Generatation of the stubs using rmic.
• Start the rmiregistry.
• Start the RMIServer.
• Run the client program.


10.9      What is the role of stub in RMI ?

A stub for a remote object acts as a client’s local representative or proxy for the remote object. The caller invokes a method on
the local stub, which is responsible for executing the method on the remote object. When a stub’s method is invoked, it undergoes
the following steps:

• It initiates a connection to the remote JVM containing the remote object.
• It marshals the parameters to the remote JVM.
• It waits for the result of the method invocation and execution.
• It unmarshals the return value or an exception if the method has not been successfully executed.
• It returns the value to the caller.


10.10       What is DGC ? And how does it work ?

DGC stands for Distributed Garbage Collection. Remote Method Invocation (RMI) uses DGC for automatic garbage collection.
Since RMI involves remote object references across JVM’s, garbage collection can be quite difficult. DGC uses a reference
counting algorithm to provide automatic memory management for remote objects.
-----------------------Page 23 End-----------------------

Java Interview Questions                                                                                                      24 / 30




10.11      What is the purpose of using RMISecurityManager in RMI ?

RMISecurityManager provides a security manager that can be used by RMI applications, which use downloaded code. The class
loader of RMI will not download any classes from remote locations, if the security manager has not been set.


10.12      Explain Marshalling and demarshalling.

When an application wants to pass its memory objects across a network to another host or persist it to storage, the in-memory
representation must be converted to a suitable format. This process is called marshalling and the revert operation is called
demarshalling.


10.13      Explain Serialization and Deserialization.

Java provides a mechanism, called object serialization where an object can be represented as a sequence of bytes and includes
the object’s data, as well as information about the object’s type, and the types of data stored in the object. Thus, serialization can
be seen as a way of flattening objects, in order to be stored on disk, and later, read back and reconstituted. Deserialisation is the
reverse process of converting an object from its flattened state to a live object.
-----------------------Page 24 End-----------------------

Java Interview Questions                                                                                                   25 / 30




Chapter 11


Servlets


11.1     What is a Servlet ?

The servlet is a Java programming language class used to process client requests and generate dynamic web content. Servlets are
mostly used to process or store data submitted by an HTML form, provide dynamic content and manage state information that
does not exist in the stateless HTTP protocol.


11.2     Explain the architechure of a Servlet.

The core abstraction that must be implemented by all servlets is the javax.servlet.Servlet interface. Each servlet must implement
it either directly or indirectly, either by extending javax.servlet.GenericServlet or javax.servlet.http.HTTPServlet. Finally, each
servlet is able to serve multiple requests in parallel using multithreading.


11.3     What is the difference between an Applet and a Servlet ?

An Applet is a client side java program that runs within a Web browser on the client machine. On the other hand, a servlet is a
server side component that runs on the web server.An applet can use the user interface classes, while a servlet does not have a
user interface. Instead, a servlet waits for client’s HTTP requests and generates a response in every request.


11.4     What is the difference between GenericServlet and HttpServlet ?

GenericServlet is a generalized and protocol-independent servlet that implements the Servlet and ServletConfig interfaces. Those
servlets extending the GenericServlet class shall override the service method. Finally, in order to develop an HTTP servlet for
use on the Web that serves requests using the HTTP protocol, your servlet must extend the HttpServlet instead. Check Servlet
examples here.


11.5     Explain the life cycle of a Servlet.

On every client’s request, the Servlet Engine loads the servlets and invokes its init methods, in order for the servlet to be
initialized. Then, the Servlet object handles all subsequent requests coming from that client, by invoking the service method for
each request separately. Finally, the servlet is removed by calling the server’s destroy method.
-----------------------Page 25 End-----------------------

Java Interview Questions                                                                                                     26 / 30




11.6     What is the difference between doGet() and doPost() ?

doGET: The GET method appends the name-value pairs on the request’s URL. Thus, there is a limit on the number of characters
and subsequently on the number of values that can be used in a client’s request. Furthermore, the values of the request are made
visible and thus, sensitive information must not be passed in that way.
doPOST: The POST method overcomes the limit imposed by the GET request, by sending the values of the request inside its
body. Also, there is no limitations on the number of values to be sent across. Finally, the sensitive information passed through a
POST request is not visible to an external client.


11.7     What is meant by a Web Application ?

A Web application is a dynamic extension of a Web or application server. There are two types of web applications: presentation-
oriented and service-oriented. A presentation-oriented Web application generates interactive web pages, which contain various
types of markup language and dynamic content in response to requests. On the other hand, a service-oriented web application
implements the endpoint of a web service. In general, a Web application can be seen as a collection of servlets installed under a
specific subset of the server’s URL namespace.


11.8     What is a Server Side Include (SSI) ?

Server Side Includes (SSI) is a simple interpreted server-side scripting language, used almost exclusively for the Web, and is
embedded with a servlet tag. The most frequent use of SSI is to include the contents of one or more files into a Web page on a
Web server. When a Web page is accessed by a browser, the Web server replaces the servlet tag in that Web page with the hyper
text generated by the corresponding servlet.


11.9     What is Servlet Chaining ?

Servlet Chaining is the method where the output of one servlet is sent to a second servlet. The output of the second servlet can
be sent to a third servlet, and so on. The last servlet in the chain is responsible for sending the response to the client.


11.10      How do you find out what client machine is making a request to your servlet
           ?

The ServletRequest class has functions for finding out the IP address or host name of the client machine. getRemoteAddr() gets
the IP address of the client machine and getRemoteHost() gets the host name of the client machine. See example here.


11.11      What is the structure of the HTTP response ?

The HTTP response consists of three parts:

• Status Code: describes the status of the response. It can be used to check if the request has been successfully completed. In
  case the request failed, the status code can be used to find out the reason behind the failure. If your servlet does not return a
  status code, the success status code, HttpServletResponse.SC_OK, is returned by default.
• HTTP Headers: they contain more information about the response. For example, the headers may specify the date/time after
  which the response is considered stale, or the form of encoding used to safely transfer the entity to the user. See how to retrieve
  headers in Servlet here.
• Body: it contains the content of the response. The body may contain HTML code, an image, etc. The body consists of the data
  bytes transmitted in an HTTP transaction message immediately following the headers.
-----------------------Page 26 End-----------------------

Java Interview Questions                                                                                                      27 / 30




11.12      What is a cookie ? What is the difference between session and cookie ?

A cookie is a bit of information that the Web server sends to the browser. The browser stores the cookies for each Web server
in a local file. In a future request, the browser, along with the request, sends all stored cookies for that specific Web server.The
differences between session and a cookie are the following:

• The session should work, regardless of the settings on the client browser. The client may have chosen to disable cookies.
  However, the sessions still work, as the client has no ability to disable them in the server side.
• The session and cookies also differ in the amount of information the can store. The HTTP session is capable of storing any
  Java object, while a cookie can only store String objects.


11.13      Which protocol will be used by browser and servlet to communicate ?

The browser communicates with a servlet by using the HTTP protocol.


11.14      What is HTTP Tunneling ?

HTTP Tunneling is a technique by which, communications performed using various network protocols are encapsulated using
the HTTP or HTTPS protocols. The HTTP protocol therefore acts as a wrapper for a channel that the network protocol being
tunneled uses to communicate. The masking of other protocol requests as HTTP requests is HTTP Tunneling.


11.15      What’s the difference between sendRedirect and forward methods ?

The sendRedirect method creates a new request, while the forward method just forwards a request to a new target. The previous
request scope objects are not available after a redirect, because it results in a new request. On the other hand, the previous request
scope objects are available after forwarding. FInally, in general, the sendRedirect method is considered to be slower compare to
the forward method.


11.16      What is URL Encoding and URL Decoding ?

The URL encoding procedure is responsible for replacing all the spaces and every other extra special character of a URL, into
their corresponding Hex representation. In correspondence, URL decoding is the exact opposite procedure.
-----------------------Page 27 End-----------------------

Java Interview Questions                                                                                                      28 / 30




Chapter 12


JSP


12.1     What is a JSP Page ?

A Java Server Page (JSP) is a text document that contains two types of text: static data and JSP elements. Static data can be
expressed in any text-based format, such as HTML or XML. JSP is a technology that mixes static content with dynamically-
generated content. See JSP example here.


12.2     How are the JSP requests handled ?

On the arrival of a JSP request, the browser first requests a page with a .jsp extension. Then, the Web server reads the request and
using the JSP compiler, the Web server converts the JSP page into a servlet class. Notice that the JSP file is compiled only on
the first request of the page, or if the JSP file has changed.The generated servlet class is invoked, in order to handle the browser’s
request. Once the execution of the request is over, the servlet sends a response back to the client. See how to get Request
parameters in a JSP.


12.3     What are the advantages of JSP ?

The advantages of using the JSP technology are shown below:

• JSP pages are dynamically compiled into servlets and thus, the developers can easily make updates to presentation code.

• JSP pages can be pre-compiled.
• JSP pages can be easily combined to static templates, including HTML or XML fragments, with code that generates dynamic
  content.
• Developers can offer customized JSP tag libraries that page authors access using an XML-like syntax.

• Developers can make logic changes at the component level, without editing the individual pages that use the application’s logic.


12.4     What are Directives ? What are the different types of Directives available in
         JSP ?

Directives are instructions that are processed by the JSP engine, when the page is compiled to a servlet. Directives are used to
set page-level instructions, insert data from external files, and specify custom tag libraries. Directives are defined between < %@
and % >. The different types of directives are shown below:
-----------------------Page 28 End-----------------------

Java Interview Questions                                                                                                   29 / 30



• Include directive: it is used to include a file and merges the content of the file with the current page.
• Page directive: it is used to define specific attributes in the JSP page, like error page and buffer.
• Taglib: it is used to declare a custom tag library which is used in the page.


12.5     What are JSP actions ?

JSP actions use constructs in XML syntax to control the behavior of the servlet engine. JSP actions are executed when a JSP
page is requested. They can be dynamically inserted into a file, re-use JavaBeans components, forward the user to another page,
or generate HTML for the Java plugin.Some of the available actions are listed below:

• jsp:include - includes a file, when the JSP page is requested.
• jsp:useBean - finds or instantiates a JavaBean.
• jsp:setProperty - sets the property of a JavaBean.
• jsp:getProperty - gets the property of a JavaBean.
• jsp:forward - forwards the requester to a new page.
• jsp:plugin - generates browser-specific code.


12.6     What are Scriptlets ?

In Java Server Pages (JSP) technology, a scriptlet is a piece of Java-code embedded in a JSP page. The scriptlet is everything
inside the tags. Between these tags, a user can add any valid scriplet.


12.7     What are Decalarations ?

Declarations are similar to variable declarations in Java. Declarations are used to declare variables for subsequent use in expres-
sions or scriptlets. To add a declaration, you must use the sequences to enclose your declarations.


12.8     What are Expressions ?

A JSP expression is used to insert the value of a scripting language expression, converted into a string, into the data stream
returned to the client, by the web server. Expressions are defined between <% =and %> tags.


12.9     What is meant by implicit objects and what are they ?

JSP implicit objects are those Java objects that the JSP Container makes available to developers in each page. A developer can
call them directly, without being explicitly declared. JSP Implicit Objects are also called pre-defined variables.The following
objects are considered implicit in a JSP page:

• application
• page
• request
• response
-----------------------Page 29 End-----------------------

Java Interview Questions   30 / 30



• session
• exception
• out

• config
• pageContext
-----------------------Page 30 End-----------------------
